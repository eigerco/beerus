Beerus Architecture Overview
============================

## Components

* Beerus client library (`src/client.rs`)
* Beerus RPC server
  - Based on `axum` HTTP server
  - RPC impl (`src/rpc.rs`)
* JSON-RPC spec (generated code: `src/gen.rs`)
  - Starknet spec 0.7.1 (`etc/spec/starknet/0.7.1`)
  - Generated by `iamgroot` (Rust DTO codegen tool)
* Feeder Gateway client (`src/feeder.rs`)
* Merkle proof check (`src/proof.rs`)
* Stateless execution (`src/exe/mod.rs`)
  - `blockifier`
  - `cairo-vm`
  - `cairo-lang-*`
* WebAssembly library (`web/beerus-web`)

## Execution

### Get current state

```mermaid
sequenceDiagram
Note right of Beerus: Beerus is ready
Beerus->>Feeder: Query State
Beerus->>Feeder: Get Latest Block
Feeder->>(Starknet RPC): Get Latest Block
(Starknet RPC)->>Feeder: Latest Block Number
Feeder->>Feeder: Verify received block
Feeder->>Beerus: Latest Block Number
Beerus->>Beerus: Store Current State
```

### Stateless call (RPC)

```mermaid
sequenceDiagram
(RPC Server)->>Beerus: starknet_call
Beerus->>Beerus: Check current state
Beerus->>Blockifier: Prepare execution context
Blockifier->>Blockifier: Create Starknet client
Blockifier->>Blockifier: Create State reader & write
loop Stateless Execution
Blockifier->>State Reader: State Request
State Reader->>(Starknet RPC): starknet_getStorageAt
(Starknet RPC)->>State Reader: storage result
State Reader->>(Starknet RPC): pathfinder_getProof
(Starknet RPC)->>State Reader: merkle proof
State Reader->>State Reader: verify merkle proof
State Reader->>Blockifier: State Result
end

(RPC Server)->>Beerus: starknet_getStorageAt
Beerus->>(Starknet RPC): pathfinder_getProof
(Starknet RPC)->>Beerus: merkle proof
Beerus->>Beerus: verify merkle proof
Beerus->>(RPC Server): storage result

Note right of (RPC Server): Other methods are proxied
(RPC Server)->>Beerus: starknet_*
Beerus->>(Starknet RPC): (proxy the request)
(Starknet RPC)->>Beerus: (proxy the response)
Beerus->>(RPC Server): response
```

### Stateless call (WASM)

```mermaid
sequenceDiagram
(Browser)->>(Browser): Check Proxy
(Browser)->>Beerus: Init
Note right of Beerus: Beerus is set up to run in a WebWorker
Beerus->>(Browser): Ready
(Browser)->>Beerus: Call
Beerus->>Client: Inject post() function
Client->>Client: create blocking StateReader
Note right of Client: Blocking StateReader is required by Blockifier
Client->>Client: create async StateReader
Client->>Beerus: Ready
Beerus->>Blockifier: Execute call
loop Stateless Execution
Blockifier->>Client: State Request
Client->>(Starknet RPC): State Request
(Starknet RPC)->>Client: State Result
Client->>(Starknet RPC): Get State Proof
(Starknet RPC)->>Client: State Proof
Client->>Client: Verify State Proof
Client->>Blockifier: State Result
end
Blockifier->>Beerus: Call Result
```

Beerus allows Blockifier to execute calls in a stateless manner by providing implementation of a `StateReader`. The `StateReader` implementation fetches necessary state (the value for the provided key to be exact) directly from Starknet RPC (and then pulls merkle proof for the value and verifies that it is valid). Thus during call execution Beerus has no control over which specific RPC methods are being called and how often - it depends on Blockifier and specific execution context of the call (contract & method that are being executed).

Beerus workload is purely IO bound, as the only computation being performed is the verification of a merkle proof for a received key-value pairs. Thus performance of the stateless call execution depends on latency and frequency of RPC calls performed by Blockifier.
