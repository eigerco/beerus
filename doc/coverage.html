<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","work","Work","Eiger","code","beerus","examples","call.rs"],"content":"use beerus::client::{Client, Http};\nuse beerus::config::Config;\nuse beerus::gen::{Address, Felt, FunctionCall};\nuse eyre::{Context, Result};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    tracing_subscriber::fmt::init();\n\n    let api_key = std::env::var(\"ALCHEMY_API_KEY\")\n        .context(\"ALCHEMY_API_KEY is missing\")?;\n\n    let config = Config {\n        starknet_rpc: format!(\n            \"https://starknet-mainnet.g.alchemy.com/starknet/version/rpc/v0_7/{api_key}\"\n        ),\n        gateway_url: None,\n        data_dir: \"tmp\".to_owned(),\n    };\n\n    let http = Http::new();\n    let beerus = Client::new(\u0026config, http).await?;\n\n    let calldata = FunctionCall {\n        contract_address: Address(Felt::try_new(\n            \"0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n        )?),\n        entry_point_selector: Felt::try_new(\n            \"0x361458367e696363fbcc70777d07ebbd2394e89fd0adcaf147faccd1d294d60\",\n        )?,\n        calldata: vec![],\n    };\n\n    let state = beerus.get_state().await?;\n    let res = beerus.execute(calldata, state)?;\n    println!(\"{:#?}\", res);\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","work","Work","Eiger","code","beerus","examples","state.rs"],"content":"use beerus::client::{Client, Http};\nuse beerus::config::Config;\nuse eyre::{Context, Result};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    tracing_subscriber::fmt::init();\n\n    let api_key = std::env::var(\"ALCHEMY_API_KEY\")\n        .context(\"ALCHEMY_API_KEY is missing\")?;\n\n    let config = Config {\n        starknet_rpc: format!(\n            \"https://starknet-mainnet.g.alchemy.com/starknet/version/rpc/v0_7/{api_key}\"\n        ),\n        gateway_url: None,\n        data_dir: \"tmp\".to_owned(),\n    };\n\n    let http = Http::new();\n    let beerus = Client::new(\u0026config, http).await?;\n\n    let state = beerus.get_state().await?;\n    tracing::info!(\"{state:#?}\");\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","work","Work","Eiger","code","beerus","src","bin","beerus.rs"],"content":"use std::{sync::Arc, time::Duration};\n\nuse beerus::{\n    client::Http,\n    config::{check_data_dir, ServerConfig},\n};\nuse tokio::sync::RwLock;\nuse validator::Validate;\n\n#[cfg(not(tarpaulin_include))] // exclude from code-coverage report\n#[tokio::main]\nasync fn main() -\u003e eyre::Result\u003c()\u003e {\n    tracing_subscriber::fmt::init();\n\n    let config = get_config().await?;\n\n    let http = Http::new();\n    let beerus = beerus::client::Client::new(\u0026config.client, http).await?;\n\n    let state = beerus.get_state().await?;\n    tracing::info!(?state, \"initialized\");\n    let state = Arc::new(RwLock::new(state));\n\n    {\n        let state = state.clone();\n        let period = Duration::from_secs(config.poll_secs);\n        tokio::spawn(async move {\n            let mut tick = tokio::time::interval(period);\n            let mut current = state.read().await.clone();\n            loop {\n                tick.tick().await;\n                match beerus.get_state().await {\n                    Ok(update) if update != current =\u003e {\n                        *state.write().await = update.clone();\n                        current = update;\n                        tracing::info!(state=?current, \"updated\");\n                    }\n                    Ok(_) =\u003e (),\n                    Err(e) =\u003e {\n                        tracing::error!(error=%e, \"state update failed\");\n                    }\n                }\n            }\n        });\n    }\n\n    let server = beerus::rpc::serve(\n        \u0026config.client.starknet_rpc,\n        \u0026config.rpc_addr,\n        state,\n    )\n    .await?;\n\n    tracing::info!(port = server.port(), \"rpc server started\");\n    server.done().await;\n\n    Ok(())\n}\n\n#[cfg(not(tarpaulin_include))] // exclude from code-coverage report\nasync fn get_config() -\u003e eyre::Result\u003cServerConfig\u003e {\n    let path = std::env::args().nth(1);\n    let config = if let Some(path) = path {\n        ServerConfig::from_file(\u0026path)?\n    } else {\n        ServerConfig::from_env()?\n    };\n    config.validate()?;\n    check_data_dir(\u0026config.client.data_dir)?;\n    Ok(config)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","work","Work","Eiger","code","beerus","src","client.rs"],"content":"use eyre::Result;\n\nuse crate::config::{get_gateway_url, Config};\nuse crate::feeder::GatewayClient;\nuse crate::gen::client::Client as StarknetClient;\nuse crate::gen::{gen, Felt, FunctionCall, Rpc};\n\nconst RPC_SPEC_VERSION: \u0026str = \"0.7.1\";\n\n#[derive(Debug, Clone)]\npub struct State {\n    pub block_number: u64,\n    pub block_hash: Felt,\n    pub root: Felt,\n}\n\nasync fn post\u003cQ: serde::Serialize, R: serde::de::DeserializeOwned\u003e(\n    client: \u0026reqwest::Client,\n    url: \u0026str,\n    request: Q,\n) -\u003e std::result::Result\u003cR, iamgroot::jsonrpc::Error\u003e {\n    let response = client\n        .post(url)\n        .json(\u0026request)\n        .send()\n        .await\n        .map_err(|e| {\n            iamgroot::jsonrpc::Error::new(\n                32101,\n                format!(\"request failed: {e:?}\"),\n            )\n        })?\n        .json()\n        .await\n        .map_err(|e| {\n            iamgroot::jsonrpc::Error::new(\n                32102,\n                format!(\"invalid response: {e:?}\"),\n            )\n        })?;\n    Ok(response)\n}\n\nimpl PartialEq\u003cState\u003e for State {\n    fn eq(\u0026self, other: \u0026State) -\u003e bool {\n        self.block_number == other.block_number\n            \u0026\u0026 self.root.as_ref() == other.root.as_ref()\n            \u0026\u0026 self.block_hash.as_ref() == other.block_hash.as_ref()\n    }\n}\n\n#[derive(Clone)]\npub struct Http(pub reqwest::Client);\n\nimpl Http {\n    #[allow(clippy::new_without_default)]\n    pub fn new() -\u003e Self {\n        Self(reqwest::Client::new())\n    }\n}\n\n#[cfg_attr(target_arch = \"wasm32\", async_trait::async_trait(?Send))]\n#[cfg_attr(not(target_arch = \"wasm32\"), async_trait::async_trait)]\nimpl gen::client::HttpClient for Http {\n    async fn post(\n        \u0026self,\n        url: \u0026str,\n        request: \u0026iamgroot::jsonrpc::Request,\n    ) -\u003e std::result::Result\u003c\n        iamgroot::jsonrpc::Response,\n        iamgroot::jsonrpc::Error,\n    \u003e {\n        post(\u0026self.0, url, request).await\n    }\n}\n\nimpl gen::client::blocking::HttpClient for Http {\n    fn post(\n        \u0026self,\n        url: \u0026str,\n        request: \u0026iamgroot::jsonrpc::Request,\n    ) -\u003e std::result::Result\u003c\n        iamgroot::jsonrpc::Response,\n        iamgroot::jsonrpc::Error,\n    \u003e {\n        #[cfg(target_arch = \"wasm32\")]\n        unreachable!(\"Blocking HTTP attempt: url={url} request={request:?}\");\n\n        #[cfg(not(target_arch = \"wasm32\"))]\n        {\n            ureq::post(url)\n                .send_json(request)\n                .map_err(|e| {\n                    iamgroot::jsonrpc::Error::new(33101, e.to_string())\n                })?\n                .into_json()\n                .map_err(|e| {\n                    iamgroot::jsonrpc::Error::new(33102, e.to_string())\n                })\n        }\n    }\n}\n\npub struct Client\u003c\n    T: gen::client::HttpClient\n        + gen::client::blocking::HttpClient\n        + Clone\n        + 'static,\n\u003e {\n    starknet: StarknetClient\u003cT\u003e,\n    gateway: GatewayClient,\n    http: T,\n}\n\nimpl\u003c\n        T: gen::client::HttpClient\n            + gen::client::blocking::HttpClient\n            + Clone\n            + 'static,\n    \u003e Client\u003cT\u003e\n{\n    pub async fn new(config: \u0026Config, http: T) -\u003e Result\u003cSelf\u003e {\n        let starknet = StarknetClient::new(\u0026config.starknet_rpc, http.clone());\n        let rpc_spec_version = starknet.specVersion().await?;\n        if rpc_spec_version != RPC_SPEC_VERSION {\n            eyre::bail!(\"RPC spec version mismatch: expected {RPC_SPEC_VERSION} but got {rpc_spec_version}\");\n        }\n        let url = if let Some(url) = config.gateway_url.as_ref() {\n            url.as_str()\n        } else {\n            get_gateway_url(\u0026config.starknet_rpc).await?\n        };\n        let gateway = GatewayClient::new(url)?;\n        Ok(Self { starknet, gateway, http })\n    }\n\n    pub fn starknet(\u0026self) -\u003e \u0026StarknetClient\u003cT\u003e {\n        \u0026self.starknet\n    }\n\n    pub fn execute(\n        \u0026self,\n        request: FunctionCall,\n        state: State,\n    ) -\u003e Result\u003cVec\u003cFelt\u003e\u003e {\n        let client = gen::client::blocking::Client::new(\n            \u0026self.starknet.url,\n            self.http.clone(),\n        );\n        let call_info = crate::exe::call(client, request, state)?;\n        call_info\n            .execution\n            .retdata\n            .0\n            .into_iter()\n            .map(|felt| as_felt(\u0026felt.to_bytes_be()))\n            .collect()\n    }\n\n    pub async fn get_state(\u0026self) -\u003e Result\u003cState\u003e {\n        self.gateway.get_state().await\n    }\n}\n\nfn as_felt(bytes: \u0026[u8]) -\u003e Result\u003cFelt\u003e {\n    // RPC spec FELT regex: leading zeroes are not allowed\n    let hex = hex::encode(bytes);\n    let hex = hex.chars().skip_while(|c| c == \u0026'0').collect::\u003cString\u003e();\n    let hex = format!(\"0x{hex}\");\n    let felt = Felt::try_new(\u0026hex)?;\n    Ok(felt)\n}\n","traces":[{"line":17,"address":[11148640],"length":1,"stats":{"Line":28}},{"line":22,"address":[11149813,11149239,11149589,11149973,11149472,11148944,11149533,11150052,11148831,11149025,11149301,11149748],"length":1,"stats":{"Line":136}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[11148935],"length":1,"stats":{"Line":29}},{"line":26,"address":[13225180],"length":1,"stats":{"Line":73}},{"line":27,"address":[11150080,11150390],"length":1,"stats":{"Line":0}},{"line":28,"address":[11150345],"length":1,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[11150246],"length":1,"stats":{"Line":0}},{"line":34,"address":[13225199],"length":1,"stats":{"Line":25}},{"line":35,"address":[11150416,11150726],"length":1,"stats":{"Line":0}},{"line":36,"address":[11150681],"length":1,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[11150582],"length":1,"stats":{"Line":0}},{"line":41,"address":[11149919],"length":1,"stats":{"Line":8}},{"line":45,"address":[11778768],"length":1,"stats":{"Line":0}},{"line":46,"address":[11778791],"length":1,"stats":{"Line":0}},{"line":47,"address":[11778812],"length":1,"stats":{"Line":0}},{"line":48,"address":[11778873],"length":1,"stats":{"Line":0}},{"line":57,"address":[11778944],"length":1,"stats":{"Line":29}},{"line":58,"address":[11778945],"length":1,"stats":{"Line":29}},{"line":73,"address":[13221479],"length":1,"stats":{"Line":47}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[11779328,11780170],"length":1,"stats":{"Line":0}},{"line":167,"address":[11779361],"length":1,"stats":{"Line":0}},{"line":168,"address":[11151040,11151054],"length":1,"stats":{"Line":0}},{"line":169,"address":[11779661],"length":1,"stats":{"Line":0}},{"line":170,"address":[11779790,11780024,11779859],"length":1,"stats":{"Line":0}},{"line":171,"address":[11779977],"length":1,"stats":{"Line":0}}],"covered":9,"coverable":50},{"path":["/","home","work","Work","Eiger","code","beerus","src","config.rs"],"content":"use std::fs;\nuse std::net::SocketAddr;\nuse std::path::Path;\n\nuse eyre::{eyre, Context, Result};\n\nuse serde::Deserialize;\nuse validator::Validate;\n\n#[cfg(not(target_arch = \"wasm32\"))]\nconst DEFAULT_DATA_DIR: \u0026str = \"tmp\";\nconst DEFAULT_POLL_SECS: u64 = 30;\n\npub const MAINNET_STARKNET_CHAINID: \u0026str = \"0x534e5f4d41494e\";\npub const SEPOLIA_STARKNET_CHAINID: \u0026str = \"0x534e5f5345504f4c4941\";\n\n#[derive(Clone, Deserialize, Debug, Validate)]\npub struct ServerConfig {\n    #[serde(flatten)]\n    pub client: Config,\n    #[serde(default = \"default_poll_secs\")]\n    #[validate(range(min = 1, max = 3600))]\n    pub poll_secs: u64,\n    #[serde(default = \"default_rpc_addr\")]\n    pub rpc_addr: SocketAddr,\n}\n\n#[derive(Clone, Deserialize, Debug, Validate)]\npub struct Config {\n    #[validate(url)]\n    pub starknet_rpc: String,\n    #[validate(url)]\n    pub gateway_url: Option\u003cString\u003e,\n    #[cfg(not(target_arch = \"wasm32\"))]\n    #[serde(default = \"default_data_dir\")]\n    pub data_dir: String,\n    // TODO: Add feeder public key option\n}\n\n#[cfg(not(target_arch = \"wasm32\"))]\nfn default_data_dir() -\u003e String {\n    DEFAULT_DATA_DIR.to_owned()\n}\n\nfn default_poll_secs() -\u003e u64 {\n    DEFAULT_POLL_SECS\n}\n\nfn default_rpc_addr() -\u003e SocketAddr {\n    SocketAddr::from(([0, 0, 0, 0], 3030))\n}\n\nimpl ServerConfig {\n    pub fn from_env() -\u003e Result\u003cSelf\u003e {\n        let poll_secs = if let Ok(poll_secs) = std::env::var(\"POLL_SECS\") {\n            poll_secs.parse()?\n        } else {\n            DEFAULT_POLL_SECS\n        };\n        let rpc_addr = if let Ok(rpc_addr) = std::env::var(\"RPC_ADDR\") {\n            rpc_addr.parse()?\n        } else {\n            default_rpc_addr()\n        };\n        Ok(Self {\n            client: Config {\n                starknet_rpc: std::env::var(\"STARKNET_RPC\")\n                    .context(\"STARKNET_RPC env var missing\")?,\n                gateway_url: std::env::var(\"GATEWAY_URL\").ok(),\n                #[cfg(not(target_arch = \"wasm32\"))]\n                data_dir: std::env::var(\"DATA_DIR\")\n                    .unwrap_or_else(|_| default_data_dir()),\n            },\n            poll_secs,\n            rpc_addr,\n        })\n    }\n\n    pub fn from_file(path: \u0026str) -\u003e Result\u003cSelf\u003e {\n        let content = fs::read_to_string(path)?;\n        Ok(toml::from_str(\u0026content)?)\n    }\n}\n\npub async fn get_gateway_url(starknet_rpc: \u0026str) -\u003e Result\u003c\u0026'static str\u003e {\n    let chain_id = call_method(starknet_rpc, \"starknet_chainId\").await?;\n    match chain_id.as_str() {\n        MAINNET_STARKNET_CHAINID =\u003e Ok(\"https://alpha-mainnet.starknet.io\"),\n        SEPOLIA_STARKNET_CHAINID =\u003e Ok(\"https://alpha-sepolia.starknet.io\"),\n        _ =\u003e eyre::bail!(\"Unexpected chain id: {}\", chain_id),\n    }\n}\n\npub fn check_data_dir\u003cP: AsRef\u003cPath\u003e\u003e(path: \u0026P) -\u003e Result\u003c()\u003e {\n    let path = path.as_ref();\n    if !path.exists() {\n        eyre::bail!(\"path does not exist\");\n    };\n\n    let meta = path.metadata().context(\"path metadata is missing\")?;\n\n    if meta.permissions().readonly() {\n        eyre::bail!(\"path is readonly\");\n    }\n\n    Ok(())\n}\n\nasync fn call_method(url: \u0026str, method: \u0026str) -\u003e Result\u003cString\u003e {\n    let response: serde_json::Value = reqwest::Client::new()\n        .post(url)\n        .json(\u0026serde_json::json!({\n            \"jsonrpc\": \"2.0\",\n            \"method\": method,\n            \"params\": [],\n            \"id\": 0\n        }))\n        .send()\n        .await?\n        .json()\n        .await?;\n\n    if let Some(error) = response[\"error\"].as_str() {\n        eyre::bail!(\"rpc error: {error}\");\n    }\n    if let Some(error) = response[\"error\"].as_object() {\n        let error = serde_json::to_string(error)?;\n        eyre::bail!(\"rpc error: {error}\");\n    }\n\n    response[\"result\"]\n        .as_str()\n        .map(|result| result.to_owned())\n        .ok_or_else(|| eyre!(\"Result missing for method={method}\"))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn wrong_urls() {\n        let config = ServerConfig {\n            client: Config {\n                starknet_rpc: \"bar\".to_string(),\n                gateway_url: None,\n                data_dir: Default::default(),\n            },\n            poll_secs: 300,\n            rpc_addr: SocketAddr::from(([0, 0, 0, 0], 3030)),\n        };\n        let response = config.client.validate();\n\n        assert!(response.is_err());\n        assert!(response.unwrap_err().to_string().contains(\"starknet_rpc\"));\n    }\n\n    #[tokio::test]\n    async fn wrong_poll_secs() {\n        let config = ServerConfig {\n            client: Config {\n                starknet_rpc: \"bar\".to_string(),\n                gateway_url: None,\n                data_dir: Default::default(),\n            },\n            poll_secs: 9999,\n            rpc_addr: SocketAddr::from(([127, 0, 0, 1], 3030)),\n        };\n        let response = config.validate();\n\n        assert!(response.is_err());\n        assert!(response.unwrap_err().to_string().contains(\"poll_secs\"));\n    }\n}\n","traces":[{"line":41,"address":[14257424],"length":1,"stats":{"Line":0}},{"line":42,"address":[14257432],"length":1,"stats":{"Line":0}},{"line":46,"address":[100326768],"length":1,"stats":{"Line":0}},{"line":49,"address":[14257472],"length":1,"stats":{"Line":0}},{"line":50,"address":[14257484],"length":1,"stats":{"Line":0}},{"line":54,"address":[16588336,16591869,16592191],"length":1,"stats":{"Line":0}},{"line":55,"address":[92870720],"length":1,"stats":{"Line":0}},{"line":56,"address":[16588459],"length":1,"stats":{"Line":0}},{"line":58,"address":[14257706],"length":1,"stats":{"Line":0}},{"line":60,"address":[14258084,14258148],"length":1,"stats":{"Line":0}},{"line":61,"address":[14258289,14258196,14258449],"length":1,"stats":{"Line":0}},{"line":63,"address":[14258599,14258213],"length":1,"stats":{"Line":0}},{"line":65,"address":[14259316],"length":1,"stats":{"Line":0}},{"line":66,"address":[14259099],"length":1,"stats":{"Line":0}},{"line":67,"address":[14258788,14258639,14258904],"length":1,"stats":{"Line":0}},{"line":68,"address":[14258888],"length":1,"stats":{"Line":0}},{"line":69,"address":[14258852,14258966],"length":1,"stats":{"Line":0}},{"line":70,"address":[100327031],"length":1,"stats":{"Line":0}},{"line":71,"address":[14259065,14258993],"length":1,"stats":{"Line":0}},{"line":72,"address":[13366608,13366624],"length":1,"stats":{"Line":0}},{"line":74,"address":[14259243],"length":1,"stats":{"Line":0}},{"line":75,"address":[14259252],"length":1,"stats":{"Line":0}},{"line":79,"address":[16589556,16589477],"length":1,"stats":{"Line":0}},{"line":80,"address":[14259684,14259553],"length":1,"stats":{"Line":0}},{"line":81,"address":[16589774,16589645,16590043],"length":1,"stats":{"Line":0}},{"line":85,"address":[14260141,14260128],"length":1,"stats":{"Line":0}},{"line":86,"address":[16590239,16589703],"length":1,"stats":{"Line":0}},{"line":87,"address":[16590580,16590363],"length":1,"stats":{"Line":0}},{"line":88,"address":[16591041,16590902,16591181],"length":1,"stats":{"Line":0}},{"line":89,"address":[16590415],"length":1,"stats":{"Line":0}},{"line":90,"address":[16590781],"length":1,"stats":{"Line":0}},{"line":94,"address":[16591087,16590253],"length":1,"stats":{"Line":0}},{"line":95,"address":[16588418,16588644,16592064,16591183,16588508,16591089,16592212],"length":1,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[16592327,16592447],"length":1,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[16592566,16592628,16592368,16592286],"length":1,"stats":{"Line":0}},{"line":109,"address":[14260160,14260183],"length":1,"stats":{"Line":0}},{"line":110,"address":[8345289,8344919,8344295,8342022,8345119,8344726,8342207,8344981,8345534,8346989,8344874,8344186,8344241,8344646],"length":1,"stats":{"Line":0}},{"line":111,"address":[67771523],"length":1,"stats":{"Line":0}},{"line":112,"address":[8343227,8342732,8343936,8344360,8342297,8344401,8342345],"length":1,"stats":{"Line":0}},{"line":119,"address":[8336130],"length":1,"stats":{"Line":0}},{"line":121,"address":[8336152,8336424,8336409],"length":1,"stats":{"Line":0}},{"line":123,"address":[8345671],"length":1,"stats":{"Line":0}},{"line":124,"address":[8345981],"length":1,"stats":{"Line":0}},{"line":126,"address":[8346128,8345939],"length":1,"stats":{"Line":0}},{"line":127,"address":[8346533,8346210,8346760,8346259],"length":1,"stats":{"Line":0}},{"line":128,"address":[8346618],"length":1,"stats":{"Line":0}},{"line":131,"address":[8346960,8346217,8346888],"length":1,"stats":{"Line":0}},{"line":133,"address":[8347024,8347046],"length":1,"stats":{"Line":0}},{"line":134,"address":[8347072,8347083,8347149,8346932],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":53},{"path":["/","home","work","Work","Eiger","code","beerus","src","exe","cache.rs"],"content":"use alloy_primitives::U256;\nuse blockifier::state::state_api::{State as BlockifierState, StateReader};\nuse lru::LruCache;\nuse starknet_api::{core::ContractAddress, state::StorageKey};\nuse starknet_types_core::felt::Felt as StarkFelt;\nuse std::num::NonZeroUsize;\nuse std::sync::{LazyLock, Mutex};\n\nuse crate::gen;\n\nmod storage {\n    use super::*;\n\n    type Key = (U256, U256, U256); // block hash + contract address + storage key\n    type Value = StarkFelt;\n\n    const SIZE: usize = 1024;\n\n    static CACHE: LazyLock\u003cMutex\u003cLruCache\u003cKey, Value\u003e\u003e\u003e = LazyLock::new(|| {\n        Mutex::new(LruCache::new(NonZeroUsize::new(SIZE).unwrap()))\n    });\n\n    pub fn get(key: \u0026Key) -\u003e Option\u003cValue\u003e {\n        let mut guard = CACHE.lock().expect(\"storage-cache-lock\");\n        guard.get(key).cloned()\n    }\n\n    pub fn set(key: Key, value: Value) -\u003e Option\u003cValue\u003e {\n        let mut guard = CACHE.lock().expect(\"storage-cache-lock\");\n        guard.put(key, value)\n    }\n\n    pub fn key(\n        block_hash: \u0026gen::Felt,\n        contract_address: \u0026ContractAddress,\n        storage_key: \u0026StorageKey,\n    ) -\u003e Key {\n        (\n            block_hash.as_ref().parse().unwrap(),\n            U256::from_be_bytes(contract_address.0.key().to_bytes_be()),\n            U256::from_be_bytes(storage_key.0.key().to_bytes_be()),\n        )\n    }\n}\n\nmod class_hash {\n    use super::*;\n\n    type Key = (U256, U256); // block hash + contract address\n    type Value = starknet_api::core::ClassHash;\n\n    const SIZE: usize = 256;\n\n    static CACHE: LazyLock\u003cMutex\u003cLruCache\u003cKey, Value\u003e\u003e\u003e = LazyLock::new(|| {\n        Mutex::new(LruCache::new(NonZeroUsize::new(SIZE).unwrap()))\n    });\n\n    pub fn get(key: \u0026Key) -\u003e Option\u003cValue\u003e {\n        let mut guard = CACHE.lock().expect(\"classhash-cache-lock\");\n        guard.get(key).cloned()\n    }\n\n    pub fn set(key: Key, value: Value) -\u003e Option\u003cValue\u003e {\n        let mut guard = CACHE.lock().expect(\"classhash-cache-lock\");\n        guard.put(key, value)\n    }\n\n    pub fn key(\n        block_hash: \u0026gen::Felt,\n        contract_address: \u0026ContractAddress,\n    ) -\u003e Key {\n        (\n            block_hash.as_ref().parse().unwrap(),\n            U256::from_be_bytes(contract_address.0.key().to_bytes_be()),\n        )\n    }\n}\n\nmod contract_class {\n    use super::*;\n\n    type Key = (U256, U256); // block hash + class hash\n    type Value = blockifier::execution::contract_class::ContractClass;\n\n    const SIZE: usize = 256;\n\n    static CACHE: LazyLock\u003cMutex\u003cLruCache\u003cKey, Value\u003e\u003e\u003e = LazyLock::new(|| {\n        Mutex::new(LruCache::new(NonZeroUsize::new(SIZE).unwrap()))\n    });\n\n    pub fn get(key: \u0026Key) -\u003e Option\u003cValue\u003e {\n        let mut guard = CACHE.lock().expect(\"contractclass-cache-lock\");\n        guard.get(key).cloned()\n    }\n\n    pub fn set(key: Key, value: Value) -\u003e Option\u003cValue\u003e {\n        let mut guard = CACHE.lock().expect(\"contractclass-cache-lock\");\n        guard.put(key, value)\n    }\n\n    pub fn key(\n        block_hash: \u0026gen::Felt,\n        class_hash: \u0026starknet_api::core::ClassHash,\n    ) -\u003e Key {\n        (\n            block_hash.as_ref().parse().unwrap(),\n            U256::from_be_bytes(class_hash.0.to_bytes_be()),\n        )\n    }\n}\n\npub trait HasBlockHash {\n    fn get_block_hash(\u0026self) -\u003e \u0026gen::Felt;\n}\n\npub struct CachedState\u003cT: StateReader + BlockifierState + HasBlockHash\u003e {\n    inner: T,\n}\n\nimpl\u003cT: StateReader + BlockifierState + HasBlockHash\u003e CachedState\u003cT\u003e {\n    pub fn new(inner: T) -\u003e Self {\n        Self { inner }\n    }\n}\n\nimpl\u003cT: StateReader + BlockifierState + HasBlockHash\u003e StateReader\n    for CachedState\u003cT\u003e\n{\n    fn get_storage_at(\n        \u0026self,\n        contract_address: ContractAddress,\n        storage_key: StorageKey,\n    ) -\u003e blockifier::state::state_api::StateResult\u003cStarkFelt\u003e {\n        let block_hash = self.inner.get_block_hash();\n        if let Some(ret) = storage::get(\u0026storage::key(\n            block_hash,\n            \u0026contract_address,\n            \u0026storage_key,\n        )) {\n            return Ok(ret);\n        }\n        let ret = self.inner.get_storage_at(contract_address, storage_key)?;\n        storage::set(\n            storage::key(block_hash, \u0026contract_address, \u0026storage_key),\n            ret,\n        );\n        Ok(ret)\n    }\n\n    fn get_nonce_at(\n        \u0026self,\n        contract_address: ContractAddress,\n    ) -\u003e blockifier::state::state_api::StateResult\u003cstarknet_api::core::Nonce\u003e\n    {\n        self.inner.get_nonce_at(contract_address)\n    }\n\n    fn get_class_hash_at(\n        \u0026self,\n        contract_address: ContractAddress,\n    ) -\u003e blockifier::state::state_api::StateResult\u003cstarknet_api::core::ClassHash\u003e\n    {\n        let block_hash = self.inner.get_block_hash();\n        if let Some(ret) =\n            class_hash::get(\u0026class_hash::key(block_hash, \u0026contract_address))\n        {\n            return Ok(ret);\n        }\n        let ret = self.inner.get_class_hash_at(contract_address)?;\n        class_hash::set(class_hash::key(block_hash, \u0026contract_address), ret);\n        Ok(ret)\n    }\n\n    fn get_compiled_contract_class(\n        \u0026self,\n        class_hash: starknet_api::core::ClassHash,\n    ) -\u003e blockifier::state::state_api::StateResult\u003c\n        blockifier::execution::contract_class::ContractClass,\n    \u003e {\n        let block_hash = self.inner.get_block_hash();\n        if let Some(ret) =\n            contract_class::get(\u0026contract_class::key(block_hash, \u0026class_hash))\n        {\n            return Ok(ret);\n        }\n        let ret = self.inner.get_compiled_contract_class(class_hash)?;\n        contract_class::set(\n            contract_class::key(block_hash, \u0026class_hash),\n            ret.clone(),\n        );\n        Ok(ret)\n    }\n\n    fn get_compiled_class_hash(\n        \u0026self,\n        class_hash: starknet_api::core::ClassHash,\n    ) -\u003e blockifier::state::state_api::StateResult\u003c\n        starknet_api::core::CompiledClassHash,\n    \u003e {\n        self.inner.get_compiled_class_hash(class_hash)\n    }\n}\n\nimpl\u003cT: StateReader + BlockifierState + HasBlockHash\u003e BlockifierState\n    for CachedState\u003cT\u003e\n{\n    fn set_storage_at(\n        \u0026mut self,\n        contract_address: ContractAddress,\n        storage_key: StorageKey,\n        value: StarkFelt,\n    ) -\u003e blockifier::state::state_api::StateResult\u003c()\u003e {\n        self.inner.set_storage_at(contract_address, storage_key, value)\n    }\n\n    fn increment_nonce(\n        \u0026mut self,\n        contract_address: ContractAddress,\n    ) -\u003e blockifier::state::state_api::StateResult\u003c()\u003e {\n        self.inner.increment_nonce(contract_address)\n    }\n\n    fn set_class_hash_at(\n        \u0026mut self,\n        contract_address: ContractAddress,\n        class_hash: starknet_api::core::ClassHash,\n    ) -\u003e blockifier::state::state_api::StateResult\u003c()\u003e {\n        self.inner.set_class_hash_at(contract_address, class_hash)\n    }\n\n    fn set_contract_class(\n        \u0026mut self,\n        class_hash: starknet_api::core::ClassHash,\n        contract_class: blockifier::execution::contract_class::ContractClass,\n    ) -\u003e blockifier::state::state_api::StateResult\u003c()\u003e {\n        self.inner.set_contract_class(class_hash, contract_class)\n    }\n\n    fn set_compiled_class_hash(\n        \u0026mut self,\n        class_hash: starknet_api::core::ClassHash,\n        compiled_class_hash: starknet_api::core::CompiledClassHash,\n    ) -\u003e blockifier::state::state_api::StateResult\u003c()\u003e {\n        self.inner.set_compiled_class_hash(class_hash, compiled_class_hash)\n    }\n\n    fn add_visited_pcs(\n        \u0026mut self,\n        class_hash: starknet_api::core::ClassHash,\n        pcs: \u0026std::collections::HashSet\u003cusize\u003e,\n    ) {\n        self.inner.add_visited_pcs(class_hash, pcs);\n    }\n}\n","traces":[{"line":19,"address":[14067632],"length":1,"stats":{"Line":2}},{"line":20,"address":[14067707,14067650],"length":1,"stats":{"Line":4}},{"line":23,"address":[13035172,13034944],"length":1,"stats":{"Line":2}},{"line":24,"address":[13034968],"length":1,"stats":{"Line":2}},{"line":25,"address":[13035051,13035114],"length":1,"stats":{"Line":4}},{"line":28,"address":[13035200,13035525],"length":1,"stats":{"Line":2}},{"line":29,"address":[13035227],"length":1,"stats":{"Line":2}},{"line":30,"address":[13035310,13035386],"length":1,"stats":{"Line":4}},{"line":33,"address":[13035552],"length":1,"stats":{"Line":2}},{"line":39,"address":[13035616],"length":1,"stats":{"Line":2}},{"line":40,"address":[13035803],"length":1,"stats":{"Line":2}},{"line":41,"address":[13035857],"length":1,"stats":{"Line":2}},{"line":54,"address":[10534896],"length":1,"stats":{"Line":2}},{"line":55,"address":[10534914,10534971],"length":1,"stats":{"Line":4}},{"line":58,"address":[13518036,13517808],"length":1,"stats":{"Line":4}},{"line":59,"address":[13517832],"length":1,"stats":{"Line":4}},{"line":60,"address":[13517915,13517978],"length":1,"stats":{"Line":4}},{"line":63,"address":[13518365,13518064],"length":1,"stats":{"Line":2}},{"line":64,"address":[13518091],"length":1,"stats":{"Line":2}},{"line":65,"address":[13518174,13518250],"length":1,"stats":{"Line":4}},{"line":68,"address":[13518384],"length":1,"stats":{"Line":4}},{"line":73,"address":[13518435],"length":1,"stats":{"Line":4}},{"line":74,"address":[13518622],"length":1,"stats":{"Line":4}},{"line":87,"address":[11164784],"length":1,"stats":{"Line":2}},{"line":88,"address":[11164802,11164859],"length":1,"stats":{"Line":4}},{"line":91,"address":[11165127,11164896],"length":1,"stats":{"Line":2}},{"line":92,"address":[11164910],"length":1,"stats":{"Line":2}},{"line":93,"address":[11164993,11165056],"length":1,"stats":{"Line":4}},{"line":96,"address":[11165559,11165152],"length":1,"stats":{"Line":2}},{"line":97,"address":[11165259,11165174],"length":1,"stats":{"Line":4}},{"line":98,"address":[11165411,11165339],"length":1,"stats":{"Line":4}},{"line":101,"address":[11165600],"length":1,"stats":{"Line":2}},{"line":106,"address":[11165651],"length":1,"stats":{"Line":2}},{"line":107,"address":[11165838],"length":1,"stats":{"Line":2}},{"line":121,"address":[13699856],"length":1,"stats":{"Line":4}},{"line":129,"address":[13699888],"length":1,"stats":{"Line":2}},{"line":134,"address":[13699934],"length":1,"stats":{"Line":2}},{"line":135,"address":[13699966],"length":1,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[13700058],"length":1,"stats":{"Line":1}},{"line":142,"address":[13700574,13700337,13700132],"length":1,"stats":{"Line":4}},{"line":144,"address":[13700401],"length":1,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[13700514],"length":1,"stats":{"Line":2}},{"line":150,"address":[13700640],"length":1,"stats":{"Line":0}},{"line":155,"address":[13700657],"length":1,"stats":{"Line":0}},{"line":158,"address":[13700720],"length":1,"stats":{"Line":4}},{"line":163,"address":[13700763],"length":1,"stats":{"Line":4}},{"line":164,"address":[13700790],"length":1,"stats":{"Line":4}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[13700882],"length":1,"stats":{"Line":2}},{"line":169,"address":[13701334,13701097,13700952],"length":1,"stats":{"Line":6}},{"line":170,"address":[13701161],"length":1,"stats":{"Line":2}},{"line":171,"address":[13701274],"length":1,"stats":{"Line":2}},{"line":174,"address":[13702049,13701392],"length":1,"stats":{"Line":2}},{"line":180,"address":[13701435],"length":1,"stats":{"Line":2}},{"line":181,"address":[13701511],"length":1,"stats":{"Line":2}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[13701548],"length":1,"stats":{"Line":1}},{"line":186,"address":[13701798,13701589,13701731],"length":1,"stats":{"Line":4}},{"line":188,"address":[13701779],"length":1,"stats":{"Line":2}},{"line":189,"address":[13701907],"length":1,"stats":{"Line":2}},{"line":191,"address":[13702013],"length":1,"stats":{"Line":2}},{"line":194,"address":[13702080],"length":1,"stats":{"Line":0}},{"line":200,"address":[13702097],"length":1,"stats":{"Line":0}},{"line":207,"address":[13702160],"length":1,"stats":{"Line":0}},{"line":213,"address":[13702177],"length":1,"stats":{"Line":0}},{"line":216,"address":[13702320],"length":1,"stats":{"Line":0}},{"line":220,"address":[13702337],"length":1,"stats":{"Line":0}},{"line":223,"address":[13702400],"length":1,"stats":{"Line":0}},{"line":228,"address":[13702417],"length":1,"stats":{"Line":0}},{"line":231,"address":[13702528],"length":1,"stats":{"Line":0}},{"line":236,"address":[13702555],"length":1,"stats":{"Line":0}},{"line":239,"address":[13702624],"length":1,"stats":{"Line":0}},{"line":244,"address":[13702641],"length":1,"stats":{"Line":0}},{"line":247,"address":[13702752],"length":1,"stats":{"Line":2}},{"line":252,"address":[13702766],"length":1,"stats":{"Line":2}}],"covered":59,"coverable":79},{"path":["/","home","work","Work","Eiger","code","beerus","src","exe","err.rs"],"content":"use cairo_lang_starknet_classes::casm_contract_class::StarknetSierraCompilationError;\nuse thiserror::Error as ThisError;\n\n#[derive(Debug, ThisError)]\npub enum Error {\n    #[error(\"io error: {0:?}\")]\n    Io(#[from] std::io::Error),\n    #[error(\"base64 error: {0:?}\")]\n    Base64(#[from] base64::DecodeError),\n    #[error(\"serde error: {0:?}\")]\n    Serde(#[from] serde_json::Error),\n    #[error(\"reqwest error: {0:?}\")]\n    Reqwest(#[from] reqwest::Error),\n    #[error(\"codegen error: {0:?}\")]\n    IamGroot(#[from] iamgroot::jsonrpc::Error),\n    #[error(\"starknet api error: {0:?}\")]\n    StarknetApi(#[from] starknet_api::StarknetApiError),\n    #[error(\"blockifier state error: {0:?}\")]\n    State(#[from] blockifier::state::errors::StateError),\n    #[error(\"blockifier entry point error: {0:?}\")]\n    EntryPoint(#[from] blockifier::execution::errors::EntryPointExecutionError),\n    #[error(\"blockifier transaction error: {0:?}\")]\n    Transaction(\n        #[from] blockifier::transaction::errors::TransactionExecutionError,\n    ),\n    #[error(\"sierra compilation error: {0:?}\")]\n    SierraCompilation(#[from] StarknetSierraCompilationError),\n    #[error(\"program error: {0}\")]\n    Program(String),\n    #[error(\"{0}\")]\n    Custom(\u0026'static str),\n}\n\nimpl From\u003cError\u003e for blockifier::state::errors::StateError {\n    fn from(error: Error) -\u003e Self {\n        blockifier::state::errors::StateError::StateReadError(format!(\n            \"{error:?}\"\n        ))\n    }\n}\n\nimpl From\u003cError\u003e for iamgroot::jsonrpc::Error {\n    fn from(error: Error) -\u003e Self {\n        match error {\n            Error::IamGroot(e) =\u003e e,\n            e =\u003e iamgroot::jsonrpc::Error { code: 500, message: e.to_string() },\n        }\n    }\n}\n","traces":[{"line":35,"address":[14207664,14207972],"length":1,"stats":{"Line":0}},{"line":36,"address":[198077335,198077439],"length":1,"stats":{"Line":0}},{"line":43,"address":[195790400,195790785],"length":1,"stats":{"Line":0}},{"line":44,"address":[11203942],"length":1,"stats":{"Line":0}},{"line":45,"address":[10328730],"length":1,"stats":{"Line":0}},{"line":46,"address":[10328808,10328874],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","home","work","Work","Eiger","code","beerus","src","exe","map.rs"],"content":"use blockifier::execution::contract_class::ContractClassV0;\nuse cairo_lang_starknet_classes::casm_contract_class::CasmContractClass;\nuse cairo_lang_starknet_classes::contract_class::ContractClass as CairoContractClass;\n\nuse self::gen::DeprecatedContractClass;\n\nuse super::*;\n\nimpl TryFrom\u003cgen::Felt\u003e for StarkFelt {\n    type Error = Error;\n    fn try_from(felt: gen::Felt) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let felt = felt.as_ref().as_str();\n        let felt = StarkFelt::from_hex_unchecked(felt);\n        Ok(felt)\n    }\n}\n\nimpl TryFrom\u003c\u0026StarkFelt\u003e for gen::Felt {\n    type Error = Error;\n    fn try_from(felt: \u0026StarkFelt) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let hex = hex::encode(felt.to_bytes_be());\n        let hex = {\n            // drop leading zeroes in order to match the regex\n            let hex = hex.trim_start_matches('0');\n            let hex = if hex.is_empty() { \"0\" } else { hex };\n            format!(\"0x{hex}\")\n        };\n        let felt = gen::Felt::try_new(\u0026hex)?;\n        Ok(felt)\n    }\n}\n\nimpl TryFrom\u003cStarkFelt\u003e for gen::Felt {\n    type Error = Error;\n    fn try_from(felt: StarkFelt) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let felt = \u0026felt;\n        felt.try_into()\n    }\n}\n\nimpl TryFrom\u003cgen::GetClassResult\u003e for ContractClass {\n    type Error = Error;\n\n    fn try_from(value: gen::GetClassResult) -\u003e Result\u003cSelf, Self::Error\u003e {\n        Ok(match value {\n            gen::GetClassResult::ContractClass(ref class) =\u003e {\n                let mut json = serde_json::to_value(\u0026value)?;\n                if let Some(abi) = class.abi.as_ref() {\n                    let abi: serde_json::Value = serde_json::from_str(abi)?;\n                    json[\"abi\"] = abi;\n                }\n                let contract_class: CairoContractClass =\n                    serde_json::from_value(json)?;\n                let casm_contract_class =\n                    CasmContractClass::from_contract_class(\n                        contract_class,\n                        /*add_pythonic_hints=*/ false,\n                        /*max_bytecode_size=*/ u16::MAX as usize,\n                    )?;\n                let class = casm_contract_class\n                    .try_into()\n                    .map_err(|e| Error::Program(format!(\"{e}\")))?;\n\n                ContractClass::V1(class)\n            }\n            gen::GetClassResult::DeprecatedContractClass(class) =\u003e {\n                let class = build_contract_class(class)?;\n                ContractClass::V0(class)\n            }\n        })\n    }\n}\n\nfn build_contract_class(\n    class: DeprecatedContractClass,\n) -\u003e Result\u003cContractClassV0, Error\u003e {\n    let program = decode_program(class.program.as_ref())?;\n\n    let mut class = serde_json::to_value(class)?;\n    class[\"program\"] = serde_json::from_str(\u0026program)?;\n    let json = serde_json::to_string(\u0026class)?;\n\n    let class = ContractClassV0::try_from_json_string(\u0026json)\n        .map_err(|e| Error::Program(format!(\"{e}\")))?;\n    Ok(class)\n}\n\nfn decode_program(program: \u0026str) -\u003e Result\u003cString, Error\u003e {\n    let program = decode_base64(program)?;\n    let program = decompress(\u0026program)?;\n    Ok(program)\n}\n\nfn decode_base64(input: \u0026str) -\u003e Result\u003cVec\u003cu8\u003e, Error\u003e {\n    use base64::{engine::general_purpose::STANDARD as BASE64, Engine as _};\n    let result = BASE64.decode(input)?;\n    Ok(result)\n}\n\nfn decompress(input: \u0026[u8]) -\u003e Result\u003cString, Error\u003e {\n    use flate2::read::GzDecoder;\n    use std::io::prelude::*;\n    let mut gz = GzDecoder::new(input);\n    let mut result = String::new();\n    gz.read_to_string(\u0026mut result)?;\n    Ok(result)\n}\n","traces":[{"line":11,"address":[11183936,11184141],"length":1,"stats":{"Line":2}},{"line":12,"address":[11183963,11184019],"length":1,"stats":{"Line":4}},{"line":13,"address":[11184056],"length":1,"stats":{"Line":3}},{"line":14,"address":[11184082],"length":1,"stats":{"Line":3}},{"line":20,"address":[10336320,10337203],"length":1,"stats":{"Line":4}},{"line":21,"address":[10336345],"length":1,"stats":{"Line":4}},{"line":24,"address":[10336396,10336464],"length":1,"stats":{"Line":8}},{"line":25,"address":[10336532],"length":1,"stats":{"Line":4}},{"line":26,"address":[10336718],"length":1,"stats":{"Line":4}},{"line":28,"address":[10336916,10336847,10337089],"length":1,"stats":{"Line":8}},{"line":29,"address":[10337034],"length":1,"stats":{"Line":4}},{"line":35,"address":[10337232],"length":1,"stats":{"Line":2}},{"line":36,"address":[10337244],"length":1,"stats":{"Line":2}},{"line":37,"address":[10337249],"length":1,"stats":{"Line":2}},{"line":44,"address":[10618847,10615904,10617738],"length":1,"stats":{"Line":2}},{"line":45,"address":[10616433,10615950],"length":1,"stats":{"Line":4}},{"line":46,"address":[10616155],"length":1,"stats":{"Line":2}},{"line":47,"address":[10618826,10616163,10616552,10616822],"length":1,"stats":{"Line":4}},{"line":48,"address":[10616905,10616794,10617699],"length":1,"stats":{"Line":6}},{"line":49,"address":[10616958,10617103,10617503],"length":1,"stats":{"Line":4}},{"line":50,"address":[10617540,10617719,10617356],"length":1,"stats":{"Line":2}},{"line":53,"address":[10616975,10618022,10618770,10617796],"length":1,"stats":{"Line":4}},{"line":55,"address":[10617988,10618386,10618100,10618733],"length":1,"stats":{"Line":4}},{"line":56,"address":[10617960],"length":1,"stats":{"Line":2}},{"line":60,"address":[10618456,10618649,10618699,10618264],"length":1,"stats":{"Line":4}},{"line":62,"address":[10596320,10596435,10596575],"length":1,"stats":{"Line":0}},{"line":64,"address":[10618552],"length":1,"stats":{"Line":2}},{"line":66,"address":[10616028],"length":1,"stats":{"Line":1}},{"line":67,"address":[10616254,10616140,10616503,10616381],"length":1,"stats":{"Line":2}},{"line":68,"address":[10616323],"length":1,"stats":{"Line":1}},{"line":74,"address":[13736936,13736845,13734880],"length":1,"stats":{"Line":1}},{"line":77,"address":[13734996,13735324,13734910,13736918],"length":1,"stats":{"Line":2}},{"line":79,"address":[13735651,13735398,13735161,13736904],"length":1,"stats":{"Line":2}},{"line":80,"address":[13736856,13735742,13735629],"length":1,"stats":{"Line":2}},{"line":81,"address":[13736854,13736455,13736272],"length":1,"stats":{"Line":1}},{"line":83,"address":[13736433,13736741,13736546],"length":1,"stats":{"Line":2}},{"line":84,"address":[10596656,10596771,10596911],"length":1,"stats":{"Line":0}},{"line":85,"address":[13736666],"length":1,"stats":{"Line":1}},{"line":88,"address":[13736976,13737513],"length":1,"stats":{"Line":1}},{"line":89,"address":[13737142,13737009],"length":1,"stats":{"Line":1}},{"line":90,"address":[13737457,13737116,13737255],"length":1,"stats":{"Line":2}},{"line":91,"address":[13737368],"length":1,"stats":{"Line":1}},{"line":94,"address":[13737536],"length":1,"stats":{"Line":1}},{"line":96,"address":[13737565,13737705],"length":1,"stats":{"Line":1}},{"line":97,"address":[13737665],"length":1,"stats":{"Line":1}},{"line":100,"address":[13737760,13738215],"length":1,"stats":{"Line":1}},{"line":103,"address":[13737793],"length":1,"stats":{"Line":1}},{"line":104,"address":[13737815],"length":1,"stats":{"Line":1}},{"line":105,"address":[13737948,13737863,13738136],"length":1,"stats":{"Line":2}},{"line":106,"address":[13738027],"length":1,"stats":{"Line":1}}],"covered":48,"coverable":50},{"path":["/","home","work","Work","Eiger","code","beerus","src","exe","mod.rs"],"content":"use std::{collections::HashSet, num::NonZeroU128, sync::Arc};\n\nuse blockifier::{\n    blockifier::block::{BlockInfo, GasPrices},\n    bouncer::BouncerConfig,\n    context::{BlockContext, ChainInfo, FeeTokenAddresses, TransactionContext},\n    execution::{\n        call_info::CallInfo,\n        common_hints::ExecutionMode,\n        contract_class::ContractClass,\n        entry_point::{CallEntryPoint, CallType, EntryPointExecutionContext},\n    },\n    state::{\n        errors::StateError,\n        state_api::{State as BlockifierState, StateReader, StateResult},\n    },\n    transaction::objects::{\n        CommonAccountFields, DeprecatedTransactionInfo, TransactionInfo,\n    },\n    versioned_constants::VersionedConstants,\n};\nuse starknet_api::{\n    block::{BlockNumber as StarknetBlockNumber, BlockTimestamp},\n    core::{\n        ChainId as BlockifierChainId, ClassHash, CompiledClassHash,\n        ContractAddress, EntryPointSelector, Nonce,\n    },\n    deprecated_contract_class::EntryPointType,\n    hash::StarkHash,\n    state::StorageKey as StarknetStorageKey,\n    transaction::{\n        Calldata, Fee, TransactionHash, TransactionSignature,\n        TransactionVersion,\n    },\n};\nuse starknet_types_core::felt::Felt as StarkFelt;\n\nuse crate::{\n    client::State,\n    gen::{self, blocking::Rpc},\n};\n\npub mod cache;\npub mod err;\npub mod map;\n\nuse err::Error;\n\npub fn call\u003cT: gen::client::blocking::HttpClient\u003e(\n    client: gen::client::blocking::Client\u003cT\u003e,\n    function_call: gen::FunctionCall,\n    state: State,\n) -\u003e Result\u003cCallInfo, Error\u003e {\n    let gen::FunctionCall { calldata, contract_address, entry_point_selector } =\n        function_call;\n\n    let calldata: Result\u003cVec\u003cStarkFelt\u003e, _\u003e =\n        calldata.into_iter().map(|felt| felt.try_into()).collect();\n\n    let contract_address: StarkFelt = contract_address.0.try_into()?;\n\n    let entry_point_selector: StarkFelt = entry_point_selector.try_into()?;\n\n    let one = NonZeroU128::new(1)\n        .ok_or_else(|| Error::Custom(\"NonZeroU128 is zero\"))?;\n    let block_info = BlockInfo {\n        block_number: StarknetBlockNumber::default(),\n        block_timestamp: BlockTimestamp::default(),\n        sequencer_address: ContractAddress::default(),\n        gas_prices: GasPrices {\n            eth_l1_gas_price: one,\n            strk_l1_gas_price: one,\n            eth_l1_data_gas_price: one,\n            strk_l1_data_gas_price: one,\n        },\n        use_kzg_da: false,\n    };\n\n    let chain_info = ChainInfo {\n        chain_id: BlockifierChainId::Mainnet,\n        fee_token_addresses: FeeTokenAddresses {\n            strk_fee_token_address: ContractAddress::default(),\n            eth_fee_token_address: ContractAddress::default(),\n        },\n    };\n\n    let versioned_constants = VersionedConstants::latest_constants().to_owned();\n\n    let bouncer_config = BouncerConfig::default();\n\n    let block_context = BlockContext::new(\n        block_info,\n        chain_info,\n        versioned_constants,\n        bouncer_config,\n    );\n\n    let tx_info = TransactionInfo::Deprecated(DeprecatedTransactionInfo {\n        common_fields: CommonAccountFields {\n            transaction_hash: TransactionHash::default(),\n            version: TransactionVersion(StarkFelt::ONE),\n            signature: TransactionSignature(vec![\n                StarkHash::ZERO,\n                StarkHash::ZERO,\n            ]),\n            nonce: Nonce(StarkHash::ZERO),\n            sender_address: ContractAddress::default(),\n            only_query: true,\n        },\n        max_fee: Fee::default(),\n    });\n\n    let tx_context = Arc::new(TransactionContext { block_context, tx_info });\n    let limit_steps_by_resources = false;\n    let mut context = EntryPointExecutionContext::new(\n        tx_context.clone(),\n        ExecutionMode::Execute,\n        limit_steps_by_resources,\n    )?;\n\n    let call_entry_point = CallEntryPoint {\n        class_hash: None,\n        code_address: None,\n        entry_point_type: EntryPointType::External,\n        entry_point_selector: EntryPointSelector(entry_point_selector),\n        calldata: Calldata(Arc::new(calldata?)),\n        storage_address: ContractAddress(contract_address.try_into()?),\n        caller_address: ContractAddress::default(),\n        call_type: CallType::Call,\n        initial_gas: u64::MAX,\n    };\n\n    let state_proxy: StateProxy\u003cT\u003e = StateProxy { client, state };\n    let mut state_proxy = cache::CachedState::new(state_proxy);\n\n    let mut resources = Default::default();\n    let call_info = call_entry_point.execute(\n        \u0026mut state_proxy,\n        \u0026mut resources,\n        \u0026mut context,\n    )?;\n\n    tracing::debug!(?call_info, \"call completed\");\n    Ok(call_info)\n}\n\nstruct StateProxy\u003cT: gen::client::blocking::HttpClient\u003e {\n    client: gen::client::blocking::Client\u003cT\u003e,\n    state: State,\n}\n\nimpl\u003cT: gen::client::blocking::HttpClient\u003e cache::HasBlockHash\n    for StateProxy\u003cT\u003e\n{\n    fn get_block_hash(\u0026self) -\u003e \u0026gen::Felt {\n        \u0026self.state.block_hash\n    }\n}\n\nimpl\u003cT: gen::client::blocking::HttpClient\u003e StateReader for StateProxy\u003cT\u003e {\n    fn get_storage_at(\n        \u0026self,\n        contract_address: ContractAddress,\n        storage_key: StarknetStorageKey,\n    ) -\u003e StateResult\u003cStarkFelt\u003e {\n        tracing::info!(?contract_address, ?storage_key, \"get_storage_at\");\n\n        let felt: gen::Felt = contract_address.0.key().try_into()?;\n        let address = gen::Address(felt);\n\n        let key = gen::StorageKey::try_new(\u0026storage_key.0.to_string())\n            .map_err(Into::\u003cError\u003e::into)?;\n\n        let block_id = gen::BlockId::BlockHash {\n            block_hash: gen::BlockHash(self.state.block_hash.clone()),\n        };\n\n        let ret = self\n            .client\n            .getStorageAt(address.clone(), key.clone(), block_id.clone())\n            .map_err(Into::\u003cError\u003e::into)?;\n        tracing::info!(?address, ?key, value=?ret, \"get_storage_at\");\n\n        if ret.as_ref() == \"0x0\" {\n            tracing::info!(\"get_storage_at: skipping proof for zero value\");\n            return Ok(ret.try_into()?);\n        }\n\n        let proof = self\n            .client\n            .getProof(block_id, address.clone(), vec![key.clone()])\n            .map_err(Into::\u003cError\u003e::into)?;\n        tracing::info!(\"get_storage_at: proof received\");\n\n        let global_root = self.state.root.clone();\n        let value = ret.clone();\n        proof.verify(global_root, address, key, value).map_err(|e| {\n            StateError::StateReadError(format!(\n                \"Failed to verify merkle proof: {e:?}\"\n            ))\n        })?;\n        tracing::info!(\"get_storage_at: proof verified\");\n\n        Ok(ret.try_into()?)\n    }\n\n    fn get_nonce_at(\n        \u0026self,\n        contract_address: ContractAddress,\n    ) -\u003e StateResult\u003cNonce\u003e {\n        tracing::info!(?contract_address, \"get_nonce_at\");\n\n        let block_id = gen::BlockId::BlockHash {\n            block_hash: gen::BlockHash(self.state.block_hash.clone()),\n        };\n\n        let felt: gen::Felt = contract_address.0.key().try_into()?;\n        let contract_address = gen::Address(felt);\n\n        let ret = self\n            .client\n            .getNonce(block_id, contract_address)\n            .map_err(Into::\u003cError\u003e::into)?;\n\n        Ok(Nonce(ret.try_into()?))\n    }\n\n    fn get_class_hash_at(\n        \u0026self,\n        contract_address: ContractAddress,\n    ) -\u003e StateResult\u003cClassHash\u003e {\n        tracing::info!(?contract_address, \"get_class_hash_at\");\n\n        let block_id = gen::BlockId::BlockHash {\n            block_hash: gen::BlockHash(self.state.block_hash.clone()),\n        };\n\n        let felt: gen::Felt = contract_address.0.key().try_into()?;\n        let contract_address = gen::Address(felt);\n\n        let ret = self\n            .client\n            .getClassHashAt(block_id, contract_address)\n            .map_err(Into::\u003cError\u003e::into)?;\n\n        Ok(ClassHash(ret.try_into()?))\n    }\n\n    fn get_compiled_contract_class(\n        \u0026self,\n        class_hash: ClassHash,\n    ) -\u003e StateResult\u003cContractClass\u003e {\n        tracing::info!(?class_hash, \"get_compiled_contract_class\");\n\n        let block_id = gen::BlockId::BlockHash {\n            block_hash: gen::BlockHash(self.state.block_hash.clone()),\n        };\n\n        let class_hash: gen::Felt = class_hash.0.try_into()?;\n\n        let ret = self\n            .client\n            .getClass(block_id, class_hash)\n            .map_err(Into::\u003cError\u003e::into)?;\n\n        Ok(ret.try_into()?)\n    }\n\n    fn get_compiled_class_hash(\n        \u0026self,\n        class_hash: ClassHash,\n    ) -\u003e StateResult\u003cCompiledClassHash\u003e {\n        tracing::info!(?class_hash, \"get_compiled_class_hash\");\n        Err(StateError::UndeclaredClassHash(class_hash))\n    }\n}\n\nimpl\u003cT: gen::client::blocking::HttpClient\u003e BlockifierState for StateProxy\u003cT\u003e {\n    fn set_storage_at(\n        \u0026mut self,\n        contract_address: ContractAddress,\n        key: StarknetStorageKey,\n        value: StarkFelt,\n    ) -\u003e StateResult\u003c()\u003e {\n        tracing::info!(?contract_address, ?key, ?value, \"set_storage_at\");\n        Ok(())\n    }\n\n    fn increment_nonce(\n        \u0026mut self,\n        contract_address: ContractAddress,\n    ) -\u003e StateResult\u003c()\u003e {\n        tracing::info!(?contract_address, \"increment_nonce\");\n        Ok(())\n    }\n\n    fn set_class_hash_at(\n        \u0026mut self,\n        contract_address: ContractAddress,\n        class_hash: ClassHash,\n    ) -\u003e StateResult\u003c()\u003e {\n        tracing::info!(?contract_address, ?class_hash, \"set_class_hash_at\");\n        Ok(())\n    }\n\n    fn set_contract_class(\n        \u0026mut self,\n        class_hash: ClassHash,\n        contract_class: ContractClass,\n    ) -\u003e StateResult\u003c()\u003e {\n        tracing::info!(?class_hash, ?contract_class, \"set_contract_class\");\n        Ok(())\n    }\n\n    fn set_compiled_class_hash(\n        \u0026mut self,\n        class_hash: ClassHash,\n        compiled_class_hash: CompiledClassHash,\n    ) -\u003e StateResult\u003c()\u003e {\n        tracing::info!(\n            ?class_hash,\n            ?compiled_class_hash,\n            \"set_compiled_class_hash\"\n        );\n        Ok(())\n    }\n\n    fn add_visited_pcs(\u0026mut self, class_hash: ClassHash, pcs: \u0026HashSet\u003cusize\u003e) {\n        tracing::info!(?class_hash, pcs.len = pcs.len(), \"add_visited_pcs\");\n    }\n}\n","traces":[{"line":49,"address":[11803342,11803906,11795248],"length":1,"stats":{"Line":2}},{"line":54,"address":[11795340],"length":1,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[11795515,11795583,11803980,11803952],"length":1,"stats":{"Line":8}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[11803586,11795645,11795941,11795753],"length":1,"stats":{"Line":5}},{"line":62,"address":[11795838,11803584,11796137,11795980],"length":1,"stats":{"Line":6}},{"line":64,"address":[11796065,11803582,11796381,11796192],"length":1,"stats":{"Line":6}},{"line":65,"address":[11796363,11804000,11804003],"length":1,"stats":{"Line":0}},{"line":67,"address":[11796312],"length":1,"stats":{"Line":4}},{"line":68,"address":[11796402],"length":1,"stats":{"Line":4}},{"line":69,"address":[11796425],"length":1,"stats":{"Line":4}},{"line":70,"address":[11796464],"length":1,"stats":{"Line":4}},{"line":81,"address":[11796740],"length":1,"stats":{"Line":4}},{"line":87,"address":[11796908,11796976],"length":1,"stats":{"Line":8}},{"line":89,"address":[11797011],"length":1,"stats":{"Line":4}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[11797056],"length":1,"stats":{"Line":4}},{"line":94,"address":[11797160],"length":1,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[11797862],"length":1,"stats":{"Line":4}},{"line":99,"address":[11797583],"length":1,"stats":{"Line":4}},{"line":100,"address":[11797273],"length":1,"stats":{"Line":4}},{"line":101,"address":[11797321],"length":1,"stats":{"Line":4}},{"line":102,"address":[11797361],"length":1,"stats":{"Line":4}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[11797505],"length":1,"stats":{"Line":4}},{"line":107,"address":[11797532],"length":1,"stats":{"Line":4}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[11797751],"length":1,"stats":{"Line":4}},{"line":113,"address":[11797947],"length":1,"stats":{"Line":4}},{"line":114,"address":[11795332],"length":1,"stats":{"Line":2}},{"line":116,"address":[11798110],"length":1,"stats":{"Line":4}},{"line":117,"address":[11798189],"length":1,"stats":{"Line":4}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[11798446],"length":1,"stats":{"Line":4}},{"line":126,"address":[11798478,11798670,11803457],"length":1,"stats":{"Line":8}},{"line":127,"address":[11799074,11798846,11798949],"length":1,"stats":{"Line":8}},{"line":128,"address":[11799059],"length":1,"stats":{"Line":4}},{"line":133,"address":[11799462],"length":1,"stats":{"Line":4}},{"line":134,"address":[11799644],"length":1,"stats":{"Line":4}},{"line":136,"address":[11799720],"length":1,"stats":{"Line":4}},{"line":137,"address":[11799768,11799916,11800226],"length":1,"stats":{"Line":6}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[11800913,11801046,11802026,11801203,11802093,11855684,11800714,11800298,11855527,11801651,11801473,11801750,11802685],"length":1,"stats":{"Line":12}},{"line":144,"address":[11801369],"length":1,"stats":{"Line":2}},{"line":155,"address":[11804032],"length":1,"stats":{"Line":4}},{"line":156,"address":[11804040],"length":1,"stats":{"Line":4}},{"line":161,"address":[11804048,11819660],"length":1,"stats":{"Line":2}},{"line":166,"address":[11804946,11806465,11804865,11805058,11804699,11805104,11806511,11804148,11856103,11804347,11806283,11806211,11856260,11806059],"length":1,"stats":{"Line":12}},{"line":168,"address":[11807416,11805951,11807245],"length":1,"stats":{"Line":4}},{"line":169,"address":[11807317],"length":1,"stats":{"Line":2}},{"line":171,"address":[11807605,11807525,11807397,11807849],"length":1,"stats":{"Line":6}},{"line":172,"address":[11822733,11807548,11807776],"length":1,"stats":{"Line":2}},{"line":175,"address":[11807919],"length":1,"stats":{"Line":2}},{"line":178,"address":[11808220,11808684,11808295,11822558],"length":1,"stats":{"Line":4}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[11808026,11808074,11822645,11808279],"length":1,"stats":{"Line":6}},{"line":181,"address":[11808666],"length":1,"stats":{"Line":0}},{"line":182,"address":[11809501,11809846,11809368,11810020,11856836,11808753,11810510,11809656,11810119,11810431,11811578,11809169,11856679],"length":1,"stats":{"Line":10}},{"line":184,"address":[11809770,11812572],"length":1,"stats":{"Line":4}},{"line":185,"address":[11819808,11820711,11821214,11821926,11820423,11820556,11820941,11820224,11821551,11857412,11821115,11821484,11857255],"length":1,"stats":{"Line":5}},{"line":186,"address":[11822237,11820825],"length":1,"stats":{"Line":2}},{"line":189,"address":[11813587,11819750,11813171,11813246],"length":1,"stats":{"Line":4}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[11812850,11812626,11813230,11819752],"length":1,"stats":{"Line":4}},{"line":192,"address":[11813569],"length":1,"stats":{"Line":0}},{"line":193,"address":[11857988,11814274,11814075,11815416,11815815,11857831,11813659,11814562,11815025,11815337,11814926,11814752,11814407],"length":1,"stats":{"Line":10}},{"line":195,"address":[11816132,11814684],"length":1,"stats":{"Line":4}},{"line":196,"address":[11816156],"length":1,"stats":{"Line":2}},{"line":197,"address":[11816204,11823188,11822880,11816670],"length":1,"stats":{"Line":2}},{"line":198,"address":[11823135,11823031],"length":1,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[11818112,11816706,11858564,11818902,11817609,11817122,11818503,11858407,11817321,11818424,11817454,11817839,11818013],"length":1,"stats":{"Line":10}},{"line":204,"address":[11819503,11819219,11817723],"length":1,"stats":{"Line":4}},{"line":207,"address":[11827031,11827118,11823216],"length":1,"stats":{"Line":0}},{"line":211,"address":[11858983,11824105,11824919,11824151,11823999,11825351,11823275,11823918,11825069,11825138,11825305,11823752,11859140,11823418],"length":1,"stats":{"Line":0}},{"line":214,"address":[11824778],"length":1,"stats":{"Line":0}},{"line":217,"address":[11825894,11826230,11824872,11827090],"length":1,"stats":{"Line":0}},{"line":218,"address":[11826050],"length":1,"stats":{"Line":0}},{"line":220,"address":[11826307,11826162,11826578],"length":1,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[11826122],"length":1,"stats":{"Line":0}},{"line":223,"address":[11826563],"length":1,"stats":{"Line":0}},{"line":225,"address":[11826463,11826640,11826914],"length":1,"stats":{"Line":0}},{"line":228,"address":[11831054,11827152,11830967],"length":1,"stats":{"Line":4}},{"line":232,"address":[11829241,11829074,11827354,11829287,11859559,11859716,11827211,11828855,11827935,11828087,11827854,11828041,11827688,11829005],"length":1,"stats":{"Line":24}},{"line":235,"address":[11828714],"length":1,"stats":{"Line":4}},{"line":238,"address":[11829830,11831026,11828808,11830166],"length":1,"stats":{"Line":8}},{"line":239,"address":[11829986],"length":1,"stats":{"Line":4}},{"line":241,"address":[11830098,11830514,11830243],"length":1,"stats":{"Line":6}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[11830058],"length":1,"stats":{"Line":4}},{"line":244,"address":[11830499],"length":1,"stats":{"Line":0}},{"line":246,"address":[11830850,11830576,11830399],"length":1,"stats":{"Line":4}},{"line":249,"address":[11831088,11834868,11834781],"length":1,"stats":{"Line":2}},{"line":253,"address":[11833242,11831150,11831645,11831998,11860292,11833288,11832044,11831811,11832856,11833006,11831892,11860135,11833075,11831293],"length":1,"stats":{"Line":12}},{"line":256,"address":[11832678],"length":1,"stats":{"Line":2}},{"line":259,"address":[11834840,11832775,11834114,11833829],"length":1,"stats":{"Line":4}},{"line":261,"address":[11834468,11834046,11834191],"length":1,"stats":{"Line":4}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[11833966],"length":1,"stats":{"Line":2}},{"line":264,"address":[11834453],"length":1,"stats":{"Line":0}},{"line":266,"address":[11834664,11834373,11834530],"length":1,"stats":{"Line":4}},{"line":269,"address":[11834912,11836288],"length":1,"stats":{"Line":0}},{"line":273,"address":[11835540,11835718,11835618,11836511,11836730,11836897,11835061,11836661,11836290,11835764,11860711,11835392,11836943,11860868],"length":1,"stats":{"Line":0}},{"line":274,"address":[11836393],"length":1,"stats":{"Line":0}},{"line":279,"address":[11839275,11837440],"length":1,"stats":{"Line":0}},{"line":285,"address":[11839808,11838183,11839277,11861444,11839572,11861287,11838335,11837936,11837602,11838102,11839854,11838289,11839641,11839426],"length":1,"stats":{"Line":0}},{"line":286,"address":[11839383],"length":1,"stats":{"Line":0}},{"line":289,"address":[11842162,11840768],"length":1,"stats":{"Line":0}},{"line":293,"address":[11841248,11842738,11841492,11842456,11842164,11842525,11841414,11842692,11861863,11840917,11841592,11862020,11841638,11842310],"length":1,"stats":{"Line":0}},{"line":294,"address":[11842267],"length":1,"stats":{"Line":0}},{"line":297,"address":[11843248,11844855],"length":1,"stats":{"Line":0}},{"line":302,"address":[11843977,11843733,11845385,11843899,11845149,11845218,11845431,11862439,11844123,11862596,11843402,11844077,11845003,11844857],"length":1,"stats":{"Line":0}},{"line":303,"address":[11844960],"length":1,"stats":{"Line":0}},{"line":306,"address":[11846144,11847300,11849681],"length":1,"stats":{"Line":0}},{"line":311,"address":[11847302,11848062,11847507,11863015,11848938,11848129,11863172,11847780,11846813,11846397,11847145,11847681,11847012],"length":1,"stats":{"Line":0}},{"line":312,"address":[11847424],"length":1,"stats":{"Line":0}},{"line":315,"address":[11851319,11849712],"length":1,"stats":{"Line":0}},{"line":320,"address":[11851613,11851849,11863591,11851321,11851467,11850441,11851682,11851895,11850363,11849866,11850197,11850541,11850587,11863748],"length":1,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[11851424],"length":1,"stats":{"Line":0}},{"line":328,"address":[11852608,11854195],"length":1,"stats":{"Line":2}},{"line":329,"address":[11853091,11853317,11852760,11854197,11853463,11854326,11864167,11854541,11853417,11854472,11854708,11864324,11854754,11853239],"length":1,"stats":{"Line":10}}],"covered":77,"coverable":130},{"path":["/","home","work","Work","Eiger","code","beerus","src","feeder.rs"],"content":"use eyre::{Context, OptionExt, Result};\n\nuse crate::{client::State, gen::Felt};\n\npub struct GatewayClient {\n    url: String,\n    client: reqwest::Client,\n}\n\nimpl GatewayClient {\n    pub fn new(url: \u0026str) -\u003e Result\u003cSelf\u003e {\n        if url.ends_with('/') {\n            eyre::bail!(\"Gateway URL must not end with '/'.\");\n        }\n        Ok(Self { url: url.to_owned(), client: reqwest::Client::new() })\n    }\n\n    pub async fn get_pubkey(\u0026self, block_hash: \u0026str) -\u003e Result\u003cString\u003e {\n        let url = format!(\n            \"{}/feeder_gateway/get_public_key?blockHash={}\",\n            self.url, block_hash\n        );\n        let hex: String = self\n            .client\n            .get(\u0026url)\n            .send()\n            .await\n            .context(\"failed to send gateway request\")?\n            .text()\n            .await\n            .context(\"failed to receive gateway response\")?;\n        Ok(hex)\n    }\n\n    pub async fn get_signature(\n        \u0026self,\n        block_hash: \u0026str,\n    ) -\u003e Result\u003c(String, String)\u003e {\n        let url = format!(\n            \"{}/feeder_gateway/get_signature?blockHash={}\",\n            self.url, block_hash\n        );\n        let json: serde_json::Value = self\n            .client\n            .get(\u0026url)\n            .send()\n            .await\n            .context(\"failed to send gateway request\")?\n            .json()\n            .await\n            .context(\"failed to receive gateway response\")?;\n\n        let hash = json[\"block_hash\"]\n            .as_str()\n            .ok_or_eyre(\"gateway: invalid block hash\")?;\n        if hash != block_hash {\n            eyre::bail!(\"gateway: invalid block hash\");\n        }\n\n        let signature = json[\"signature\"]\n            .as_array()\n            .ok_or_eyre(\"gateway: invalid signature\")?;\n        if signature.len() != 2 {\n            eyre::bail!(\"gateway: invalid signature\");\n        }\n\n        let r = signature[0]\n            .as_str()\n            .map(ToOwned::to_owned)\n            .ok_or_eyre(\"gateway: invalid signature\")?;\n        let s = signature[1]\n            .as_str()\n            .map(ToOwned::to_owned)\n            .ok_or_eyre(\"gateway: invalid signature\")?;\n        Ok((r, s))\n    }\n\n    pub async fn get_state(\u0026self) -\u003e Result\u003cState\u003e {\n        let url =\n            format!(\"{}/feeder_gateway/get_block?blockNumber=latest\", self.url);\n        let json: serde_json::Value = self\n            .client\n            .get(\u0026url)\n            .send()\n            .await\n            .context(\"failed to send gateway request\")?\n            .json()\n            .await\n            .context(\"failed to receive gateway response\")?;\n\n        if json[\"status\"].as_str() != Some(\"ACCEPTED_ON_L2\") {\n            eyre::bail!(\"gateway: invalid block status\");\n        }\n\n        let block_number: u64 = json[\"block_number\"]\n            .as_u64()\n            .ok_or_eyre(\"gateway: fetching block_number failed\")?;\n        let block_hash = json[\"block_hash\"]\n            .as_str()\n            .map(ToOwned::to_owned)\n            .ok_or_eyre(\"gateway: fetching block_hash failed\")?;\n\n        // TODO: Verify block signature\n\n        let root = json[\"state_root\"]\n            .as_str()\n            .map(ToOwned::to_owned)\n            .ok_or_eyre(\"gateway: fetching state_root failed\")?;\n        Ok(State {\n            block_number,\n            block_hash: Felt::try_new(\u0026block_hash)?,\n            root: Felt::try_new(\u0026root)?,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use wiremock::{\n        matchers::{method, path, query_param},\n        Mock, MockServer, ResponseTemplate,\n    };\n\n    use super::*;\n\n    #[tokio::test]\n    async fn test_ok() -\u003e Result\u003c()\u003e {\n        const BLOCK_NUMBER: u64 = 1056427;\n        const BLOCK_HASH: \u0026str =\n            \"0x7c7b366f1b31a556ace49e1affe3b4ed3cfb5aa328b85307655ea70dadd0cc6\";\n        const STATE_ROOT: \u0026str =\n            \"0x33d912445ba4f73ce6d910f3952e722aef1c55ee81278b3039b50243278f561\";\n\n        let mock = MockServer::start().await;\n        Mock::given(method(\"GET\"))\n            .and(path(\"/feeder_gateway/get_block\"))\n            .and(query_param(\"blockNumber\", \"latest\"))\n            .respond_with(ResponseTemplate::new(200).set_body_json(\n                serde_json::json!({\n                    \"block_number\": BLOCK_NUMBER,\n                    \"block_hash\": BLOCK_HASH,\n                    \"state_root\": STATE_ROOT,\n                    \"status\": \"ACCEPTED_ON_L2\"\n                }),\n            ))\n            .mount(\u0026mock)\n            .await;\n\n        let gateway = GatewayClient::new(mock.uri().as_str())?;\n        let state = gateway.get_state().await?;\n\n        assert_eq!(state.root.as_ref(), STATE_ROOT);\n        assert_eq!(state.block_number, BLOCK_NUMBER);\n        assert_eq!(state.block_hash.as_ref(), BLOCK_HASH);\n        Ok(())\n    }\n}\n","traces":[{"line":11,"address":[13394288,13394607],"length":1,"stats":{"Line":1}},{"line":12,"address":[14181147],"length":1,"stats":{"Line":1}},{"line":13,"address":[10668125],"length":1,"stats":{"Line":0}},{"line":15,"address":[14181177,14181268],"length":1,"stats":{"Line":1}},{"line":18,"address":[14181458,14181440],"length":1,"stats":{"Line":0}},{"line":35,"address":[15740336],"length":1,"stats":{"Line":0}},{"line":78,"address":[13394736,13394744],"length":1,"stats":{"Line":4}},{"line":79,"address":[8365678],"length":1,"stats":{"Line":1}},{"line":81,"address":[8369930,8365827,8365882,8365803,8365936,8366468,8367156,8366423,8366165,8366239,8366533,8366683,8366834],"length":1,"stats":{"Line":9}},{"line":83,"address":[8365807],"length":1,"stats":{"Line":1}},{"line":85,"address":[11609807],"length":1,"stats":{"Line":4}},{"line":88,"address":[11609826],"length":1,"stats":{"Line":3}},{"line":91,"address":[11664486,11664621],"length":1,"stats":{"Line":2}},{"line":92,"address":[11664768,11667210],"length":1,"stats":{"Line":0}},{"line":95,"address":[11664726,11665030,11667208,11664805],"length":1,"stats":{"Line":2}},{"line":98,"address":[11665325,11664975,11665060,11667206],"length":1,"stats":{"Line":2}},{"line":105,"address":[11665399,11665650,11665270],"length":1,"stats":{"Line":2}},{"line":109,"address":[11666120],"length":1,"stats":{"Line":1}},{"line":111,"address":[11665737,11665891,11665617],"length":1,"stats":{"Line":2}},{"line":112,"address":[11665874,11666014,11666275],"length":1,"stats":{"Line":2}}],"covered":16,"coverable":20},{"path":["/","home","work","Work","Eiger","code","beerus","src","gen.rs"],"content":"pub use gen::*;\n\n// TODO: must be handled in iamgroot\n#[allow(clippy::needless_return)]\n// vvv GENERATED CODE BELOW vvv\n#[allow(clippy::module_inception)]\n#[allow(non_snake_case)]\n#[allow(clippy::enum_variant_names)]\n#[allow(clippy::large_enum_variant)]\npub mod gen {\n    use serde::{Deserialize, Serialize};\n    use serde_json::Value;\n\n    use iamgroot::jsonrpc;\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct Address(pub Felt);\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct BinaryNode {\n        pub binary: BinaryNodeBinary,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct BinaryNodeBinary {\n        pub left: Felt,\n        pub right: Felt,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct BlockBodyWithReceipts {\n        pub transactions: Vec\u003cTransactionAndReceipt\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct BlockBodyWithTxHashes {\n        pub transactions: Vec\u003cTxnHash\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct BlockBodyWithTxs {\n        pub transactions: Vec\u003cTransactionsInBlock\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct BlockHash(pub Felt);\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct BlockHeader {\n        pub block_hash: BlockHash,\n        pub block_number: BlockNumber,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub l1_da_mode: Option\u003cBlockHeaderL1DaMode\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub l1_data_gas_price: Option\u003cResourcePrice\u003e,\n        pub l1_gas_price: ResourcePrice,\n        pub new_root: Felt,\n        pub parent_hash: BlockHash,\n        pub sequencer_address: Felt,\n        pub starknet_version: String,\n        pub timestamp: BlockHeaderTimestamp,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum BlockHeaderL1DaMode {\n        #[serde(rename = \"BLOB\")]\n        Blob,\n        #[serde(rename = \"CALLDATA\")]\n        Calldata,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(try_from = \"i64\")]\n    pub struct BlockHeaderTimestamp(i64);\n\n    mod blockheadertimestamp {\n        use super::jsonrpc;\n        use super::BlockHeaderTimestamp;\n\n        static MIN: i64 = 0;\n        static MAX: i64 = 9223372036854775807;\n\n        impl BlockHeaderTimestamp {\n            pub fn try_new(value: i64) -\u003e Result\u003cSelf, jsonrpc::Error\u003e {\n                if value \u003c MIN {\n                    return Err(jsonrpc::Error {\n                    code: 1001,\n                    message: format!(\"BlockHeaderTimestamp value {value} must be \u003e {MIN}\"),\n                });\n                }\n                if value \u003e MAX {\n                    return Err(jsonrpc::Error {\n                    code: 1001,\n                    message: format!(\"BlockHeaderTimestamp value {value} must be \u003c {MAX}\"),\n                });\n                }\n                Ok(Self(value))\n            }\n        }\n\n        impl TryFrom\u003ci64\u003e for BlockHeaderTimestamp {\n            type Error = String;\n            fn try_from(value: i64) -\u003e Result\u003cSelf, Self::Error\u003e {\n                Self::try_new(value).map_err(|e| e.message)\n            }\n        }\n\n        impl AsRef\u003ci64\u003e for BlockHeaderTimestamp {\n            fn as_ref(\u0026self) -\u003e \u0026i64 {\n                \u0026self.0\n            }\n        }\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(untagged)]\n    pub enum BlockId {\n        BlockHash { block_hash: BlockHash },\n        BlockNumber { block_number: BlockNumber },\n        BlockTag(BlockTag),\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(try_from = \"i64\")]\n    pub struct BlockNumber(i64);\n\n    mod blocknumber {\n        use super::jsonrpc;\n        use super::BlockNumber;\n\n        static MIN: i64 = 0;\n        static MAX: i64 = 9223372036854775807;\n\n        impl BlockNumber {\n            pub fn try_new(value: i64) -\u003e Result\u003cSelf, jsonrpc::Error\u003e {\n                if value \u003c MIN {\n                    return Err(jsonrpc::Error {\n                        code: 1001,\n                        message: format!(\n                            \"BlockNumber value {value} must be \u003e {MIN}\"\n                        ),\n                    });\n                }\n                if value \u003e MAX {\n                    return Err(jsonrpc::Error {\n                        code: 1001,\n                        message: format!(\n                            \"BlockNumber value {value} must be \u003c {MAX}\"\n                        ),\n                    });\n                }\n                Ok(Self(value))\n            }\n        }\n\n        impl TryFrom\u003ci64\u003e for BlockNumber {\n            type Error = String;\n            fn try_from(value: i64) -\u003e Result\u003cSelf, Self::Error\u003e {\n                Self::try_new(value).map_err(|e| e.message)\n            }\n        }\n\n        impl AsRef\u003ci64\u003e for BlockNumber {\n            fn as_ref(\u0026self) -\u003e \u0026i64 {\n                \u0026self.0\n            }\n        }\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum BlockStatus {\n        #[serde(rename = \"PENDING\")]\n        Pending,\n        #[serde(rename = \"ACCEPTED_ON_L2\")]\n        AcceptedOnL2,\n        #[serde(rename = \"ACCEPTED_ON_L1\")]\n        AcceptedOnL1,\n        #[serde(rename = \"REJECTED\")]\n        Rejected,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum BlockTag {\n        #[serde(rename = \"latest\")]\n        Latest,\n        #[serde(rename = \"pending\")]\n        Pending,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct BlockWithReceipts {\n        pub status: BlockStatus,\n        #[serde(flatten)]\n        pub block_header: BlockHeader,\n        #[serde(flatten)]\n        pub block_body_with_receipts: BlockBodyWithReceipts,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct BlockWithTxHashes {\n        pub status: BlockStatus,\n        #[serde(flatten)]\n        pub block_header: BlockHeader,\n        #[serde(flatten)]\n        pub block_body_with_tx_hashes: BlockBodyWithTxHashes,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct BlockWithTxs {\n        pub status: BlockStatus,\n        #[serde(flatten)]\n        pub block_header: BlockHeader,\n        #[serde(flatten)]\n        pub block_body_with_txs: BlockBodyWithTxs,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(untagged)]\n    pub enum BroadcastedDeclareTxn {\n        BroadcastedDeclareTxnV1(BroadcastedDeclareTxnV1),\n        BroadcastedDeclareTxnV2(BroadcastedDeclareTxnV2),\n        BroadcastedDeclareTxnV3(BroadcastedDeclareTxnV3),\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct BroadcastedDeclareTxnV1 {\n        pub contract_class: DeprecatedContractClass,\n        pub max_fee: Felt,\n        pub nonce: Felt,\n        pub r#type: BroadcastedDeclareTxnV1Type,\n        pub sender_address: Address,\n        pub signature: Signature,\n        pub version: BroadcastedDeclareTxnV1Version,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum BroadcastedDeclareTxnV1Type {\n        #[serde(rename = \"DECLARE\")]\n        Declare,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum BroadcastedDeclareTxnV1Version {\n        #[serde(rename = \"0x1\")]\n        V0x1,\n        #[serde(rename = \"0x100000000000000000000000000000001\")]\n        V0x100000000000000000000000000000001,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct BroadcastedDeclareTxnV2 {\n        pub compiled_class_hash: Felt,\n        pub contract_class: ContractClass,\n        pub max_fee: Felt,\n        pub nonce: Felt,\n        pub r#type: BroadcastedDeclareTxnV2Type,\n        pub sender_address: Address,\n        pub signature: Signature,\n        pub version: BroadcastedDeclareTxnV2Version,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum BroadcastedDeclareTxnV2Type {\n        #[serde(rename = \"DECLARE\")]\n        Declare,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum BroadcastedDeclareTxnV2Version {\n        #[serde(rename = \"0x2\")]\n        V0x2,\n        #[serde(rename = \"0x100000000000000000000000000000002\")]\n        V0x100000000000000000000000000000002,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct BroadcastedDeclareTxnV3 {\n        pub account_deployment_data: Vec\u003cFelt\u003e,\n        pub compiled_class_hash: Felt,\n        pub contract_class: ContractClass,\n        pub fee_data_availability_mode: DaMode,\n        pub nonce: Felt,\n        pub nonce_data_availability_mode: DaMode,\n        pub paymaster_data: Vec\u003cFelt\u003e,\n        pub r#type: BroadcastedDeclareTxnV3Type,\n        pub resource_bounds: ResourceBoundsMapping,\n        pub sender_address: Address,\n        pub signature: Signature,\n        pub tip: U64,\n        pub version: BroadcastedDeclareTxnV3Version,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum BroadcastedDeclareTxnV3Type {\n        #[serde(rename = \"DECLARE\")]\n        Declare,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum BroadcastedDeclareTxnV3Version {\n        #[serde(rename = \"0x3\")]\n        V0x3,\n        #[serde(rename = \"0x100000000000000000000000000000003\")]\n        V0x100000000000000000000000000000003,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct BroadcastedDeployAccountTxn(pub DeployAccountTxn);\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct BroadcastedInvokeTxn(pub InvokeTxn);\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(untagged)]\n    pub enum BroadcastedTxn {\n        BroadcastedInvokeTxn(BroadcastedInvokeTxn),\n        BroadcastedDeclareTxn(BroadcastedDeclareTxn),\n        BroadcastedDeployAccountTxn(BroadcastedDeployAccountTxn),\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum CallType {\n        #[serde(rename = \"LIBRARY_CALL\")]\n        LibraryCall,\n        #[serde(rename = \"CALL\")]\n        Call,\n        #[serde(rename = \"DELEGATE\")]\n        Delegate,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(try_from = \"String\")]\n    pub struct ChainId(String);\n\n    mod chainid {\n        use super::jsonrpc;\n        use super::ChainId;\n        use once_cell::sync::Lazy;\n        use regex::Regex;\n\n        static CHAINID_REGEX: Lazy\u003cRegex\u003e = Lazy::new(|| {\n            Regex::new(\"^0x[a-fA-F0-9]+$\").expect(\"ChainId: valid regex\")\n        });\n\n        impl ChainId {\n            pub fn try_new(value: \u0026str) -\u003e Result\u003cSelf, jsonrpc::Error\u003e {\n                if CHAINID_REGEX.is_match(value) {\n                    Ok(Self(value.to_string()))\n                } else {\n                    Err(jsonrpc::Error {\n                        code: 1001,\n                        message: format!(\n                            \"ChainId value does not match regex: {value}\"\n                        ),\n                    })\n                }\n            }\n        }\n\n        impl TryFrom\u003cString\u003e for ChainId {\n            type Error = String;\n            fn try_from(value: String) -\u003e Result\u003cSelf, Self::Error\u003e {\n                Self::try_new(\u0026value).map_err(|e| e.message)\n            }\n        }\n\n        impl AsRef\u003cString\u003e for ChainId {\n            fn as_ref(\u0026self) -\u003e \u0026String {\n                \u0026self.0\n            }\n        }\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct CommonReceiptProperties {\n        pub actual_fee: FeePayment,\n        pub events: Vec\u003cEvent\u003e,\n        pub execution_resources: ExecutionResources,\n        pub finality_status: TxnFinalityStatus,\n        pub messages_sent: Vec\u003cMsgToL1\u003e,\n        pub transaction_hash: TxnHash,\n        #[serde(flatten)]\n        pub result_common_receipt_properties: ResultCommonReceiptProperties,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct ComputationResources {\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub bitwise_builtin_applications: Option\u003ci64\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub ec_op_builtin_applications: Option\u003ci64\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub ecdsa_builtin_applications: Option\u003ci64\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub keccak_builtin_applications: Option\u003ci64\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub memory_holes: Option\u003ci64\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub pedersen_builtin_applications: Option\u003ci64\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub poseidon_builtin_applications: Option\u003ci64\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub range_check_builtin_applications: Option\u003ci64\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub segment_arena_builtin: Option\u003ci64\u003e,\n        pub steps: i64,\n    }\n\n    type ContractAbi = Vec\u003cContractAbiEntry\u003e;\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(untagged)]\n    pub enum ContractAbiEntry {\n        FunctionAbiEntry(FunctionAbiEntry),\n        EventAbiEntry(EventAbiEntry),\n        StructAbiEntry(StructAbiEntry),\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct ContractClass {\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub abi: Option\u003cString\u003e,\n        pub contract_class_version: String,\n        pub entry_points_by_type: ContractClassEntryPointsByType,\n        pub sierra_program: Vec\u003cFelt\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct ContractClassEntryPointsByType {\n        #[serde(rename = \"CONSTRUCTOR\")]\n        pub constructor: Vec\u003cSierraEntryPoint\u003e,\n        #[serde(rename = \"EXTERNAL\")]\n        pub external: Vec\u003cSierraEntryPoint\u003e,\n        #[serde(rename = \"L1_HANDLER\")]\n        pub l1_handler: Vec\u003cSierraEntryPoint\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct ContractStorageDiffItem {\n        pub address: Felt,\n        pub storage_entries: Vec\u003cStorageDiffItem\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum DaMode {\n        #[serde(rename = \"L1\")]\n        L1,\n        #[serde(rename = \"L2\")]\n        L2,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(untagged)]\n    pub enum DeclareTxn {\n        DeclareTxnV0(DeclareTxnV0),\n        DeclareTxnV1(DeclareTxnV1),\n        DeclareTxnV2(DeclareTxnV2),\n        DeclareTxnV3(DeclareTxnV3),\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct DeclareTxnReceipt {\n        pub r#type: DeclareTxnReceiptType,\n        #[serde(flatten)]\n        pub common_receipt_properties: CommonReceiptProperties,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum DeclareTxnReceiptType {\n        #[serde(rename = \"DECLARE\")]\n        Declare,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct DeclareTxnTrace {\n        pub execution_resources: ExecutionResources,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub fee_transfer_invocation: Option\u003cFunctionInvocation\u003e,\n        pub r#type: DeclareTxnTraceType,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub state_diff: Option\u003cStateDiff\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub validate_invocation: Option\u003cFunctionInvocation\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum DeclareTxnTraceType {\n        #[serde(rename = \"DECLARE\")]\n        Declare,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct DeclareTxnV0 {\n        pub class_hash: Felt,\n        pub max_fee: Felt,\n        pub r#type: DeclareTxnV0Type,\n        pub sender_address: Address,\n        pub signature: Signature,\n        pub version: DeclareTxnV0Version,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum DeclareTxnV0Type {\n        #[serde(rename = \"DECLARE\")]\n        Declare,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum DeclareTxnV0Version {\n        #[serde(rename = \"0x0\")]\n        V0x0,\n        #[serde(rename = \"0x100000000000000000000000000000000\")]\n        V0x100000000000000000000000000000000,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct DeclareTxnV1 {\n        pub class_hash: Felt,\n        pub max_fee: Felt,\n        pub nonce: Felt,\n        pub r#type: DeclareTxnV1Type,\n        pub sender_address: Address,\n        pub signature: Signature,\n        pub version: DeclareTxnV1Version,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum DeclareTxnV1Type {\n        #[serde(rename = \"DECLARE\")]\n        Declare,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum DeclareTxnV1Version {\n        #[serde(rename = \"0x1\")]\n        V0x1,\n        #[serde(rename = \"0x100000000000000000000000000000001\")]\n        V0x100000000000000000000000000000001,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct DeclareTxnV2 {\n        pub class_hash: Felt,\n        pub compiled_class_hash: Felt,\n        pub max_fee: Felt,\n        pub nonce: Felt,\n        pub r#type: DeclareTxnV2Type,\n        pub sender_address: Address,\n        pub signature: Signature,\n        pub version: DeclareTxnV2Version,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum DeclareTxnV2Type {\n        #[serde(rename = \"DECLARE\")]\n        Declare,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum DeclareTxnV2Version {\n        #[serde(rename = \"0x2\")]\n        V0x2,\n        #[serde(rename = \"0x100000000000000000000000000000002\")]\n        V0x100000000000000000000000000000002,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct DeclareTxnV3 {\n        pub account_deployment_data: Vec\u003cFelt\u003e,\n        pub class_hash: Felt,\n        pub compiled_class_hash: Felt,\n        pub fee_data_availability_mode: DaMode,\n        pub nonce: Felt,\n        pub nonce_data_availability_mode: DaMode,\n        pub paymaster_data: Vec\u003cFelt\u003e,\n        pub r#type: DeclareTxnV3Type,\n        pub resource_bounds: ResourceBoundsMapping,\n        pub sender_address: Address,\n        pub signature: Signature,\n        pub tip: U64,\n        pub version: DeclareTxnV3Version,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum DeclareTxnV3Type {\n        #[serde(rename = \"DECLARE\")]\n        Declare,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum DeclareTxnV3Version {\n        #[serde(rename = \"0x3\")]\n        V0x3,\n        #[serde(rename = \"0x100000000000000000000000000000003\")]\n        V0x100000000000000000000000000000003,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(untagged)]\n    pub enum DeployAccountTxn {\n        DeployAccountTxnV1(DeployAccountTxnV1),\n        DeployAccountTxnV3(DeployAccountTxnV3),\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct DeployAccountTxnReceipt {\n        #[serde(flatten)]\n        pub common_receipt_properties: CommonReceiptProperties,\n        pub contract_address: Felt,\n        pub r#type: DeployAccountTxnReceiptType,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum DeployAccountTxnReceiptType {\n        #[serde(rename = \"DEPLOY_ACCOUNT\")]\n        DeployAccount,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct DeployAccountTxnTrace {\n        pub constructor_invocation: FunctionInvocation,\n        pub execution_resources: ExecutionResources,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub fee_transfer_invocation: Option\u003cFunctionInvocation\u003e,\n        pub r#type: DeployAccountTxnTraceType,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub state_diff: Option\u003cStateDiff\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub validate_invocation: Option\u003cFunctionInvocation\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum DeployAccountTxnTraceType {\n        #[serde(rename = \"DEPLOY_ACCOUNT\")]\n        DeployAccount,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct DeployAccountTxnV1 {\n        pub class_hash: Felt,\n        pub constructor_calldata: Vec\u003cFelt\u003e,\n        pub contract_address_salt: Felt,\n        pub max_fee: Felt,\n        pub nonce: Felt,\n        pub r#type: DeployAccountTxnV1Type,\n        pub signature: Signature,\n        pub version: DeployAccountTxnV1Version,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum DeployAccountTxnV1Type {\n        #[serde(rename = \"DEPLOY_ACCOUNT\")]\n        DeployAccount,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum DeployAccountTxnV1Version {\n        #[serde(rename = \"0x1\")]\n        V0x1,\n        #[serde(rename = \"0x100000000000000000000000000000001\")]\n        V0x100000000000000000000000000000001,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct DeployAccountTxnV3 {\n        pub class_hash: Felt,\n        pub constructor_calldata: Vec\u003cFelt\u003e,\n        pub contract_address_salt: Felt,\n        pub fee_data_availability_mode: DaMode,\n        pub nonce: Felt,\n        pub nonce_data_availability_mode: DaMode,\n        pub paymaster_data: Vec\u003cFelt\u003e,\n        pub r#type: DeployAccountTxnV3Type,\n        pub resource_bounds: ResourceBoundsMapping,\n        pub signature: Signature,\n        pub tip: U64,\n        pub version: DeployAccountTxnV3Version,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum DeployAccountTxnV3Type {\n        #[serde(rename = \"DEPLOY_ACCOUNT\")]\n        DeployAccount,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum DeployAccountTxnV3Version {\n        #[serde(rename = \"0x3\")]\n        V0x3,\n        #[serde(rename = \"0x100000000000000000000000000000003\")]\n        V0x100000000000000000000000000000003,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct DeployTxn {\n        pub class_hash: Felt,\n        pub constructor_calldata: Vec\u003cFelt\u003e,\n        pub contract_address_salt: Felt,\n        pub r#type: DeployTxnType,\n        pub version: Felt,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct DeployTxnReceipt {\n        #[serde(flatten)]\n        pub common_receipt_properties: CommonReceiptProperties,\n        pub contract_address: Felt,\n        pub r#type: DeployTxnReceiptType,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum DeployTxnReceiptType {\n        #[serde(rename = \"DEPLOY\")]\n        Deploy,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum DeployTxnType {\n        #[serde(rename = \"DEPLOY\")]\n        Deploy,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct DeployedContractItem {\n        pub address: Felt,\n        pub class_hash: Felt,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct DeprecatedCairoEntryPoint {\n        pub offset: NumAsHex,\n        pub selector: Felt,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct DeprecatedContractClass {\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub abi: Option\u003cContractAbi\u003e,\n        pub entry_points_by_type: DeprecatedContractClassEntryPointsByType,\n        pub program: DeprecatedContractClassProgram,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct DeprecatedContractClassEntryPointsByType {\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        #[serde(rename = \"CONSTRUCTOR\")]\n        pub constructor: Option\u003cVec\u003cDeprecatedCairoEntryPoint\u003e\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        #[serde(rename = \"EXTERNAL\")]\n        pub external: Option\u003cVec\u003cDeprecatedCairoEntryPoint\u003e\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        #[serde(rename = \"L1_HANDLER\")]\n        pub l1_handler: Option\u003cVec\u003cDeprecatedCairoEntryPoint\u003e\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(try_from = \"String\")]\n    pub struct DeprecatedContractClassProgram(String);\n\n    mod deprecatedcontractclassprogram {\n        use super::jsonrpc;\n        use super::DeprecatedContractClassProgram;\n        use once_cell::sync::Lazy;\n        use regex::Regex;\n\n        static DEPRECATEDCONTRACTCLASSPROGRAM_REGEX: Lazy\u003cRegex\u003e = Lazy::new(\n            || {\n                Regex::new(\"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)?$\").expect(\"DeprecatedContractClassProgram: valid regex\")\n            },\n        );\n\n        impl DeprecatedContractClassProgram {\n            pub fn try_new(value: \u0026str) -\u003e Result\u003cSelf, jsonrpc::Error\u003e {\n                if DEPRECATEDCONTRACTCLASSPROGRAM_REGEX.is_match(value) {\n                    Ok(Self(value.to_string()))\n                } else {\n                    Err(jsonrpc::Error {\n                    code: 1001,\n                    message: format!(\"DeprecatedContractClassProgram value does not match regex: {value}\"),\n                })\n                }\n            }\n        }\n\n        impl TryFrom\u003cString\u003e for DeprecatedContractClassProgram {\n            type Error = String;\n            fn try_from(value: String) -\u003e Result\u003cSelf, Self::Error\u003e {\n                Self::try_new(\u0026value).map_err(|e| e.message)\n            }\n        }\n\n        impl AsRef\u003cString\u003e for DeprecatedContractClassProgram {\n            fn as_ref(\u0026self) -\u003e \u0026String {\n                \u0026self.0\n            }\n        }\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct EdgeNode {\n        pub edge: EdgeNodeEdge,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct EdgeNodeEdge {\n        pub child: Felt,\n        pub path: EdgeNodePath,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct EdgeNodePath {\n        pub len: i64,\n        pub value: Felt,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct EmittedEvent {\n        #[serde(flatten)]\n        pub event: Event,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub block_hash: Option\u003cBlockHash\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub block_number: Option\u003cBlockNumber\u003e,\n        pub transaction_hash: TxnHash,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum EntryPointType {\n        #[serde(rename = \"EXTERNAL\")]\n        External,\n        #[serde(rename = \"L1_HANDLER\")]\n        L1Handler,\n        #[serde(rename = \"CONSTRUCTOR\")]\n        Constructor,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(try_from = \"String\")]\n    pub struct EthAddress(String);\n\n    mod ethaddress {\n        use super::jsonrpc;\n        use super::EthAddress;\n        use once_cell::sync::Lazy;\n        use regex::Regex;\n\n        static ETHADDRESS_REGEX: Lazy\u003cRegex\u003e = Lazy::new(|| {\n            Regex::new(\"^0x[a-fA-F0-9]{40}$\").expect(\"EthAddress: valid regex\")\n        });\n\n        impl EthAddress {\n            pub fn try_new(value: \u0026str) -\u003e Result\u003cSelf, jsonrpc::Error\u003e {\n                if ETHADDRESS_REGEX.is_match(value) {\n                    Ok(Self(value.to_string()))\n                } else {\n                    Err(jsonrpc::Error {\n                        code: 1001,\n                        message: format!(\n                            \"EthAddress value does not match regex: {value}\"\n                        ),\n                    })\n                }\n            }\n        }\n\n        impl TryFrom\u003cString\u003e for EthAddress {\n            type Error = String;\n            fn try_from(value: String) -\u003e Result\u003cSelf, Self::Error\u003e {\n                Self::try_new(\u0026value).map_err(|e| e.message)\n            }\n        }\n\n        impl AsRef\u003cString\u003e for EthAddress {\n            fn as_ref(\u0026self) -\u003e \u0026String {\n                \u0026self.0\n            }\n        }\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct Event {\n        pub from_address: Address,\n        #[serde(flatten)]\n        pub event_content: EventContent,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct EventAbiEntry {\n        pub data: Vec\u003cTypedParameter\u003e,\n        pub keys: Vec\u003cTypedParameter\u003e,\n        pub name: String,\n        pub r#type: EventAbiType,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum EventAbiType {\n        #[serde(rename = \"event\")]\n        Event,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct EventContent {\n        pub data: Vec\u003cFelt\u003e,\n        pub keys: Vec\u003cFelt\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct EventFilter {\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub address: Option\u003cAddress\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub from_block: Option\u003cBlockId\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub keys: Option\u003cVec\u003cVec\u003cFelt\u003e\u003e\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub to_block: Option\u003cBlockId\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct EventsChunk {\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub continuation_token: Option\u003cString\u003e,\n        pub events: Vec\u003cEmittedEvent\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct ExecutionResources {\n        #[serde(flatten)]\n        pub computation_resources: ComputationResources,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub data_availability: Option\u003cExecutionResourcesDataAvailability\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct ExecutionResourcesDataAvailability {\n        pub l1_data_gas: i64,\n        pub l1_gas: i64,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct FeeEstimate {\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub data_gas_consumed: Option\u003cFelt\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub data_gas_price: Option\u003cFelt\u003e,\n        pub gas_consumed: Felt,\n        pub gas_price: Felt,\n        pub overall_fee: Felt,\n        pub unit: PriceUnit,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct FeePayment {\n        pub amount: Felt,\n        pub unit: PriceUnit,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(try_from = \"String\")]\n    pub struct Felt(String);\n\n    mod felt {\n        use super::jsonrpc;\n        use super::Felt;\n        use once_cell::sync::Lazy;\n        use regex::Regex;\n\n        static FELT_REGEX: Lazy\u003cRegex\u003e = Lazy::new(|| {\n            Regex::new(\"^0x(0|[a-fA-F1-9]{1}[a-fA-F0-9]{0,62})$\")\n                .expect(\"Felt: valid regex\")\n        });\n\n        impl Felt {\n            pub fn try_new(value: \u0026str) -\u003e Result\u003cSelf, jsonrpc::Error\u003e {\n                if FELT_REGEX.is_match(value) {\n                    Ok(Self(value.to_string()))\n                } else {\n                    Err(jsonrpc::Error {\n                        code: 1001,\n                        message: format!(\n                            \"Felt value does not match regex: {value}\"\n                        ),\n                    })\n                }\n            }\n        }\n\n        impl TryFrom\u003cString\u003e for Felt {\n            type Error = String;\n            fn try_from(value: String) -\u003e Result\u003cSelf, Self::Error\u003e {\n                Self::try_new(\u0026value).map_err(|e| e.message)\n            }\n        }\n\n        impl AsRef\u003cString\u003e for Felt {\n            fn as_ref(\u0026self) -\u003e \u0026String {\n                \u0026self.0\n            }\n        }\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct FunctionAbiEntry {\n        pub inputs: Vec\u003cTypedParameter\u003e,\n        pub name: String,\n        pub outputs: Vec\u003cTypedParameter\u003e,\n        pub r#type: FunctionAbiType,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        #[serde(rename = \"stateMutability\")]\n        pub statemutability: Option\u003cFunctionStateMutability\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum FunctionAbiType {\n        #[serde(rename = \"function\")]\n        Function,\n        #[serde(rename = \"l1_handler\")]\n        L1Handler,\n        #[serde(rename = \"constructor\")]\n        Constructor,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct FunctionCall {\n        pub calldata: Vec\u003cFelt\u003e,\n        pub contract_address: Address,\n        pub entry_point_selector: Felt,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct FunctionInvocation {\n        #[serde(flatten)]\n        pub function_call: FunctionCall,\n        pub call_type: CallType,\n        pub caller_address: Felt,\n        pub calls: Vec\u003cNestedCall\u003e,\n        pub class_hash: Felt,\n        pub entry_point_type: EntryPointType,\n        pub events: Vec\u003cOrderedEvent\u003e,\n        pub execution_resources: ComputationResources,\n        pub messages: Vec\u003cOrderedMessage\u003e,\n        pub result: Vec\u003cFelt\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum FunctionStateMutability {\n        #[serde(rename = \"view\")]\n        View,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(untagged)]\n    pub enum InvokeTxn {\n        InvokeTxnV0(InvokeTxnV0),\n        InvokeTxnV1(InvokeTxnV1),\n        InvokeTxnV3(InvokeTxnV3),\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct InvokeTxnReceipt {\n        pub r#type: InvokeTxnReceiptType,\n        #[serde(flatten)]\n        pub common_receipt_properties: CommonReceiptProperties,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum InvokeTxnReceiptType {\n        #[serde(rename = \"INVOKE\")]\n        Invoke,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct InvokeTxnTrace {\n        pub execute_invocation: InvokeTxnTraceExecuteInvocation,\n        pub execution_resources: ExecutionResources,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub fee_transfer_invocation: Option\u003cFunctionInvocation\u003e,\n        pub r#type: InvokeTxnTraceType,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub state_diff: Option\u003cStateDiff\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub validate_invocation: Option\u003cFunctionInvocation\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(untagged)]\n    pub enum InvokeTxnTraceExecuteInvocation {\n        FunctionInvocation(FunctionInvocation),\n        RevertReason { revert_reason: String },\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum InvokeTxnTraceType {\n        #[serde(rename = \"INVOKE\")]\n        Invoke,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct InvokeTxnV0 {\n        pub calldata: Vec\u003cFelt\u003e,\n        pub contract_address: Address,\n        pub entry_point_selector: Felt,\n        pub max_fee: Felt,\n        pub r#type: InvokeTxnV0Type,\n        pub signature: Signature,\n        pub version: InvokeTxnV0Version,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum InvokeTxnV0Type {\n        #[serde(rename = \"INVOKE\")]\n        Invoke,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum InvokeTxnV0Version {\n        #[serde(rename = \"0x0\")]\n        V0x0,\n        #[serde(rename = \"0x100000000000000000000000000000000\")]\n        V0x100000000000000000000000000000000,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct InvokeTxnV1 {\n        pub calldata: Vec\u003cFelt\u003e,\n        pub max_fee: Felt,\n        pub nonce: Felt,\n        pub r#type: InvokeTxnV1Type,\n        pub sender_address: Address,\n        pub signature: Signature,\n        pub version: InvokeTxnV1Version,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum InvokeTxnV1Type {\n        #[serde(rename = \"INVOKE\")]\n        Invoke,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum InvokeTxnV1Version {\n        #[serde(rename = \"0x1\")]\n        V0x1,\n        #[serde(rename = \"0x100000000000000000000000000000001\")]\n        V0x100000000000000000000000000000001,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct InvokeTxnV3 {\n        pub account_deployment_data: Vec\u003cFelt\u003e,\n        pub calldata: Vec\u003cFelt\u003e,\n        pub fee_data_availability_mode: DaMode,\n        pub nonce: Felt,\n        pub nonce_data_availability_mode: DaMode,\n        pub paymaster_data: Vec\u003cFelt\u003e,\n        pub r#type: InvokeTxnV3Type,\n        pub resource_bounds: ResourceBoundsMapping,\n        pub sender_address: Address,\n        pub signature: Signature,\n        pub tip: U64,\n        pub version: InvokeTxnV3Version,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum InvokeTxnV3Type {\n        #[serde(rename = \"INVOKE\")]\n        Invoke,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum InvokeTxnV3Version {\n        #[serde(rename = \"0x3\")]\n        V0x3,\n        #[serde(rename = \"0x100000000000000000000000000000003\")]\n        V0x100000000000000000000000000000003,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct L1HandlerTxn {\n        pub nonce: NumAsHex,\n        pub r#type: L1HandlerTxnType,\n        pub version: L1HandlerTxnVersion,\n        #[serde(flatten)]\n        pub function_call: FunctionCall,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct L1HandlerTxnReceipt {\n        pub message_hash: NumAsHex,\n        pub r#type: L1HandlerTxnReceiptType,\n        #[serde(flatten)]\n        pub common_receipt_properties: CommonReceiptProperties,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum L1HandlerTxnReceiptType {\n        #[serde(rename = \"L1_HANDLER\")]\n        L1Handler,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct L1HandlerTxnTrace {\n        pub execution_resources: ExecutionResources,\n        pub function_invocation: FunctionInvocation,\n        pub r#type: L1HandlerTxnTraceType,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub state_diff: Option\u003cStateDiff\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum L1HandlerTxnTraceType {\n        #[serde(rename = \"L1_HANDLER\")]\n        L1Handler,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum L1HandlerTxnType {\n        #[serde(rename = \"L1_HANDLER\")]\n        L1Handler,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum L1HandlerTxnVersion {\n        #[serde(rename = \"0x0\")]\n        V0x0,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct MsgFromL1 {\n        pub entry_point_selector: Felt,\n        pub from_address: EthAddress,\n        pub payload: Vec\u003cFelt\u003e,\n        pub to_address: Address,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct MsgToL1 {\n        pub from_address: Felt,\n        pub payload: Vec\u003cFelt\u003e,\n        pub to_address: Felt,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct NestedCall(pub FunctionInvocation);\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct NewClasses {\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub class_hash: Option\u003cFelt\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub compiled_class_hash: Option\u003cFelt\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(untagged)]\n    pub enum Node {\n        BinaryNode(BinaryNode),\n        EdgeNode(EdgeNode),\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct NonceUpdate {\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub contract_address: Option\u003cAddress\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub nonce: Option\u003cFelt\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(try_from = \"String\")]\n    pub struct NumAsHex(String);\n\n    mod numashex {\n        use super::jsonrpc;\n        use super::NumAsHex;\n        use once_cell::sync::Lazy;\n        use regex::Regex;\n\n        static NUMASHEX_REGEX: Lazy\u003cRegex\u003e = Lazy::new(|| {\n            Regex::new(\"^0x[a-fA-F0-9]+$\").expect(\"NumAsHex: valid regex\")\n        });\n\n        impl NumAsHex {\n            pub fn try_new(value: \u0026str) -\u003e Result\u003cSelf, jsonrpc::Error\u003e {\n                if NUMASHEX_REGEX.is_match(value) {\n                    Ok(Self(value.to_string()))\n                } else {\n                    Err(jsonrpc::Error {\n                        code: 1001,\n                        message: format!(\n                            \"NumAsHex value does not match regex: {value}\"\n                        ),\n                    })\n                }\n            }\n        }\n\n        impl TryFrom\u003cString\u003e for NumAsHex {\n            type Error = String;\n            fn try_from(value: String) -\u003e Result\u003cSelf, Self::Error\u003e {\n                Self::try_new(\u0026value).map_err(|e| e.message)\n            }\n        }\n\n        impl AsRef\u003cString\u003e for NumAsHex {\n            fn as_ref(\u0026self) -\u003e \u0026String {\n                \u0026self.0\n            }\n        }\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct OrderedEvent {\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub order: Option\u003ci64\u003e,\n        #[serde(flatten)]\n        pub event: Event,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct OrderedMessage {\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub order: Option\u003ci64\u003e,\n        #[serde(flatten)]\n        pub msg_to_l1: MsgToL1,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct PendingBlockHeader {\n        pub l1_da_mode: PendingBlockHeaderL1DaMode,\n        pub l1_data_gas_price: ResourcePrice,\n        pub l1_gas_price: ResourcePrice,\n        pub parent_hash: BlockHash,\n        pub sequencer_address: Felt,\n        pub starknet_version: String,\n        pub timestamp: PendingBlockHeaderTimestamp,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum PendingBlockHeaderL1DaMode {\n        #[serde(rename = \"BLOB\")]\n        Blob,\n        #[serde(rename = \"CALLDATA\")]\n        Calldata,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(try_from = \"i64\")]\n    pub struct PendingBlockHeaderTimestamp(i64);\n\n    mod pendingblockheadertimestamp {\n        use super::jsonrpc;\n        use super::PendingBlockHeaderTimestamp;\n\n        static MIN: i64 = 0;\n        static MAX: i64 = 9223372036854775807;\n\n        impl PendingBlockHeaderTimestamp {\n            pub fn try_new(value: i64) -\u003e Result\u003cSelf, jsonrpc::Error\u003e {\n                if value \u003c MIN {\n                    return Err(jsonrpc::Error {\n                    code: 1001,\n                    message: format!(\"PendingBlockHeaderTimestamp value {value} must be \u003e {MIN}\"),\n                });\n                }\n                if value \u003e MAX {\n                    return Err(jsonrpc::Error {\n                    code: 1001,\n                    message: format!(\"PendingBlockHeaderTimestamp value {value} must be \u003c {MAX}\"),\n                });\n                }\n                Ok(Self(value))\n            }\n        }\n\n        impl TryFrom\u003ci64\u003e for PendingBlockHeaderTimestamp {\n            type Error = String;\n            fn try_from(value: i64) -\u003e Result\u003cSelf, Self::Error\u003e {\n                Self::try_new(value).map_err(|e| e.message)\n            }\n        }\n\n        impl AsRef\u003ci64\u003e for PendingBlockHeaderTimestamp {\n            fn as_ref(\u0026self) -\u003e \u0026i64 {\n                \u0026self.0\n            }\n        }\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct PendingBlockWithReceipts {\n        #[serde(flatten)]\n        pub block_body_with_receipts: BlockBodyWithReceipts,\n        #[serde(flatten)]\n        pub pending_block_header: PendingBlockHeader,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct PendingBlockWithTxHashes {\n        #[serde(flatten)]\n        pub block_body_with_tx_hashes: BlockBodyWithTxHashes,\n        #[serde(flatten)]\n        pub pending_block_header: PendingBlockHeader,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct PendingBlockWithTxs {\n        #[serde(flatten)]\n        pub block_body_with_txs: BlockBodyWithTxs,\n        #[serde(flatten)]\n        pub pending_block_header: PendingBlockHeader,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct PendingStateUpdate {\n        pub old_root: Felt,\n        pub state_diff: StateDiff,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum PriceUnit {\n        #[serde(rename = \"WEI\")]\n        Wei,\n        #[serde(rename = \"FRI\")]\n        Fri,\n    }\n\n    type Proof = Vec\u003cNode\u003e;\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct ReplacedClass {\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub class_hash: Option\u003cFelt\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub contract_address: Option\u003cAddress\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct ResourceBounds {\n        pub max_amount: U64,\n        pub max_price_per_unit: U128,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct ResourceBoundsMapping {\n        pub l1_gas: ResourceBounds,\n        pub l2_gas: ResourceBounds,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct ResourcePrice {\n        pub price_in_fri: Felt,\n        pub price_in_wei: Felt,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(untagged)]\n    pub enum ResultCommonReceiptProperties {\n        SuccessfulCommonReceiptProperties(SuccessfulCommonReceiptProperties),\n        RevertedCommonReceiptProperties(RevertedCommonReceiptProperties),\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct ResultPageRequest {\n        pub chunk_size: ResultPageRequestChunkSize,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub continuation_token: Option\u003cString\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(try_from = \"i64\")]\n    pub struct ResultPageRequestChunkSize(i64);\n\n    mod resultpagerequestchunksize {\n        use super::jsonrpc;\n        use super::ResultPageRequestChunkSize;\n\n        static MIN: i64 = 1;\n        static MAX: i64 = 9223372036854775807;\n\n        impl ResultPageRequestChunkSize {\n            pub fn try_new(value: i64) -\u003e Result\u003cSelf, jsonrpc::Error\u003e {\n                if value \u003c MIN {\n                    return Err(jsonrpc::Error {\n                    code: 1001,\n                    message: format!(\"ResultPageRequestChunkSize value {value} must be \u003e {MIN}\"),\n                });\n                }\n                if value \u003e MAX {\n                    return Err(jsonrpc::Error {\n                    code: 1001,\n                    message: format!(\"ResultPageRequestChunkSize value {value} must be \u003c {MAX}\"),\n                });\n                }\n                Ok(Self(value))\n            }\n        }\n\n        impl TryFrom\u003ci64\u003e for ResultPageRequestChunkSize {\n            type Error = String;\n            fn try_from(value: i64) -\u003e Result\u003cSelf, Self::Error\u003e {\n                Self::try_new(value).map_err(|e| e.message)\n            }\n        }\n\n        impl AsRef\u003ci64\u003e for ResultPageRequestChunkSize {\n            fn as_ref(\u0026self) -\u003e \u0026i64 {\n                \u0026self.0\n            }\n        }\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct RevertedCommonReceiptProperties {\n        pub execution_status: RevertedCommonReceiptPropertiesExecutionStatus,\n        pub revert_reason: String,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum RevertedCommonReceiptPropertiesExecutionStatus {\n        #[serde(rename = \"REVERTED\")]\n        Reverted,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct SierraEntryPoint {\n        pub function_idx: i64,\n        pub selector: Felt,\n    }\n\n    type Signature = Vec\u003cFelt\u003e;\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum SimulationFlag {\n        #[serde(rename = \"SKIP_VALIDATE\")]\n        SkipValidate,\n        #[serde(rename = \"SKIP_FEE_CHARGE\")]\n        SkipFeeCharge,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum SimulationFlagForEstimateFee {\n        #[serde(rename = \"SKIP_VALIDATE\")]\n        SkipValidate,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct StateDiff {\n        pub declared_classes: Vec\u003cNewClasses\u003e,\n        pub deployed_contracts: Vec\u003cDeployedContractItem\u003e,\n        pub deprecated_declared_classes: Vec\u003cFelt\u003e,\n        pub nonces: Vec\u003cNonceUpdate\u003e,\n        pub replaced_classes: Vec\u003cReplacedClass\u003e,\n        pub storage_diffs: Vec\u003cContractStorageDiffItem\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct StateUpdate {\n        pub block_hash: BlockHash,\n        pub new_root: Felt,\n        pub old_root: Felt,\n        pub state_diff: StateDiff,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct StorageDiffItem {\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub key: Option\u003cFelt\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub value: Option\u003cFelt\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(try_from = \"String\")]\n    pub struct StorageKey(String);\n\n    mod storagekey {\n        use super::jsonrpc;\n        use super::StorageKey;\n        use once_cell::sync::Lazy;\n        use regex::Regex;\n\n        static STORAGEKEY_REGEX: Lazy\u003cRegex\u003e = Lazy::new(|| {\n            Regex::new(\"^0x(0|[0-7]{1}[a-fA-F0-9]{0,62}$)\")\n                .expect(\"StorageKey: valid regex\")\n        });\n\n        impl StorageKey {\n            pub fn try_new(value: \u0026str) -\u003e Result\u003cSelf, jsonrpc::Error\u003e {\n                if STORAGEKEY_REGEX.is_match(value) {\n                    Ok(Self(value.to_string()))\n                } else {\n                    Err(jsonrpc::Error {\n                        code: 1001,\n                        message: format!(\n                            \"StorageKey value does not match regex: {value}\"\n                        ),\n                    })\n                }\n            }\n        }\n\n        impl TryFrom\u003cString\u003e for StorageKey {\n            type Error = String;\n            fn try_from(value: String) -\u003e Result\u003cSelf, Self::Error\u003e {\n                Self::try_new(\u0026value).map_err(|e| e.message)\n            }\n        }\n\n        impl AsRef\u003cString\u003e for StorageKey {\n            fn as_ref(\u0026self) -\u003e \u0026String {\n                \u0026self.0\n            }\n        }\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct StructAbiEntry {\n        pub members: Vec\u003cStructMember\u003e,\n        pub name: String,\n        pub r#type: StructAbiType,\n        pub size: StructAbiEntrySize,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(try_from = \"i64\")]\n    pub struct StructAbiEntrySize(i64);\n\n    mod structabientrysize {\n        use super::jsonrpc;\n        use super::StructAbiEntrySize;\n\n        static MIN: i64 = 1;\n        static MAX: i64 = 9223372036854775807;\n\n        impl StructAbiEntrySize {\n            pub fn try_new(value: i64) -\u003e Result\u003cSelf, jsonrpc::Error\u003e {\n                if value \u003c MIN {\n                    return Err(jsonrpc::Error {\n                        code: 1001,\n                        message: format!(\n                            \"StructAbiEntrySize value {value} must be \u003e {MIN}\"\n                        ),\n                    });\n                }\n                if value \u003e MAX {\n                    return Err(jsonrpc::Error {\n                        code: 1001,\n                        message: format!(\n                            \"StructAbiEntrySize value {value} must be \u003c {MAX}\"\n                        ),\n                    });\n                }\n                Ok(Self(value))\n            }\n        }\n\n        impl TryFrom\u003ci64\u003e for StructAbiEntrySize {\n            type Error = String;\n            fn try_from(value: i64) -\u003e Result\u003cSelf, Self::Error\u003e {\n                Self::try_new(value).map_err(|e| e.message)\n            }\n        }\n\n        impl AsRef\u003ci64\u003e for StructAbiEntrySize {\n            fn as_ref(\u0026self) -\u003e \u0026i64 {\n                \u0026self.0\n            }\n        }\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum StructAbiType {\n        #[serde(rename = \"struct\")]\n        Struct,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct StructMember {\n        #[serde(flatten)]\n        pub typed_parameter: TypedParameter,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub offset: Option\u003ci64\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct SuccessfulCommonReceiptProperties {\n        pub execution_status: SuccessfulCommonReceiptPropertiesExecutionStatus,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum SuccessfulCommonReceiptPropertiesExecutionStatus {\n        #[serde(rename = \"SUCCEEDED\")]\n        Succeeded,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct SyncStatus {\n        pub current_block_hash: BlockHash,\n        pub current_block_num: BlockNumber,\n        pub highest_block_hash: BlockHash,\n        pub highest_block_num: BlockNumber,\n        pub starting_block_hash: BlockHash,\n        pub starting_block_num: BlockNumber,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct TransactionAndReceipt {\n        pub receipt: TxnReceipt,\n        pub transaction: Txn,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(untagged)]\n    pub enum TransactionTrace {\n        InvokeTxnTrace(InvokeTxnTrace),\n        DeclareTxnTrace(DeclareTxnTrace),\n        DeployAccountTxnTrace(DeployAccountTxnTrace),\n        L1HandlerTxnTrace(L1HandlerTxnTrace),\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct TransactionsInBlock {\n        #[serde(flatten)]\n        pub txn: Txn,\n        pub transaction_hash: TxnHash,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum TxGatewayStatus {\n        #[serde(rename = \"NOT_RECEIVED\")]\n        NotReceived,\n        #[serde(rename = \"RECEIVED\")]\n        Received,\n        #[serde(rename = \"PENDING\")]\n        Pending,\n        #[serde(rename = \"REJECTED\")]\n        Rejected,\n        #[serde(rename = \"ACCEPTED_ON_L1\")]\n        AcceptedOnL1,\n        #[serde(rename = \"ACCEPTED_ON_L2\")]\n        AcceptedOnL2,\n        #[serde(rename = \"REVERTED\")]\n        Reverted,\n        #[serde(rename = \"ABORTED\")]\n        Aborted,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(untagged)]\n    pub enum Txn {\n        InvokeTxn(InvokeTxn),\n        L1HandlerTxn(L1HandlerTxn),\n        DeclareTxn(DeclareTxn),\n        DeployTxn(DeployTxn),\n        DeployAccountTxn(DeployAccountTxn),\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum TxnExecutionStatus {\n        #[serde(rename = \"SUCCEEDED\")]\n        Succeeded,\n        #[serde(rename = \"REVERTED\")]\n        Reverted,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum TxnFinalityStatus {\n        #[serde(rename = \"ACCEPTED_ON_L2\")]\n        AcceptedOnL2,\n        #[serde(rename = \"ACCEPTED_ON_L1\")]\n        AcceptedOnL1,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct TxnHash(pub Felt);\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(untagged)]\n    pub enum TxnReceipt {\n        InvokeTxnReceipt(InvokeTxnReceipt),\n        L1HandlerTxnReceipt(L1HandlerTxnReceipt),\n        DeclareTxnReceipt(DeclareTxnReceipt),\n        DeployTxnReceipt(DeployTxnReceipt),\n        DeployAccountTxnReceipt(DeployAccountTxnReceipt),\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct TxnReceiptWithBlockInfo {\n        #[serde(flatten)]\n        pub txn_receipt: TxnReceipt,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub block_hash: Option\u003cBlockHash\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub block_number: Option\u003cBlockNumber\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum TxnStatus {\n        #[serde(rename = \"RECEIVED\")]\n        Received,\n        #[serde(rename = \"REJECTED\")]\n        Rejected,\n        #[serde(rename = \"ACCEPTED_ON_L2\")]\n        AcceptedOnL2,\n        #[serde(rename = \"ACCEPTED_ON_L1\")]\n        AcceptedOnL1,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub enum TxnType {\n        #[serde(rename = \"DECLARE\")]\n        Declare,\n        #[serde(rename = \"DEPLOY\")]\n        Deploy,\n        #[serde(rename = \"DEPLOY_ACCOUNT\")]\n        DeployAccount,\n        #[serde(rename = \"INVOKE\")]\n        Invoke,\n        #[serde(rename = \"L1_HANDLER\")]\n        L1Handler,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct TypedParameter {\n        pub name: String,\n        pub r#type: String,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(try_from = \"String\")]\n    pub struct U128(String);\n\n    mod u128 {\n        use super::jsonrpc;\n        use super::U128;\n        use once_cell::sync::Lazy;\n        use regex::Regex;\n\n        static U128_REGEX: Lazy\u003cRegex\u003e = Lazy::new(|| {\n            Regex::new(\"^0x(0|[a-fA-F1-9]{1}[a-fA-F0-9]{0,31})$\")\n                .expect(\"U128: valid regex\")\n        });\n\n        impl U128 {\n            pub fn try_new(value: \u0026str) -\u003e Result\u003cSelf, jsonrpc::Error\u003e {\n                if U128_REGEX.is_match(value) {\n                    Ok(Self(value.to_string()))\n                } else {\n                    Err(jsonrpc::Error {\n                        code: 1001,\n                        message: format!(\n                            \"U128 value does not match regex: {value}\"\n                        ),\n                    })\n                }\n            }\n        }\n\n        impl TryFrom\u003cString\u003e for U128 {\n            type Error = String;\n            fn try_from(value: String) -\u003e Result\u003cSelf, Self::Error\u003e {\n                Self::try_new(\u0026value).map_err(|e| e.message)\n            }\n        }\n\n        impl AsRef\u003cString\u003e for U128 {\n            fn as_ref(\u0026self) -\u003e \u0026String {\n                \u0026self.0\n            }\n        }\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(try_from = \"String\")]\n    pub struct U64(String);\n\n    mod u64 {\n        use super::jsonrpc;\n        use super::U64;\n        use once_cell::sync::Lazy;\n        use regex::Regex;\n\n        static U64_REGEX: Lazy\u003cRegex\u003e = Lazy::new(|| {\n            Regex::new(\"^0x(0|[a-fA-F1-9]{1}[a-fA-F0-9]{0,15})$\")\n                .expect(\"U64: valid regex\")\n        });\n\n        impl U64 {\n            pub fn try_new(value: \u0026str) -\u003e Result\u003cSelf, jsonrpc::Error\u003e {\n                if U64_REGEX.is_match(value) {\n                    Ok(Self(value.to_string()))\n                } else {\n                    Err(jsonrpc::Error {\n                        code: 1001,\n                        message: format!(\n                            \"U64 value does not match regex: {value}\"\n                        ),\n                    })\n                }\n            }\n        }\n\n        impl TryFrom\u003cString\u003e for U64 {\n            type Error = String;\n            fn try_from(value: String) -\u003e Result\u003cSelf, Self::Error\u003e {\n                Self::try_new(\u0026value).map_err(|e| e.message)\n            }\n        }\n\n        impl AsRef\u003cString\u003e for U64 {\n            fn as_ref(\u0026self) -\u003e \u0026String {\n                \u0026self.0\n            }\n        }\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(untagged)]\n    pub enum GetBlockWithTxHashesResult {\n        BlockWithTxHashes(BlockWithTxHashes),\n        PendingBlockWithTxHashes(PendingBlockWithTxHashes),\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(untagged)]\n    pub enum GetBlockWithTxsResult {\n        BlockWithTxs(BlockWithTxs),\n        PendingBlockWithTxs(PendingBlockWithTxs),\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(untagged)]\n    pub enum GetBlockWithReceiptsResult {\n        BlockWithReceipts(BlockWithReceipts),\n        PendingBlockWithReceipts(PendingBlockWithReceipts),\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(untagged)]\n    pub enum GetStateUpdateResult {\n        StateUpdate(StateUpdate),\n        PendingStateUpdate(PendingStateUpdate),\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct GetTransactionStatusResult {\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub execution_status: Option\u003cTxnExecutionStatus\u003e,\n        pub finality_status: TxnStatus,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct GetTransactionByHashResult {\n        #[serde(flatten)]\n        pub txn: Txn,\n        pub transaction_hash: TxnHash,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct GetTransactionByBlockIdAndIndexResult {\n        #[serde(flatten)]\n        pub txn: Txn,\n        pub transaction_hash: TxnHash,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(try_from = \"i64\")]\n    pub struct GetTransactionByBlockIdAndIndexIndex(i64);\n\n    mod gettransactionbyblockidandindexindex {\n        use super::jsonrpc;\n        use super::GetTransactionByBlockIdAndIndexIndex;\n\n        static MIN: i64 = 0;\n        static MAX: i64 = 9223372036854775807;\n\n        impl GetTransactionByBlockIdAndIndexIndex {\n            pub fn try_new(value: i64) -\u003e Result\u003cSelf, jsonrpc::Error\u003e {\n                if value \u003c MIN {\n                    return Err(jsonrpc::Error {\n                    code: 1001,\n                    message: format!(\"GetTransactionByBlockIdAndIndexIndex value {value} must be \u003e {MIN}\"),\n                });\n                }\n                if value \u003e MAX {\n                    return Err(jsonrpc::Error {\n                    code: 1001,\n                    message: format!(\"GetTransactionByBlockIdAndIndexIndex value {value} must be \u003c {MAX}\"),\n                });\n                }\n                Ok(Self(value))\n            }\n        }\n\n        impl TryFrom\u003ci64\u003e for GetTransactionByBlockIdAndIndexIndex {\n            type Error = String;\n            fn try_from(value: i64) -\u003e Result\u003cSelf, Self::Error\u003e {\n                Self::try_new(value).map_err(|e| e.message)\n            }\n        }\n\n        impl AsRef\u003ci64\u003e for GetTransactionByBlockIdAndIndexIndex {\n            fn as_ref(\u0026self) -\u003e \u0026i64 {\n                \u0026self.0\n            }\n        }\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(untagged)]\n    pub enum GetClassResult {\n        DeprecatedContractClass(DeprecatedContractClass),\n        ContractClass(ContractClass),\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(untagged)]\n    pub enum GetClassAtResult {\n        DeprecatedContractClass(DeprecatedContractClass),\n        ContractClass(ContractClass),\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(try_from = \"i64\")]\n    pub struct GetBlockTransactionCountResult(i64);\n\n    mod getblocktransactioncountresult {\n        use super::jsonrpc;\n        use super::GetBlockTransactionCountResult;\n\n        static MIN: i64 = 0;\n        static MAX: i64 = 9223372036854775807;\n\n        impl GetBlockTransactionCountResult {\n            pub fn try_new(value: i64) -\u003e Result\u003cSelf, jsonrpc::Error\u003e {\n                if value \u003c MIN {\n                    return Err(jsonrpc::Error {\n                    code: 1001,\n                    message: format!(\"GetBlockTransactionCountResult value {value} must be \u003e {MIN}\"),\n                });\n                }\n                if value \u003e MAX {\n                    return Err(jsonrpc::Error {\n                    code: 1001,\n                    message: format!(\"GetBlockTransactionCountResult value {value} must be \u003c {MAX}\"),\n                });\n                }\n                Ok(Self(value))\n            }\n        }\n\n        impl TryFrom\u003ci64\u003e for GetBlockTransactionCountResult {\n            type Error = String;\n            fn try_from(value: i64) -\u003e Result\u003cSelf, Self::Error\u003e {\n                Self::try_new(value).map_err(|e| e.message)\n            }\n        }\n\n        impl AsRef\u003ci64\u003e for GetBlockTransactionCountResult {\n            fn as_ref(\u0026self) -\u003e \u0026i64 {\n                \u0026self.0\n            }\n        }\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct BlockHashAndNumberResult {\n        pub block_hash: BlockHash,\n        pub block_number: BlockNumber,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    #[serde(untagged)]\n    pub enum SyncingResult {\n        False(bool),\n        SyncStatus(SyncStatus),\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct GetEventsFilter {\n        #[serde(flatten)]\n        pub event_filter: EventFilter,\n        #[serde(flatten)]\n        pub result_page_request: ResultPageRequest,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct AddInvokeTransactionResult {\n        pub transaction_hash: TxnHash,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct AddDeclareTransactionResult {\n        pub class_hash: Felt,\n        pub transaction_hash: TxnHash,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct AddDeployAccountTransactionResult {\n        pub contract_address: Felt,\n        pub transaction_hash: TxnHash,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct SimulatedTransaction {\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub fee_estimation: Option\u003cFeeEstimate\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub transaction_trace: Option\u003cTransactionTrace\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct BlockTransactionTrace {\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub trace_root: Option\u003cTransactionTrace\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub transaction_hash: Option\u003cFelt\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct ContractData {\n        pub class_hash: Felt,\n        pub contract_state_hash_version: Felt,\n        pub nonce: Felt,\n        pub root: Felt,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub storage_proofs: Option\u003cVec\u003cProof\u003e\u003e,\n    }\n\n    #[derive(Clone, Debug, Deserialize, Serialize)]\n    pub struct GetProofResult {\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub class_commitment: Option\u003cFelt\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub contract_data: Option\u003cContractData\u003e,\n        pub contract_proof: Proof,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub state_commitment: Option\u003cFelt\u003e,\n    }\n\n    pub mod error {\n        pub const BLOCK_NOT_FOUND: Error = Error(24, \"Block not found\");\n        pub const CLASS_ALREADY_DECLARED: Error =\n            Error(51, \"Class already declared\");\n        pub const CLASS_HASH_NOT_FOUND: Error =\n            Error(28, \"Class hash not found\");\n        pub const COMPILATION_FAILED: Error = Error(56, \"Compilation failed\");\n        pub const COMPILED_CLASS_HASH_MISMATCH: Error = Error(60, \"the compiled class hash did not match the one supplied in the transaction\");\n        pub const CONTRACT_CLASS_SIZE_IS_TOO_LARGE: Error =\n            Error(57, \"Contract class size it too large\");\n        pub const CONTRACT_ERROR: Error = Error(40, \"Contract error\");\n        pub const CONTRACT_NOT_FOUND: Error = Error(20, \"Contract not found\");\n        pub const DUPLICATE_TX: Error = Error(\n            59,\n            \"A transaction with the same hash already exists in the mempool\",\n        );\n        pub const FAILED_TO_RECEIVE_TXN: Error =\n            Error(1, \"Failed to write transaction\");\n        pub const INSUFFICIENT_ACCOUNT_BALANCE: Error = Error(\n            54,\n            \"Account balance is smaller than the transaction's max_fee\",\n        );\n        pub const INSUFFICIENT_MAX_FEE: Error = Error(53, \"Max fee is smaller than the minimal transaction cost (validation plus fee transfer)\");\n        pub const INVALID_CONTINUATION_TOKEN: Error =\n            Error(33, \"The supplied continuation token is invalid or unknown\");\n        pub const INVALID_TRANSACTION_NONCE: Error =\n            Error(52, \"Invalid transaction nonce\");\n        pub const INVALID_TXN_INDEX: Error =\n            Error(27, \"Invalid transaction index in a block\");\n        pub const NON_ACCOUNT: Error =\n            Error(58, \"Sender address in not an account contract\");\n        pub const NO_BLOCKS: Error = Error(32, \"There are no blocks\");\n        pub const NO_TRACE_AVAILABLE: Error =\n            Error(10, \"No trace available for transaction\");\n        pub const PAGE_SIZE_TOO_BIG: Error =\n            Error(31, \"Requested page size is too big\");\n        pub const PROOF_LIMIT_EXCEEDED: Error =\n            Error(10000, \"Too many storage keys requested\");\n        pub const TOO_MANY_KEYS_IN_FILTER: Error =\n            Error(34, \"Too many keys provided in a filter\");\n        pub const TRANSACTION_EXECUTION_ERROR: Error =\n            Error(41, \"Transaction execution error\");\n        pub const TXN_HASH_NOT_FOUND: Error =\n            Error(29, \"Transaction hash not found\");\n        pub const UNEXPECTED_ERROR: Error =\n            Error(63, \"An unexpected error occurred\");\n        pub const UNSUPPORTED_CONTRACT_CLASS_VERSION: Error =\n            Error(62, \"the contract class version is not supported\");\n        pub const UNSUPPORTED_TX_VERSION: Error =\n            Error(61, \"the transaction version is not supported\");\n        pub const VALIDATION_FAILURE: Error =\n            Error(55, \"Account validation failed\");\n\n        pub struct Error(i64, \u0026'static str);\n\n        impl From\u003cError\u003e for iamgroot::jsonrpc::Error {\n            fn from(Error(code, message): Error) -\u003e Self {\n                Self { code, message: message.to_string() }\n            }\n        }\n    }\n\n    #[allow(non_snake_case)]\n    #[cfg_attr(target_arch = \"wasm32\", async_trait::async_trait(?Send))]\n    #[cfg_attr(not(target_arch = \"wasm32\"), async_trait::async_trait)]\n    pub trait Rpc {\n        /// Returns merkle proofs of a contract's storage state\n        async fn getProof(\n            \u0026self,\n            block_id: BlockId,\n            contract_address: Address,\n            keys: Vec\u003cStorageKey\u003e,\n        ) -\u003e std::result::Result\u003cGetProofResult, jsonrpc::Error\u003e;\n\n        /// Returns the status of a transaction\n        async fn getTxStatus(\n            \u0026self,\n            transaction_hash: TxnHash,\n        ) -\u003e std::result::Result\u003cTxGatewayStatus, jsonrpc::Error\u003e;\n\n        /// The version of the pathfinder node hosting this API.\n        async fn version(\u0026self) -\u003e std::result::Result\u003cString, jsonrpc::Error\u003e;\n\n        /// Submit a new class declaration transaction\n        async fn addDeclareTransaction(\n            \u0026self,\n            declare_transaction: BroadcastedDeclareTxn,\n        ) -\u003e std::result::Result\u003cAddDeclareTransactionResult, jsonrpc::Error\u003e;\n\n        /// Submit a new deploy account transaction\n        async fn addDeployAccountTransaction(\n            \u0026self,\n            deploy_account_transaction: BroadcastedDeployAccountTxn,\n        ) -\u003e std::result::Result\u003c\n            AddDeployAccountTransactionResult,\n            jsonrpc::Error,\n        \u003e;\n\n        /// Submit a new transaction to be added to the chain\n        async fn addInvokeTransaction(\n            \u0026self,\n            invoke_transaction: BroadcastedInvokeTxn,\n        ) -\u003e std::result::Result\u003cAddInvokeTransactionResult, jsonrpc::Error\u003e;\n\n        /// Get the most recent accepted block hash and number\n        async fn blockHashAndNumber(\n            \u0026self,\n        ) -\u003e std::result::Result\u003cBlockHashAndNumberResult, jsonrpc::Error\u003e;\n\n        /// Get the most recent accepted block number\n        async fn blockNumber(\n            \u0026self,\n        ) -\u003e std::result::Result\u003cBlockNumber, jsonrpc::Error\u003e;\n\n        /// call a starknet function without creating a StarkNet transaction\n        async fn call(\n            \u0026self,\n            request: FunctionCall,\n            block_id: BlockId,\n        ) -\u003e std::result::Result\u003cVec\u003cFelt\u003e, jsonrpc::Error\u003e;\n\n        /// Return the currently configured StarkNet chain id\n        async fn chainId(\u0026self)\n            -\u003e std::result::Result\u003cChainId, jsonrpc::Error\u003e;\n\n        /// estimate the fee for of StarkNet transactions\n        async fn estimateFee(\n            \u0026self,\n            request: Vec\u003cBroadcastedTxn\u003e,\n            simulation_flags: Vec\u003cSimulationFlagForEstimateFee\u003e,\n            block_id: BlockId,\n        ) -\u003e std::result::Result\u003cVec\u003cFeeEstimate\u003e, jsonrpc::Error\u003e;\n\n        /// estimate the L2 fee of a message sent on L1\n        async fn estimateMessageFee(\n            \u0026self,\n            message: MsgFromL1,\n            block_id: BlockId,\n        ) -\u003e std::result::Result\u003cFeeEstimate, jsonrpc::Error\u003e;\n\n        /// Get the number of transactions in a block given a block id\n        async fn getBlockTransactionCount(\n            \u0026self,\n            block_id: BlockId,\n        ) -\u003e std::result::Result\u003cGetBlockTransactionCountResult, jsonrpc::Error\u003e;\n\n        /// Get block information with full transactions and receipts given the block id\n        async fn getBlockWithReceipts(\n            \u0026self,\n            block_id: BlockId,\n        ) -\u003e std::result::Result\u003cGetBlockWithReceiptsResult, jsonrpc::Error\u003e;\n\n        /// Get block information with transaction hashes given the block id\n        async fn getBlockWithTxHashes(\n            \u0026self,\n            block_id: BlockId,\n        ) -\u003e std::result::Result\u003cGetBlockWithTxHashesResult, jsonrpc::Error\u003e;\n\n        /// Get block information with full transactions given the block id\n        async fn getBlockWithTxs(\n            \u0026self,\n            block_id: BlockId,\n        ) -\u003e std::result::Result\u003cGetBlockWithTxsResult, jsonrpc::Error\u003e;\n\n        /// Get the contract class definition in the given block associated with the given hash\n        async fn getClass(\n            \u0026self,\n            block_id: BlockId,\n            class_hash: Felt,\n        ) -\u003e std::result::Result\u003cGetClassResult, jsonrpc::Error\u003e;\n\n        /// Get the contract class definition in the given block at the given address\n        async fn getClassAt(\n            \u0026self,\n            block_id: BlockId,\n            contract_address: Address,\n        ) -\u003e std::result::Result\u003cGetClassAtResult, jsonrpc::Error\u003e;\n\n        /// Get the contract class hash in the given block for the contract deployed at the given address\n        async fn getClassHashAt(\n            \u0026self,\n            block_id: BlockId,\n            contract_address: Address,\n        ) -\u003e std::result::Result\u003cFelt, jsonrpc::Error\u003e;\n\n        /// Returns all events matching the given filter\n        async fn getEvents(\n            \u0026self,\n            filter: GetEventsFilter,\n        ) -\u003e std::result::Result\u003cEventsChunk, jsonrpc::Error\u003e;\n\n        /// Get the nonce associated with the given address in the given block\n        async fn getNonce(\n            \u0026self,\n            block_id: BlockId,\n            contract_address: Address,\n        ) -\u003e std::result::Result\u003cFelt, jsonrpc::Error\u003e;\n\n        /// Get the information about the result of executing the requested block\n        async fn getStateUpdate(\n            \u0026self,\n            block_id: BlockId,\n        ) -\u003e std::result::Result\u003cGetStateUpdateResult, jsonrpc::Error\u003e;\n\n        /// Get the value of the storage at the given address and key\n        async fn getStorageAt(\n            \u0026self,\n            contract_address: Address,\n            key: StorageKey,\n            block_id: BlockId,\n        ) -\u003e std::result::Result\u003cFelt, jsonrpc::Error\u003e;\n\n        /// Get the details of a transaction by a given block id and index\n        async fn getTransactionByBlockIdAndIndex(\n            \u0026self,\n            block_id: BlockId,\n            index: GetTransactionByBlockIdAndIndexIndex,\n        ) -\u003e std::result::Result\u003c\n            GetTransactionByBlockIdAndIndexResult,\n            jsonrpc::Error,\n        \u003e;\n\n        /// Get the details and status of a submitted transaction\n        async fn getTransactionByHash(\n            \u0026self,\n            transaction_hash: TxnHash,\n        ) -\u003e std::result::Result\u003cGetTransactionByHashResult, jsonrpc::Error\u003e;\n\n        /// Get the transaction receipt by the transaction hash\n        async fn getTransactionReceipt(\n            \u0026self,\n            transaction_hash: TxnHash,\n        ) -\u003e std::result::Result\u003cTxnReceiptWithBlockInfo, jsonrpc::Error\u003e;\n\n        /// Gets the transaction status (possibly reflecting that the tx is still in the mempool, or dropped from it)\n        async fn getTransactionStatus(\n            \u0026self,\n            transaction_hash: TxnHash,\n        ) -\u003e std::result::Result\u003cGetTransactionStatusResult, jsonrpc::Error\u003e;\n\n        /// Simulate a given sequence of transactions on the requested state, and generate the execution traces. Note that some of the transactions may revert, in which case no error is thrown, but revert details can be seen on the returned trace object. . Note that some of the transactions may revert, this will be reflected by the revert_error property in the trace. Other types of failures (e.g. unexpected error or failure in the validation phase) will result in TRANSACTION_EXECUTION_ERROR.\n        async fn simulateTransactions(\n            \u0026self,\n            block_id: BlockId,\n            transactions: Vec\u003cBroadcastedTxn\u003e,\n            simulation_flags: Vec\u003cSimulationFlag\u003e,\n        ) -\u003e std::result::Result\u003cVec\u003cSimulatedTransaction\u003e, jsonrpc::Error\u003e;\n\n        /// Returns the version of the Starknet JSON-RPC specification being used\n        async fn specVersion(\n            \u0026self,\n        ) -\u003e std::result::Result\u003cString, jsonrpc::Error\u003e;\n\n        /// Returns an object about the sync status, or false if the node is not synching\n        async fn syncing(\n            \u0026self,\n        ) -\u003e std::result::Result\u003cSyncingResult, jsonrpc::Error\u003e;\n\n        /// Retrieve traces for all transactions in the given block\n        async fn traceBlockTransactions(\n            \u0026self,\n            block_id: BlockId,\n        ) -\u003e std::result::Result\u003cVec\u003cBlockTransactionTrace\u003e, jsonrpc::Error\u003e;\n\n        /// For a given executed transaction, return the trace of its execution, including internal calls\n        async fn traceTransaction(\n            \u0026self,\n            transaction_hash: TxnHash,\n        ) -\u003e std::result::Result\u003cTransactionTrace, jsonrpc::Error\u003e;\n    }\n\n    async fn handle_getProof\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(BlockId, Address, Vec\u003cStorageKey\u003e);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            block_id: BlockId,\n            contract_address: Address,\n            keys: Vec\u003cStorageKey\u003e,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(block_id, contract_address, keys) =\n                            args_by_pos;\n                        ArgByName { block_id, contract_address, keys }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { block_id, contract_address, keys } = args;\n\n        match rpc.getProof(block_id, contract_address, keys).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_getTxStatus\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(TxnHash);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            transaction_hash: TxnHash,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(transaction_hash) = args_by_pos;\n                        ArgByName { transaction_hash }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { transaction_hash } = args;\n\n        match rpc.getTxStatus(transaction_hash).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_version\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        _params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        match rpc.version().await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(e) =\u003e jsonrpc::Response::error(1003, \u0026format!(\"{e:?}\")),\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_addDeclareTransaction\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(BroadcastedDeclareTxn);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            declare_transaction: BroadcastedDeclareTxn,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(declare_transaction) = args_by_pos;\n                        ArgByName { declare_transaction }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { declare_transaction } = args;\n\n        match rpc.addDeclareTransaction(declare_transaction).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_addDeployAccountTransaction\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(BroadcastedDeployAccountTxn);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            deploy_account_transaction: BroadcastedDeployAccountTxn,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(deploy_account_transaction) = args_by_pos;\n                        ArgByName { deploy_account_transaction }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { deploy_account_transaction } = args;\n\n        match rpc.addDeployAccountTransaction(deploy_account_transaction).await\n        {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_addInvokeTransaction\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(BroadcastedInvokeTxn);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            invoke_transaction: BroadcastedInvokeTxn,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(invoke_transaction) = args_by_pos;\n                        ArgByName { invoke_transaction }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { invoke_transaction } = args;\n\n        match rpc.addInvokeTransaction(invoke_transaction).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_blockHashAndNumber\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        _params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        match rpc.blockHashAndNumber().await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(e) =\u003e jsonrpc::Response::error(1003, \u0026format!(\"{e:?}\")),\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_blockNumber\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        _params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        match rpc.blockNumber().await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(e) =\u003e jsonrpc::Response::error(1003, \u0026format!(\"{e:?}\")),\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_call\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(FunctionCall, BlockId);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            request: FunctionCall,\n            block_id: BlockId,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(request, block_id) = args_by_pos;\n                        ArgByName { request, block_id }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { request, block_id } = args;\n\n        match rpc.call(request, block_id).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_chainId\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        _params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        match rpc.chainId().await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(e) =\u003e jsonrpc::Response::error(1003, \u0026format!(\"{e:?}\")),\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_estimateFee\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(\n            Vec\u003cBroadcastedTxn\u003e,\n            Vec\u003cSimulationFlagForEstimateFee\u003e,\n            BlockId,\n        );\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            request: Vec\u003cBroadcastedTxn\u003e,\n            simulation_flags: Vec\u003cSimulationFlagForEstimateFee\u003e,\n            block_id: BlockId,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(request, simulation_flags, block_id) =\n                            args_by_pos;\n                        ArgByName { request, simulation_flags, block_id }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { request, simulation_flags, block_id } = args;\n\n        match rpc.estimateFee(request, simulation_flags, block_id).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_estimateMessageFee\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(MsgFromL1, BlockId);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            message: MsgFromL1,\n            block_id: BlockId,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(message, block_id) = args_by_pos;\n                        ArgByName { message, block_id }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { message, block_id } = args;\n\n        match rpc.estimateMessageFee(message, block_id).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_getBlockTransactionCount\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(BlockId);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            block_id: BlockId,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(block_id) = args_by_pos;\n                        ArgByName { block_id }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { block_id } = args;\n\n        match rpc.getBlockTransactionCount(block_id).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_getBlockWithReceipts\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(BlockId);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            block_id: BlockId,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(block_id) = args_by_pos;\n                        ArgByName { block_id }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { block_id } = args;\n\n        match rpc.getBlockWithReceipts(block_id).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_getBlockWithTxHashes\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(BlockId);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            block_id: BlockId,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(block_id) = args_by_pos;\n                        ArgByName { block_id }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { block_id } = args;\n\n        match rpc.getBlockWithTxHashes(block_id).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_getBlockWithTxs\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(BlockId);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            block_id: BlockId,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(block_id) = args_by_pos;\n                        ArgByName { block_id }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { block_id } = args;\n\n        match rpc.getBlockWithTxs(block_id).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_getClass\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(BlockId, Felt);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            block_id: BlockId,\n            class_hash: Felt,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(block_id, class_hash) = args_by_pos;\n                        ArgByName { block_id, class_hash }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { block_id, class_hash } = args;\n\n        match rpc.getClass(block_id, class_hash).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_getClassAt\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(BlockId, Address);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            block_id: BlockId,\n            contract_address: Address,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(block_id, contract_address) = args_by_pos;\n                        ArgByName { block_id, contract_address }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { block_id, contract_address } = args;\n\n        match rpc.getClassAt(block_id, contract_address).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_getClassHashAt\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(BlockId, Address);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            block_id: BlockId,\n            contract_address: Address,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(block_id, contract_address) = args_by_pos;\n                        ArgByName { block_id, contract_address }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { block_id, contract_address } = args;\n\n        match rpc.getClassHashAt(block_id, contract_address).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_getEvents\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(GetEventsFilter);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            filter: GetEventsFilter,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(filter) = args_by_pos;\n                        ArgByName { filter }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { filter } = args;\n\n        match rpc.getEvents(filter).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_getNonce\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(BlockId, Address);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            block_id: BlockId,\n            contract_address: Address,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(block_id, contract_address) = args_by_pos;\n                        ArgByName { block_id, contract_address }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { block_id, contract_address } = args;\n\n        match rpc.getNonce(block_id, contract_address).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_getStateUpdate\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(BlockId);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            block_id: BlockId,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(block_id) = args_by_pos;\n                        ArgByName { block_id }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { block_id } = args;\n\n        match rpc.getStateUpdate(block_id).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_getStorageAt\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(Address, StorageKey, BlockId);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            contract_address: Address,\n            key: StorageKey,\n            block_id: BlockId,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(contract_address, key, block_id) =\n                            args_by_pos;\n                        ArgByName { contract_address, key, block_id }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { contract_address, key, block_id } = args;\n\n        match rpc.getStorageAt(contract_address, key, block_id).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_getTransactionByBlockIdAndIndex\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(BlockId, GetTransactionByBlockIdAndIndexIndex);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            block_id: BlockId,\n            index: GetTransactionByBlockIdAndIndexIndex,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(block_id, index) = args_by_pos;\n                        ArgByName { block_id, index }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { block_id, index } = args;\n\n        match rpc.getTransactionByBlockIdAndIndex(block_id, index).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_getTransactionByHash\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(TxnHash);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            transaction_hash: TxnHash,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(transaction_hash) = args_by_pos;\n                        ArgByName { transaction_hash }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { transaction_hash } = args;\n\n        match rpc.getTransactionByHash(transaction_hash).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_getTransactionReceipt\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(TxnHash);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            transaction_hash: TxnHash,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(transaction_hash) = args_by_pos;\n                        ArgByName { transaction_hash }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { transaction_hash } = args;\n\n        match rpc.getTransactionReceipt(transaction_hash).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_getTransactionStatus\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(TxnHash);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            transaction_hash: TxnHash,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(transaction_hash) = args_by_pos;\n                        ArgByName { transaction_hash }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { transaction_hash } = args;\n\n        match rpc.getTransactionStatus(transaction_hash).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_simulateTransactions\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(BlockId, Vec\u003cBroadcastedTxn\u003e, Vec\u003cSimulationFlag\u003e);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            block_id: BlockId,\n            transactions: Vec\u003cBroadcastedTxn\u003e,\n            simulation_flags: Vec\u003cSimulationFlag\u003e,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(block_id, transactions, simulation_flags) =\n                            args_by_pos;\n                        ArgByName { block_id, transactions, simulation_flags }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { block_id, transactions, simulation_flags } = args;\n\n        match rpc\n            .simulateTransactions(block_id, transactions, simulation_flags)\n            .await\n        {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_specVersion\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        _params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        match rpc.specVersion().await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(e) =\u003e jsonrpc::Response::error(1003, \u0026format!(\"{e:?}\")),\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_syncing\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        _params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        match rpc.syncing().await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(e) =\u003e jsonrpc::Response::error(1003, \u0026format!(\"{e:?}\")),\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_traceBlockTransactions\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(BlockId);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            block_id: BlockId,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(block_id) = args_by_pos;\n                        ArgByName { block_id }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { block_id } = args;\n\n        match rpc.traceBlockTransactions(block_id).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    async fn handle_traceTransaction\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        params: \u0026Value,\n    ) -\u003e jsonrpc::Response {\n        #[derive(Deserialize, Serialize)]\n        struct ArgByPos(TxnHash);\n\n        #[derive(Deserialize, Serialize)]\n        struct ArgByName {\n            transaction_hash: TxnHash,\n        }\n\n        let args =\n            serde_json::from_value::\u003cArgByName\u003e(params.clone()).or_else(|_| {\n                serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                    |args_by_pos| {\n                        let ArgByPos(transaction_hash) = args_by_pos;\n                        ArgByName { transaction_hash }\n                    },\n                )\n            });\n\n        let args: ArgByName = match args {\n            Ok(args) =\u003e args,\n            Err(error) =\u003e {\n                tracing::debug!(?error, \"failed to parse request params\");\n                return jsonrpc::Response::error(-32602, \"Invalid params\");\n            }\n        };\n\n        let ArgByName { transaction_hash } = args;\n\n        match rpc.traceTransaction(transaction_hash).await {\n            Ok(ret) =\u003e match serde_json::to_value(ret) {\n                Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse response object\");\n                    jsonrpc::Response::error(-32603, \"Internal error\")\n                }\n            },\n            Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n        }\n    }\n\n    pub async fn handle\u003cRPC: Rpc\u003e(\n        rpc: \u0026RPC,\n        req: \u0026jsonrpc::Request,\n    ) -\u003e jsonrpc::Response {\n        let params = \u0026req.params.clone().unwrap_or_default();\n\n        let response = match req.method.as_str() {\n            \"pathfinder_getProof\" =\u003e handle_getProof(rpc, params).await,\n            \"pathfinder_getTxStatus\" =\u003e handle_getTxStatus(rpc, params).await,\n            \"pathfinder_version\" =\u003e handle_version(rpc, params).await,\n            \"starknet_addDeclareTransaction\" =\u003e {\n                handle_addDeclareTransaction(rpc, params).await\n            }\n            \"starknet_addDeployAccountTransaction\" =\u003e {\n                handle_addDeployAccountTransaction(rpc, params).await\n            }\n            \"starknet_addInvokeTransaction\" =\u003e {\n                handle_addInvokeTransaction(rpc, params).await\n            }\n            \"starknet_blockHashAndNumber\" =\u003e {\n                handle_blockHashAndNumber(rpc, params).await\n            }\n            \"starknet_blockNumber\" =\u003e handle_blockNumber(rpc, params).await,\n            \"starknet_call\" =\u003e handle_call(rpc, params).await,\n            \"starknet_chainId\" =\u003e handle_chainId(rpc, params).await,\n            \"starknet_estimateFee\" =\u003e handle_estimateFee(rpc, params).await,\n            \"starknet_estimateMessageFee\" =\u003e {\n                handle_estimateMessageFee(rpc, params).await\n            }\n            \"starknet_getBlockTransactionCount\" =\u003e {\n                handle_getBlockTransactionCount(rpc, params).await\n            }\n            \"starknet_getBlockWithReceipts\" =\u003e {\n                handle_getBlockWithReceipts(rpc, params).await\n            }\n            \"starknet_getBlockWithTxHashes\" =\u003e {\n                handle_getBlockWithTxHashes(rpc, params).await\n            }\n            \"starknet_getBlockWithTxs\" =\u003e {\n                handle_getBlockWithTxs(rpc, params).await\n            }\n            \"starknet_getClass\" =\u003e handle_getClass(rpc, params).await,\n            \"starknet_getClassAt\" =\u003e handle_getClassAt(rpc, params).await,\n            \"starknet_getClassHashAt\" =\u003e {\n                handle_getClassHashAt(rpc, params).await\n            }\n            \"starknet_getEvents\" =\u003e handle_getEvents(rpc, params).await,\n            \"starknet_getNonce\" =\u003e handle_getNonce(rpc, params).await,\n            \"starknet_getStateUpdate\" =\u003e {\n                handle_getStateUpdate(rpc, params).await\n            }\n            \"starknet_getStorageAt\" =\u003e handle_getStorageAt(rpc, params).await,\n            \"starknet_getTransactionByBlockIdAndIndex\" =\u003e {\n                handle_getTransactionByBlockIdAndIndex(rpc, params).await\n            }\n            \"starknet_getTransactionByHash\" =\u003e {\n                handle_getTransactionByHash(rpc, params).await\n            }\n            \"starknet_getTransactionReceipt\" =\u003e {\n                handle_getTransactionReceipt(rpc, params).await\n            }\n            \"starknet_getTransactionStatus\" =\u003e {\n                handle_getTransactionStatus(rpc, params).await\n            }\n            \"starknet_simulateTransactions\" =\u003e {\n                handle_simulateTransactions(rpc, params).await\n            }\n            \"starknet_specVersion\" =\u003e handle_specVersion(rpc, params).await,\n            \"starknet_syncing\" =\u003e handle_syncing(rpc, params).await,\n            \"starknet_traceBlockTransactions\" =\u003e {\n                handle_traceBlockTransactions(rpc, params).await\n            }\n            \"starknet_traceTransaction\" =\u003e {\n                handle_traceTransaction(rpc, params).await\n            }\n            _ =\u003e jsonrpc::Response::error(-32601, \"Method not found\"),\n        };\n\n        return if let Some(id) = req.id.as_ref() {\n            response.with_id(id.clone())\n        } else {\n            response\n        };\n    }\n\n    pub mod blocking {\n        use super::*;\n        pub trait Rpc {\n            /// Returns merkle proofs of a contract's storage state\n            fn getProof(\n                \u0026self,\n                block_id: BlockId,\n                contract_address: Address,\n                keys: Vec\u003cStorageKey\u003e,\n            ) -\u003e std::result::Result\u003cGetProofResult, jsonrpc::Error\u003e;\n\n            /// Returns the status of a transaction\n            fn getTxStatus(\n                \u0026self,\n                transaction_hash: TxnHash,\n            ) -\u003e std::result::Result\u003cTxGatewayStatus, jsonrpc::Error\u003e;\n\n            /// The version of the pathfinder node hosting this API.\n            fn version(\u0026self) -\u003e std::result::Result\u003cString, jsonrpc::Error\u003e;\n\n            /// Submit a new class declaration transaction\n            fn addDeclareTransaction(\n                \u0026self,\n                declare_transaction: BroadcastedDeclareTxn,\n            ) -\u003e std::result::Result\u003cAddDeclareTransactionResult, jsonrpc::Error\u003e;\n\n            /// Submit a new deploy account transaction\n            fn addDeployAccountTransaction(\n                \u0026self,\n                deploy_account_transaction: BroadcastedDeployAccountTxn,\n            ) -\u003e std::result::Result\u003c\n                AddDeployAccountTransactionResult,\n                jsonrpc::Error,\n            \u003e;\n\n            /// Submit a new transaction to be added to the chain\n            fn addInvokeTransaction(\n                \u0026self,\n                invoke_transaction: BroadcastedInvokeTxn,\n            ) -\u003e std::result::Result\u003cAddInvokeTransactionResult, jsonrpc::Error\u003e;\n\n            /// Get the most recent accepted block hash and number\n            fn blockHashAndNumber(\n                \u0026self,\n            ) -\u003e std::result::Result\u003cBlockHashAndNumberResult, jsonrpc::Error\u003e;\n\n            /// Get the most recent accepted block number\n            fn blockNumber(\n                \u0026self,\n            ) -\u003e std::result::Result\u003cBlockNumber, jsonrpc::Error\u003e;\n\n            /// call a starknet function without creating a StarkNet transaction\n            fn call(\n                \u0026self,\n                request: FunctionCall,\n                block_id: BlockId,\n            ) -\u003e std::result::Result\u003cVec\u003cFelt\u003e, jsonrpc::Error\u003e;\n\n            /// Return the currently configured StarkNet chain id\n            fn chainId(\u0026self) -\u003e std::result::Result\u003cChainId, jsonrpc::Error\u003e;\n\n            /// estimate the fee for of StarkNet transactions\n            fn estimateFee(\n                \u0026self,\n                request: Vec\u003cBroadcastedTxn\u003e,\n                simulation_flags: Vec\u003cSimulationFlagForEstimateFee\u003e,\n                block_id: BlockId,\n            ) -\u003e std::result::Result\u003cVec\u003cFeeEstimate\u003e, jsonrpc::Error\u003e;\n\n            /// estimate the L2 fee of a message sent on L1\n            fn estimateMessageFee(\n                \u0026self,\n                message: MsgFromL1,\n                block_id: BlockId,\n            ) -\u003e std::result::Result\u003cFeeEstimate, jsonrpc::Error\u003e;\n\n            /// Get the number of transactions in a block given a block id\n            fn getBlockTransactionCount(\n                \u0026self,\n                block_id: BlockId,\n            ) -\u003e std::result::Result\u003c\n                GetBlockTransactionCountResult,\n                jsonrpc::Error,\n            \u003e;\n\n            /// Get block information with full transactions and receipts given the block id\n            fn getBlockWithReceipts(\n                \u0026self,\n                block_id: BlockId,\n            ) -\u003e std::result::Result\u003cGetBlockWithReceiptsResult, jsonrpc::Error\u003e;\n\n            /// Get block information with transaction hashes given the block id\n            fn getBlockWithTxHashes(\n                \u0026self,\n                block_id: BlockId,\n            ) -\u003e std::result::Result\u003cGetBlockWithTxHashesResult, jsonrpc::Error\u003e;\n\n            /// Get block information with full transactions given the block id\n            fn getBlockWithTxs(\n                \u0026self,\n                block_id: BlockId,\n            ) -\u003e std::result::Result\u003cGetBlockWithTxsResult, jsonrpc::Error\u003e;\n\n            /// Get the contract class definition in the given block associated with the given hash\n            fn getClass(\n                \u0026self,\n                block_id: BlockId,\n                class_hash: Felt,\n            ) -\u003e std::result::Result\u003cGetClassResult, jsonrpc::Error\u003e;\n\n            /// Get the contract class definition in the given block at the given address\n            fn getClassAt(\n                \u0026self,\n                block_id: BlockId,\n                contract_address: Address,\n            ) -\u003e std::result::Result\u003cGetClassAtResult, jsonrpc::Error\u003e;\n\n            /// Get the contract class hash in the given block for the contract deployed at the given address\n            fn getClassHashAt(\n                \u0026self,\n                block_id: BlockId,\n                contract_address: Address,\n            ) -\u003e std::result::Result\u003cFelt, jsonrpc::Error\u003e;\n\n            /// Returns all events matching the given filter\n            fn getEvents(\n                \u0026self,\n                filter: GetEventsFilter,\n            ) -\u003e std::result::Result\u003cEventsChunk, jsonrpc::Error\u003e;\n\n            /// Get the nonce associated with the given address in the given block\n            fn getNonce(\n                \u0026self,\n                block_id: BlockId,\n                contract_address: Address,\n            ) -\u003e std::result::Result\u003cFelt, jsonrpc::Error\u003e;\n\n            /// Get the information about the result of executing the requested block\n            fn getStateUpdate(\n                \u0026self,\n                block_id: BlockId,\n            ) -\u003e std::result::Result\u003cGetStateUpdateResult, jsonrpc::Error\u003e;\n\n            /// Get the value of the storage at the given address and key\n            fn getStorageAt(\n                \u0026self,\n                contract_address: Address,\n                key: StorageKey,\n                block_id: BlockId,\n            ) -\u003e std::result::Result\u003cFelt, jsonrpc::Error\u003e;\n\n            /// Get the details of a transaction by a given block id and index\n            fn getTransactionByBlockIdAndIndex(\n                \u0026self,\n                block_id: BlockId,\n                index: GetTransactionByBlockIdAndIndexIndex,\n            ) -\u003e std::result::Result\u003c\n                GetTransactionByBlockIdAndIndexResult,\n                jsonrpc::Error,\n            \u003e;\n\n            /// Get the details and status of a submitted transaction\n            fn getTransactionByHash(\n                \u0026self,\n                transaction_hash: TxnHash,\n            ) -\u003e std::result::Result\u003cGetTransactionByHashResult, jsonrpc::Error\u003e;\n\n            /// Get the transaction receipt by the transaction hash\n            fn getTransactionReceipt(\n                \u0026self,\n                transaction_hash: TxnHash,\n            ) -\u003e std::result::Result\u003cTxnReceiptWithBlockInfo, jsonrpc::Error\u003e;\n\n            /// Gets the transaction status (possibly reflecting that the tx is still in the mempool, or dropped from it)\n            fn getTransactionStatus(\n                \u0026self,\n                transaction_hash: TxnHash,\n            ) -\u003e std::result::Result\u003cGetTransactionStatusResult, jsonrpc::Error\u003e;\n\n            /// Simulate a given sequence of transactions on the requested state, and generate the execution traces. Note that some of the transactions may revert, in which case no error is thrown, but revert details can be seen on the returned trace object. . Note that some of the transactions may revert, this will be reflected by the revert_error property in the trace. Other types of failures (e.g. unexpected error or failure in the validation phase) will result in TRANSACTION_EXECUTION_ERROR.\n            fn simulateTransactions(\n                \u0026self,\n                block_id: BlockId,\n                transactions: Vec\u003cBroadcastedTxn\u003e,\n                simulation_flags: Vec\u003cSimulationFlag\u003e,\n            ) -\u003e std::result::Result\u003cVec\u003cSimulatedTransaction\u003e, jsonrpc::Error\u003e;\n\n            /// Returns the version of the Starknet JSON-RPC specification being used\n            fn specVersion(\n                \u0026self,\n            ) -\u003e std::result::Result\u003cString, jsonrpc::Error\u003e;\n\n            /// Returns an object about the sync status, or false if the node is not synching\n            fn syncing(\n                \u0026self,\n            ) -\u003e std::result::Result\u003cSyncingResult, jsonrpc::Error\u003e;\n\n            /// Retrieve traces for all transactions in the given block\n            fn traceBlockTransactions(\n                \u0026self,\n                block_id: BlockId,\n            ) -\u003e std::result::Result\u003cVec\u003cBlockTransactionTrace\u003e, jsonrpc::Error\u003e;\n\n            /// For a given executed transaction, return the trace of its execution, including internal calls\n            fn traceTransaction(\n                \u0026self,\n                transaction_hash: TxnHash,\n            ) -\u003e std::result::Result\u003cTransactionTrace, jsonrpc::Error\u003e;\n        }\n\n        fn handle_getProof\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(BlockId, Address, Vec\u003cStorageKey\u003e);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                block_id: BlockId,\n                contract_address: Address,\n                keys: Vec\u003cStorageKey\u003e,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(block_id, contract_address, keys) =\n                                args_by_pos;\n                            ArgByName { block_id, contract_address, keys }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { block_id, contract_address, keys } = args;\n\n            match rpc.getProof(block_id, contract_address, keys) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_getTxStatus\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(TxnHash);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                transaction_hash: TxnHash,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(transaction_hash) = args_by_pos;\n                            ArgByName { transaction_hash }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { transaction_hash } = args;\n\n            match rpc.getTxStatus(transaction_hash) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_version\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            _params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            match rpc.version() {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(e) =\u003e jsonrpc::Response::error(1003, \u0026format!(\"{e:?}\")),\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_addDeclareTransaction\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(BroadcastedDeclareTxn);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                declare_transaction: BroadcastedDeclareTxn,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(declare_transaction) = args_by_pos;\n                            ArgByName { declare_transaction }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { declare_transaction } = args;\n\n            match rpc.addDeclareTransaction(declare_transaction) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_addDeployAccountTransaction\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(BroadcastedDeployAccountTxn);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                deploy_account_transaction: BroadcastedDeployAccountTxn,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(deploy_account_transaction) =\n                                args_by_pos;\n                            ArgByName { deploy_account_transaction }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { deploy_account_transaction } = args;\n\n            match rpc.addDeployAccountTransaction(deploy_account_transaction) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_addInvokeTransaction\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(BroadcastedInvokeTxn);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                invoke_transaction: BroadcastedInvokeTxn,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(invoke_transaction) = args_by_pos;\n                            ArgByName { invoke_transaction }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { invoke_transaction } = args;\n\n            match rpc.addInvokeTransaction(invoke_transaction) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_blockHashAndNumber\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            _params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            match rpc.blockHashAndNumber() {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(e) =\u003e jsonrpc::Response::error(1003, \u0026format!(\"{e:?}\")),\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_blockNumber\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            _params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            match rpc.blockNumber() {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(e) =\u003e jsonrpc::Response::error(1003, \u0026format!(\"{e:?}\")),\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_call\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(FunctionCall, BlockId);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                request: FunctionCall,\n                block_id: BlockId,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(request, block_id) = args_by_pos;\n                            ArgByName { request, block_id }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { request, block_id } = args;\n\n            match rpc.call(request, block_id) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_chainId\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            _params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            match rpc.chainId() {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(e) =\u003e jsonrpc::Response::error(1003, \u0026format!(\"{e:?}\")),\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_estimateFee\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(\n                Vec\u003cBroadcastedTxn\u003e,\n                Vec\u003cSimulationFlagForEstimateFee\u003e,\n                BlockId,\n            );\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                request: Vec\u003cBroadcastedTxn\u003e,\n                simulation_flags: Vec\u003cSimulationFlagForEstimateFee\u003e,\n                block_id: BlockId,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(request, simulation_flags, block_id) =\n                                args_by_pos;\n                            ArgByName { request, simulation_flags, block_id }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { request, simulation_flags, block_id } = args;\n\n            match rpc.estimateFee(request, simulation_flags, block_id) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_estimateMessageFee\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(MsgFromL1, BlockId);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                message: MsgFromL1,\n                block_id: BlockId,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(message, block_id) = args_by_pos;\n                            ArgByName { message, block_id }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { message, block_id } = args;\n\n            match rpc.estimateMessageFee(message, block_id) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_getBlockTransactionCount\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(BlockId);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                block_id: BlockId,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(block_id) = args_by_pos;\n                            ArgByName { block_id }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { block_id } = args;\n\n            match rpc.getBlockTransactionCount(block_id) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_getBlockWithReceipts\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(BlockId);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                block_id: BlockId,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(block_id) = args_by_pos;\n                            ArgByName { block_id }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { block_id } = args;\n\n            match rpc.getBlockWithReceipts(block_id) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_getBlockWithTxHashes\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(BlockId);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                block_id: BlockId,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(block_id) = args_by_pos;\n                            ArgByName { block_id }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { block_id } = args;\n\n            match rpc.getBlockWithTxHashes(block_id) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_getBlockWithTxs\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(BlockId);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                block_id: BlockId,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(block_id) = args_by_pos;\n                            ArgByName { block_id }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { block_id } = args;\n\n            match rpc.getBlockWithTxs(block_id) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_getClass\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(BlockId, Felt);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                block_id: BlockId,\n                class_hash: Felt,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(block_id, class_hash) = args_by_pos;\n                            ArgByName { block_id, class_hash }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { block_id, class_hash } = args;\n\n            match rpc.getClass(block_id, class_hash) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_getClassAt\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(BlockId, Address);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                block_id: BlockId,\n                contract_address: Address,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(block_id, contract_address) =\n                                args_by_pos;\n                            ArgByName { block_id, contract_address }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { block_id, contract_address } = args;\n\n            match rpc.getClassAt(block_id, contract_address) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_getClassHashAt\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(BlockId, Address);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                block_id: BlockId,\n                contract_address: Address,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(block_id, contract_address) =\n                                args_by_pos;\n                            ArgByName { block_id, contract_address }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { block_id, contract_address } = args;\n\n            match rpc.getClassHashAt(block_id, contract_address) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_getEvents\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(GetEventsFilter);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                filter: GetEventsFilter,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(filter) = args_by_pos;\n                            ArgByName { filter }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { filter } = args;\n\n            match rpc.getEvents(filter) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_getNonce\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(BlockId, Address);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                block_id: BlockId,\n                contract_address: Address,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(block_id, contract_address) =\n                                args_by_pos;\n                            ArgByName { block_id, contract_address }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { block_id, contract_address } = args;\n\n            match rpc.getNonce(block_id, contract_address) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_getStateUpdate\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(BlockId);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                block_id: BlockId,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(block_id) = args_by_pos;\n                            ArgByName { block_id }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { block_id } = args;\n\n            match rpc.getStateUpdate(block_id) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_getStorageAt\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(Address, StorageKey, BlockId);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                contract_address: Address,\n                key: StorageKey,\n                block_id: BlockId,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(contract_address, key, block_id) =\n                                args_by_pos;\n                            ArgByName { contract_address, key, block_id }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { contract_address, key, block_id } = args;\n\n            match rpc.getStorageAt(contract_address, key, block_id) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_getTransactionByBlockIdAndIndex\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(BlockId, GetTransactionByBlockIdAndIndexIndex);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                block_id: BlockId,\n                index: GetTransactionByBlockIdAndIndexIndex,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(block_id, index) = args_by_pos;\n                            ArgByName { block_id, index }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { block_id, index } = args;\n\n            match rpc.getTransactionByBlockIdAndIndex(block_id, index) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_getTransactionByHash\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(TxnHash);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                transaction_hash: TxnHash,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(transaction_hash) = args_by_pos;\n                            ArgByName { transaction_hash }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { transaction_hash } = args;\n\n            match rpc.getTransactionByHash(transaction_hash) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_getTransactionReceipt\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(TxnHash);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                transaction_hash: TxnHash,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(transaction_hash) = args_by_pos;\n                            ArgByName { transaction_hash }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { transaction_hash } = args;\n\n            match rpc.getTransactionReceipt(transaction_hash) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_getTransactionStatus\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(TxnHash);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                transaction_hash: TxnHash,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(transaction_hash) = args_by_pos;\n                            ArgByName { transaction_hash }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { transaction_hash } = args;\n\n            match rpc.getTransactionStatus(transaction_hash) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_simulateTransactions\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(BlockId, Vec\u003cBroadcastedTxn\u003e, Vec\u003cSimulationFlag\u003e);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                block_id: BlockId,\n                transactions: Vec\u003cBroadcastedTxn\u003e,\n                simulation_flags: Vec\u003cSimulationFlag\u003e,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(\n                                block_id,\n                                transactions,\n                                simulation_flags,\n                            ) = args_by_pos;\n                            ArgByName {\n                                block_id,\n                                transactions,\n                                simulation_flags,\n                            }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { block_id, transactions, simulation_flags } = args;\n\n            match rpc.simulateTransactions(\n                block_id,\n                transactions,\n                simulation_flags,\n            ) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_specVersion\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            _params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            match rpc.specVersion() {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(e) =\u003e jsonrpc::Response::error(1003, \u0026format!(\"{e:?}\")),\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_syncing\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            _params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            match rpc.syncing() {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(e) =\u003e jsonrpc::Response::error(1003, \u0026format!(\"{e:?}\")),\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_traceBlockTransactions\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(BlockId);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                block_id: BlockId,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(block_id) = args_by_pos;\n                            ArgByName { block_id }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { block_id } = args;\n\n            match rpc.traceBlockTransactions(block_id) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        fn handle_traceTransaction\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            params: \u0026Value,\n        ) -\u003e jsonrpc::Response {\n            #[derive(Deserialize, Serialize)]\n            struct ArgByPos(TxnHash);\n\n            #[derive(Deserialize, Serialize)]\n            struct ArgByName {\n                transaction_hash: TxnHash,\n            }\n\n            let args = serde_json::from_value::\u003cArgByName\u003e(params.clone())\n                .or_else(|_| {\n                    serde_json::from_value::\u003cArgByPos\u003e(params.clone()).map(\n                        |args_by_pos| {\n                            let ArgByPos(transaction_hash) = args_by_pos;\n                            ArgByName { transaction_hash }\n                        },\n                    )\n                });\n\n            let args: ArgByName = match args {\n                Ok(args) =\u003e args,\n                Err(error) =\u003e {\n                    tracing::debug!(?error, \"failed to parse request params\");\n                    return jsonrpc::Response::error(-32602, \"Invalid params\");\n                }\n            };\n\n            let ArgByName { transaction_hash } = args;\n\n            match rpc.traceTransaction(transaction_hash) {\n                Ok(ret) =\u003e match serde_json::to_value(ret) {\n                    Ok(ret) =\u003e jsonrpc::Response::result(ret),\n                    Err(error) =\u003e {\n                        tracing::debug!(\n                            ?error,\n                            \"failed to parse response object\"\n                        );\n                        jsonrpc::Response::error(-32603, \"Internal error\")\n                    }\n                },\n                Err(e) =\u003e jsonrpc::Response::error(e.code, \u0026e.message),\n            }\n        }\n\n        pub fn handle\u003cRPC: Rpc\u003e(\n            rpc: \u0026RPC,\n            req: \u0026jsonrpc::Request,\n        ) -\u003e jsonrpc::Response {\n            let params = \u0026req.params.clone().unwrap_or_default();\n\n            let response = match req.method.as_str() {\n                \"pathfinder_getProof\" =\u003e handle_getProof(rpc, params),\n                \"pathfinder_getTxStatus\" =\u003e handle_getTxStatus(rpc, params),\n                \"pathfinder_version\" =\u003e handle_version(rpc, params),\n                \"starknet_addDeclareTransaction\" =\u003e {\n                    handle_addDeclareTransaction(rpc, params)\n                }\n                \"starknet_addDeployAccountTransaction\" =\u003e {\n                    handle_addDeployAccountTransaction(rpc, params)\n                }\n                \"starknet_addInvokeTransaction\" =\u003e {\n                    handle_addInvokeTransaction(rpc, params)\n                }\n                \"starknet_blockHashAndNumber\" =\u003e {\n                    handle_blockHashAndNumber(rpc, params)\n                }\n                \"starknet_blockNumber\" =\u003e handle_blockNumber(rpc, params),\n                \"starknet_call\" =\u003e handle_call(rpc, params),\n                \"starknet_chainId\" =\u003e handle_chainId(rpc, params),\n                \"starknet_estimateFee\" =\u003e handle_estimateFee(rpc, params),\n                \"starknet_estimateMessageFee\" =\u003e {\n                    handle_estimateMessageFee(rpc, params)\n                }\n                \"starknet_getBlockTransactionCount\" =\u003e {\n                    handle_getBlockTransactionCount(rpc, params)\n                }\n                \"starknet_getBlockWithReceipts\" =\u003e {\n                    handle_getBlockWithReceipts(rpc, params)\n                }\n                \"starknet_getBlockWithTxHashes\" =\u003e {\n                    handle_getBlockWithTxHashes(rpc, params)\n                }\n                \"starknet_getBlockWithTxs\" =\u003e {\n                    handle_getBlockWithTxs(rpc, params)\n                }\n                \"starknet_getClass\" =\u003e handle_getClass(rpc, params),\n                \"starknet_getClassAt\" =\u003e handle_getClassAt(rpc, params),\n                \"starknet_getClassHashAt\" =\u003e handle_getClassHashAt(rpc, params),\n                \"starknet_getEvents\" =\u003e handle_getEvents(rpc, params),\n                \"starknet_getNonce\" =\u003e handle_getNonce(rpc, params),\n                \"starknet_getStateUpdate\" =\u003e handle_getStateUpdate(rpc, params),\n                \"starknet_getStorageAt\" =\u003e handle_getStorageAt(rpc, params),\n                \"starknet_getTransactionByBlockIdAndIndex\" =\u003e {\n                    handle_getTransactionByBlockIdAndIndex(rpc, params)\n                }\n                \"starknet_getTransactionByHash\" =\u003e {\n                    handle_getTransactionByHash(rpc, params)\n                }\n                \"starknet_getTransactionReceipt\" =\u003e {\n                    handle_getTransactionReceipt(rpc, params)\n                }\n                \"starknet_getTransactionStatus\" =\u003e {\n                    handle_getTransactionStatus(rpc, params)\n                }\n                \"starknet_simulateTransactions\" =\u003e {\n                    handle_simulateTransactions(rpc, params)\n                }\n                \"starknet_specVersion\" =\u003e handle_specVersion(rpc, params),\n                \"starknet_syncing\" =\u003e handle_syncing(rpc, params),\n                \"starknet_traceBlockTransactions\" =\u003e {\n                    handle_traceBlockTransactions(rpc, params)\n                }\n                \"starknet_traceTransaction\" =\u003e {\n                    handle_traceTransaction(rpc, params)\n                }\n                _ =\u003e jsonrpc::Response::error(-32601, \"Method not found\"),\n            };\n\n            return if let Some(id) = req.id.as_ref() {\n                response.with_id(id.clone())\n            } else {\n                response\n            };\n        }\n    }\n    pub mod client {\n        use super::*;\n\n        #[cfg(not(target_arch = \"wasm32\"))]\n        #[async_trait::async_trait]\n        pub trait HttpClient: Sync + Send {\n            async fn post(\n                \u0026self,\n                url: \u0026str,\n                request: \u0026jsonrpc::Request,\n            ) -\u003e std::result::Result\u003cjsonrpc::Response, jsonrpc::Error\u003e;\n        }\n\n        #[cfg(target_arch = \"wasm32\")]\n        #[async_trait::async_trait(?Send)]\n        pub trait HttpClient {\n            async fn post(\n                \u0026self,\n                url: \u0026str,\n                request: \u0026jsonrpc::Request,\n            ) -\u003e std::result::Result\u003cjsonrpc::Response, jsonrpc::Error\u003e;\n        }\n\n        #[derive(Clone)]\n        pub struct Client\u003cHTTP: HttpClient\u003e {\n            http: std::sync::Arc\u003cHTTP\u003e,\n            pub url: String,\n        }\n\n        impl\u003cHTTP: HttpClient\u003e Client\u003cHTTP\u003e {\n            pub fn new(url: \u0026str, http: HTTP) -\u003e Self {\n                Self { url: url.to_string(), http: std::sync::Arc::new(http) }\n            }\n        }\n\n        #[cfg_attr(target_arch = \"wasm32\", async_trait::async_trait(?Send))]\n        #[cfg_attr(not(target_arch = \"wasm32\"), async_trait::async_trait)]\n        impl\u003cHTTP: HttpClient\u003e super::Rpc for Client\u003cHTTP\u003e {\n            async fn getProof(\n                \u0026self,\n                block_id: BlockId,\n                contract_address: Address,\n                keys: Vec\u003cStorageKey\u003e,\n            ) -\u003e std::result::Result\u003cGetProofResult, jsonrpc::Error\u003e\n            {\n                let args = (block_id, contract_address, keys);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"pathfinder_getProof\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: GetProofResult = serde_json::from_value(value)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn getTxStatus(\n                \u0026self,\n                transaction_hash: TxnHash,\n            ) -\u003e std::result::Result\u003cTxGatewayStatus, jsonrpc::Error\u003e\n            {\n                let args = (transaction_hash,);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"pathfinder_getTxStatus\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: TxGatewayStatus = serde_json::from_value(value)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn version(\n                \u0026self,\n            ) -\u003e std::result::Result\u003cString, jsonrpc::Error\u003e {\n                let req = jsonrpc::Request::new(\n                    \"pathfinder_version\".to_string(),\n                    serde_json::Value::Array(vec![]),\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: String =\n                        serde_json::from_value(value).map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn addDeclareTransaction(\n                \u0026self,\n                declare_transaction: BroadcastedDeclareTxn,\n            ) -\u003e std::result::Result\u003cAddDeclareTransactionResult, jsonrpc::Error\u003e\n            {\n                let args = (declare_transaction,);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"starknet_addDeclareTransaction\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: AddDeclareTransactionResult =\n                        serde_json::from_value(value).map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn addDeployAccountTransaction(\n                \u0026self,\n                deploy_account_transaction: BroadcastedDeployAccountTxn,\n            ) -\u003e std::result::Result\u003c\n                AddDeployAccountTransactionResult,\n                jsonrpc::Error,\n            \u003e {\n                let args = (deploy_account_transaction,);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"starknet_addDeployAccountTransaction\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: AddDeployAccountTransactionResult =\n                        serde_json::from_value(value).map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn addInvokeTransaction(\n                \u0026self,\n                invoke_transaction: BroadcastedInvokeTxn,\n            ) -\u003e std::result::Result\u003cAddInvokeTransactionResult, jsonrpc::Error\u003e\n            {\n                let args = (invoke_transaction,);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"starknet_addInvokeTransaction\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: AddInvokeTransactionResult =\n                        serde_json::from_value(value).map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn blockHashAndNumber(\n                \u0026self,\n            ) -\u003e std::result::Result\u003cBlockHashAndNumberResult, jsonrpc::Error\u003e\n            {\n                let req = jsonrpc::Request::new(\n                    \"starknet_blockHashAndNumber\".to_string(),\n                    serde_json::Value::Array(vec![]),\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: BlockHashAndNumberResult =\n                        serde_json::from_value(value).map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn blockNumber(\n                \u0026self,\n            ) -\u003e std::result::Result\u003cBlockNumber, jsonrpc::Error\u003e {\n                let req = jsonrpc::Request::new(\n                    \"starknet_blockNumber\".to_string(),\n                    serde_json::Value::Array(vec![]),\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: BlockNumber = serde_json::from_value(value)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn call(\n                \u0026self,\n                request: FunctionCall,\n                block_id: BlockId,\n            ) -\u003e std::result::Result\u003cVec\u003cFelt\u003e, jsonrpc::Error\u003e {\n                let args = (request, block_id);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req =\n                    jsonrpc::Request::new(\"starknet_call\".to_string(), params)\n                        .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: Vec\u003cFelt\u003e = serde_json::from_value(value)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn chainId(\n                \u0026self,\n            ) -\u003e std::result::Result\u003cChainId, jsonrpc::Error\u003e {\n                let req = jsonrpc::Request::new(\n                    \"starknet_chainId\".to_string(),\n                    serde_json::Value::Array(vec![]),\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: ChainId =\n                        serde_json::from_value(value).map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn estimateFee(\n                \u0026self,\n                request: Vec\u003cBroadcastedTxn\u003e,\n                simulation_flags: Vec\u003cSimulationFlagForEstimateFee\u003e,\n                block_id: BlockId,\n            ) -\u003e std::result::Result\u003cVec\u003cFeeEstimate\u003e, jsonrpc::Error\u003e\n            {\n                let args = (request, simulation_flags, block_id);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"starknet_estimateFee\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: Vec\u003cFeeEstimate\u003e = serde_json::from_value(value)\n                        .map_err(|e| {\n                        jsonrpc::Error::new(\n                            5002,\n                            format!(\"Invalid response object: {e}.\"),\n                        )\n                    })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn estimateMessageFee(\n                \u0026self,\n                message: MsgFromL1,\n                block_id: BlockId,\n            ) -\u003e std::result::Result\u003cFeeEstimate, jsonrpc::Error\u003e {\n                let args = (message, block_id);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"starknet_estimateMessageFee\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: FeeEstimate = serde_json::from_value(value)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn getBlockTransactionCount(\n                \u0026self,\n                block_id: BlockId,\n            ) -\u003e std::result::Result\u003c\n                GetBlockTransactionCountResult,\n                jsonrpc::Error,\n            \u003e {\n                let args = (block_id,);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"starknet_getBlockTransactionCount\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: GetBlockTransactionCountResult =\n                        serde_json::from_value(value).map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn getBlockWithReceipts(\n                \u0026self,\n                block_id: BlockId,\n            ) -\u003e std::result::Result\u003cGetBlockWithReceiptsResult, jsonrpc::Error\u003e\n            {\n                let args = (block_id,);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"starknet_getBlockWithReceipts\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: GetBlockWithReceiptsResult =\n                        serde_json::from_value(value).map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn getBlockWithTxHashes(\n                \u0026self,\n                block_id: BlockId,\n            ) -\u003e std::result::Result\u003cGetBlockWithTxHashesResult, jsonrpc::Error\u003e\n            {\n                let args = (block_id,);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"starknet_getBlockWithTxHashes\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: GetBlockWithTxHashesResult =\n                        serde_json::from_value(value).map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn getBlockWithTxs(\n                \u0026self,\n                block_id: BlockId,\n            ) -\u003e std::result::Result\u003cGetBlockWithTxsResult, jsonrpc::Error\u003e\n            {\n                let args = (block_id,);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"starknet_getBlockWithTxs\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: GetBlockWithTxsResult =\n                        serde_json::from_value(value).map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn getClass(\n                \u0026self,\n                block_id: BlockId,\n                class_hash: Felt,\n            ) -\u003e std::result::Result\u003cGetClassResult, jsonrpc::Error\u003e\n            {\n                let args = (block_id, class_hash);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"starknet_getClass\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: GetClassResult = serde_json::from_value(value)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn getClassAt(\n                \u0026self,\n                block_id: BlockId,\n                contract_address: Address,\n            ) -\u003e std::result::Result\u003cGetClassAtResult, jsonrpc::Error\u003e\n            {\n                let args = (block_id, contract_address);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"starknet_getClassAt\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: GetClassAtResult = serde_json::from_value(value)\n                        .map_err(|e| {\n                        jsonrpc::Error::new(\n                            5002,\n                            format!(\"Invalid response object: {e}.\"),\n                        )\n                    })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn getClassHashAt(\n                \u0026self,\n                block_id: BlockId,\n                contract_address: Address,\n            ) -\u003e std::result::Result\u003cFelt, jsonrpc::Error\u003e {\n                let args = (block_id, contract_address);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"starknet_getClassHashAt\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: Felt =\n                        serde_json::from_value(value).map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn getEvents(\n                \u0026self,\n                filter: GetEventsFilter,\n            ) -\u003e std::result::Result\u003cEventsChunk, jsonrpc::Error\u003e {\n                let args = (filter,);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"starknet_getEvents\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: EventsChunk = serde_json::from_value(value)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn getNonce(\n                \u0026self,\n                block_id: BlockId,\n                contract_address: Address,\n            ) -\u003e std::result::Result\u003cFelt, jsonrpc::Error\u003e {\n                let args = (block_id, contract_address);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"starknet_getNonce\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: Felt =\n                        serde_json::from_value(value).map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn getStateUpdate(\n                \u0026self,\n                block_id: BlockId,\n            ) -\u003e std::result::Result\u003cGetStateUpdateResult, jsonrpc::Error\u003e\n            {\n                let args = (block_id,);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"starknet_getStateUpdate\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: GetStateUpdateResult =\n                        serde_json::from_value(value).map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn getStorageAt(\n                \u0026self,\n                contract_address: Address,\n                key: StorageKey,\n                block_id: BlockId,\n            ) -\u003e std::result::Result\u003cFelt, jsonrpc::Error\u003e {\n                let args = (contract_address, key, block_id);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"starknet_getStorageAt\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: Felt =\n                        serde_json::from_value(value).map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn getTransactionByBlockIdAndIndex(\n                \u0026self,\n                block_id: BlockId,\n                index: GetTransactionByBlockIdAndIndexIndex,\n            ) -\u003e std::result::Result\u003c\n                GetTransactionByBlockIdAndIndexResult,\n                jsonrpc::Error,\n            \u003e {\n                let args = (block_id, index);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"starknet_getTransactionByBlockIdAndIndex\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: GetTransactionByBlockIdAndIndexResult =\n                        serde_json::from_value(value).map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn getTransactionByHash(\n                \u0026self,\n                transaction_hash: TxnHash,\n            ) -\u003e std::result::Result\u003cGetTransactionByHashResult, jsonrpc::Error\u003e\n            {\n                let args = (transaction_hash,);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"starknet_getTransactionByHash\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: GetTransactionByHashResult =\n                        serde_json::from_value(value).map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn getTransactionReceipt(\n                \u0026self,\n                transaction_hash: TxnHash,\n            ) -\u003e std::result::Result\u003cTxnReceiptWithBlockInfo, jsonrpc::Error\u003e\n            {\n                let args = (transaction_hash,);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"starknet_getTransactionReceipt\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: TxnReceiptWithBlockInfo =\n                        serde_json::from_value(value).map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn getTransactionStatus(\n                \u0026self,\n                transaction_hash: TxnHash,\n            ) -\u003e std::result::Result\u003cGetTransactionStatusResult, jsonrpc::Error\u003e\n            {\n                let args = (transaction_hash,);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"starknet_getTransactionStatus\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: GetTransactionStatusResult =\n                        serde_json::from_value(value).map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn simulateTransactions(\n                \u0026self,\n                block_id: BlockId,\n                transactions: Vec\u003cBroadcastedTxn\u003e,\n                simulation_flags: Vec\u003cSimulationFlag\u003e,\n            ) -\u003e std::result::Result\u003cVec\u003cSimulatedTransaction\u003e, jsonrpc::Error\u003e\n            {\n                let args = (block_id, transactions, simulation_flags);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"starknet_simulateTransactions\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: Vec\u003cSimulatedTransaction\u003e =\n                        serde_json::from_value(value).map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn specVersion(\n                \u0026self,\n            ) -\u003e std::result::Result\u003cString, jsonrpc::Error\u003e {\n                let req = jsonrpc::Request::new(\n                    \"starknet_specVersion\".to_string(),\n                    serde_json::Value::Array(vec![]),\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: String =\n                        serde_json::from_value(value).map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn syncing(\n                \u0026self,\n            ) -\u003e std::result::Result\u003cSyncingResult, jsonrpc::Error\u003e\n            {\n                let req = jsonrpc::Request::new(\n                    \"starknet_syncing\".to_string(),\n                    serde_json::Value::Array(vec![]),\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: SyncingResult = serde_json::from_value(value)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn traceBlockTransactions(\n                \u0026self,\n                block_id: BlockId,\n            ) -\u003e std::result::Result\u003cVec\u003cBlockTransactionTrace\u003e, jsonrpc::Error\u003e\n            {\n                let args = (block_id,);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"starknet_traceBlockTransactions\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: Vec\u003cBlockTransactionTrace\u003e =\n                        serde_json::from_value(value).map_err(|e| {\n                            jsonrpc::Error::new(\n                                5002,\n                                format!(\"Invalid response object: {e}.\"),\n                            )\n                        })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n\n            async fn traceTransaction(\n                \u0026self,\n                transaction_hash: TxnHash,\n            ) -\u003e std::result::Result\u003cTransactionTrace, jsonrpc::Error\u003e\n            {\n                let args = (transaction_hash,);\n\n                let params: serde_json::Value = serde_json::to_value(args)\n                    .map_err(|e| {\n                        jsonrpc::Error::new(\n                            4001,\n                            format!(\"Invalid params: {e}.\"),\n                        )\n                    })?;\n                let req = jsonrpc::Request::new(\n                    \"starknet_traceTransaction\".to_string(),\n                    params,\n                )\n                .with_id(jsonrpc::Id::Number(1));\n\n                tracing::debug!(request=?req, \"processing\");\n                let mut res: jsonrpc::Response =\n                    self.http.post(\u0026self.url, \u0026req).await?;\n                tracing::debug!(response=?res, \"processing\");\n\n                if let Some(err) = res.error.take() {\n                    tracing::error!(error=?err, \"failed\");\n                    return Err(err);\n                }\n\n                if let Some(value) = res.result.take() {\n                    let ret: TransactionTrace = serde_json::from_value(value)\n                        .map_err(|e| {\n                        jsonrpc::Error::new(\n                            5002,\n                            format!(\"Invalid response object: {e}.\"),\n                        )\n                    })?;\n\n                    tracing::debug!(result=?ret, \"ready\");\n\n                    Ok(ret)\n                } else {\n                    tracing::error!(\"both error and result are missing\");\n                    Err(jsonrpc::Error::new(\n                        5003,\n                        \"Response missing\".to_string(),\n                    ))\n                }\n            }\n        }\n\n        pub mod blocking {\n            use super::*;\n\n            #[cfg(not(target_arch = \"wasm32\"))]\n            pub trait HttpClient: Sync + Send {\n                fn post(\n                    \u0026self,\n                    url: \u0026str,\n                    request: \u0026jsonrpc::Request,\n                ) -\u003e std::result::Result\u003cjsonrpc::Response, jsonrpc::Error\u003e;\n            }\n\n            #[cfg(target_arch = \"wasm32\")]\n            pub trait HttpClient {\n                fn post(\n                    \u0026self,\n                    url: \u0026str,\n                    request: \u0026jsonrpc::Request,\n                ) -\u003e std::result::Result\u003cjsonrpc::Response, jsonrpc::Error\u003e;\n            }\n\n            #[derive(Clone)]\n            pub struct Client\u003cHTTP: HttpClient\u003e {\n                http: HTTP,\n                pub url: String,\n            }\n\n            impl\u003cHTTP: HttpClient\u003e Client\u003cHTTP\u003e {\n                pub fn new(url: \u0026str, http: HTTP) -\u003e Self {\n                    Self { url: url.to_string(), http }\n                }\n            }\n\n            impl\u003cHTTP: HttpClient\u003e super::super::blocking::Rpc for Client\u003cHTTP\u003e {\n                fn getProof(\n                    \u0026self,\n                    block_id: BlockId,\n                    contract_address: Address,\n                    keys: Vec\u003cStorageKey\u003e,\n                ) -\u003e std::result::Result\u003cGetProofResult, jsonrpc::Error\u003e\n                {\n                    let args = (block_id, contract_address, keys);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"pathfinder_getProof\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: GetProofResult = serde_json::from_value(value)\n                            .map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn getTxStatus(\n                    \u0026self,\n                    transaction_hash: TxnHash,\n                ) -\u003e std::result::Result\u003cTxGatewayStatus, jsonrpc::Error\u003e\n                {\n                    let args = (transaction_hash,);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"pathfinder_getTxStatus\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: TxGatewayStatus =\n                            serde_json::from_value(value).map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn version(\n                    \u0026self,\n                ) -\u003e std::result::Result\u003cString, jsonrpc::Error\u003e\n                {\n                    let req = jsonrpc::Request::new(\n                        \"pathfinder_version\".to_string(),\n                        serde_json::Value::Array(vec![]),\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: String = serde_json::from_value(value)\n                            .map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn addDeclareTransaction(\n                    \u0026self,\n                    declare_transaction: BroadcastedDeclareTxn,\n                ) -\u003e std::result::Result\u003c\n                    AddDeclareTransactionResult,\n                    jsonrpc::Error,\n                \u003e {\n                    let args = (declare_transaction,);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_addDeclareTransaction\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: AddDeclareTransactionResult =\n                            serde_json::from_value(value).map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn addDeployAccountTransaction(\n                    \u0026self,\n                    deploy_account_transaction: BroadcastedDeployAccountTxn,\n                ) -\u003e std::result::Result\u003c\n                    AddDeployAccountTransactionResult,\n                    jsonrpc::Error,\n                \u003e {\n                    let args = (deploy_account_transaction,);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_addDeployAccountTransaction\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: AddDeployAccountTransactionResult =\n                            serde_json::from_value(value).map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn addInvokeTransaction(\n                    \u0026self,\n                    invoke_transaction: BroadcastedInvokeTxn,\n                ) -\u003e std::result::Result\u003c\n                    AddInvokeTransactionResult,\n                    jsonrpc::Error,\n                \u003e {\n                    let args = (invoke_transaction,);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_addInvokeTransaction\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: AddInvokeTransactionResult =\n                            serde_json::from_value(value).map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn blockHashAndNumber(\n                    \u0026self,\n                ) -\u003e std::result::Result\u003cBlockHashAndNumberResult, jsonrpc::Error\u003e\n                {\n                    let req = jsonrpc::Request::new(\n                        \"starknet_blockHashAndNumber\".to_string(),\n                        serde_json::Value::Array(vec![]),\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: BlockHashAndNumberResult =\n                            serde_json::from_value(value).map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn blockNumber(\n                    \u0026self,\n                ) -\u003e std::result::Result\u003cBlockNumber, jsonrpc::Error\u003e\n                {\n                    let req = jsonrpc::Request::new(\n                        \"starknet_blockNumber\".to_string(),\n                        serde_json::Value::Array(vec![]),\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: BlockNumber = serde_json::from_value(value)\n                            .map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn call(\n                    \u0026self,\n                    request: FunctionCall,\n                    block_id: BlockId,\n                ) -\u003e std::result::Result\u003cVec\u003cFelt\u003e, jsonrpc::Error\u003e\n                {\n                    let args = (request, block_id);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_call\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: Vec\u003cFelt\u003e = serde_json::from_value(value)\n                            .map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn chainId(\n                    \u0026self,\n                ) -\u003e std::result::Result\u003cChainId, jsonrpc::Error\u003e\n                {\n                    let req = jsonrpc::Request::new(\n                        \"starknet_chainId\".to_string(),\n                        serde_json::Value::Array(vec![]),\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: ChainId = serde_json::from_value(value)\n                            .map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn estimateFee(\n                    \u0026self,\n                    request: Vec\u003cBroadcastedTxn\u003e,\n                    simulation_flags: Vec\u003cSimulationFlagForEstimateFee\u003e,\n                    block_id: BlockId,\n                ) -\u003e std::result::Result\u003cVec\u003cFeeEstimate\u003e, jsonrpc::Error\u003e\n                {\n                    let args = (request, simulation_flags, block_id);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_estimateFee\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: Vec\u003cFeeEstimate\u003e =\n                            serde_json::from_value(value).map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn estimateMessageFee(\n                    \u0026self,\n                    message: MsgFromL1,\n                    block_id: BlockId,\n                ) -\u003e std::result::Result\u003cFeeEstimate, jsonrpc::Error\u003e\n                {\n                    let args = (message, block_id);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_estimateMessageFee\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: FeeEstimate = serde_json::from_value(value)\n                            .map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn getBlockTransactionCount(\n                    \u0026self,\n                    block_id: BlockId,\n                ) -\u003e std::result::Result\u003c\n                    GetBlockTransactionCountResult,\n                    jsonrpc::Error,\n                \u003e {\n                    let args = (block_id,);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_getBlockTransactionCount\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: GetBlockTransactionCountResult =\n                            serde_json::from_value(value).map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn getBlockWithReceipts(\n                    \u0026self,\n                    block_id: BlockId,\n                ) -\u003e std::result::Result\u003c\n                    GetBlockWithReceiptsResult,\n                    jsonrpc::Error,\n                \u003e {\n                    let args = (block_id,);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_getBlockWithReceipts\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: GetBlockWithReceiptsResult =\n                            serde_json::from_value(value).map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn getBlockWithTxHashes(\n                    \u0026self,\n                    block_id: BlockId,\n                ) -\u003e std::result::Result\u003c\n                    GetBlockWithTxHashesResult,\n                    jsonrpc::Error,\n                \u003e {\n                    let args = (block_id,);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_getBlockWithTxHashes\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: GetBlockWithTxHashesResult =\n                            serde_json::from_value(value).map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn getBlockWithTxs(\n                    \u0026self,\n                    block_id: BlockId,\n                ) -\u003e std::result::Result\u003cGetBlockWithTxsResult, jsonrpc::Error\u003e\n                {\n                    let args = (block_id,);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_getBlockWithTxs\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: GetBlockWithTxsResult =\n                            serde_json::from_value(value).map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn getClass(\n                    \u0026self,\n                    block_id: BlockId,\n                    class_hash: Felt,\n                ) -\u003e std::result::Result\u003cGetClassResult, jsonrpc::Error\u003e\n                {\n                    let args = (block_id, class_hash);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_getClass\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: GetClassResult = serde_json::from_value(value)\n                            .map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn getClassAt(\n                    \u0026self,\n                    block_id: BlockId,\n                    contract_address: Address,\n                ) -\u003e std::result::Result\u003cGetClassAtResult, jsonrpc::Error\u003e\n                {\n                    let args = (block_id, contract_address);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_getClassAt\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: GetClassAtResult =\n                            serde_json::from_value(value).map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn getClassHashAt(\n                    \u0026self,\n                    block_id: BlockId,\n                    contract_address: Address,\n                ) -\u003e std::result::Result\u003cFelt, jsonrpc::Error\u003e {\n                    let args = (block_id, contract_address);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_getClassHashAt\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: Felt =\n                            serde_json::from_value(value).map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn getEvents(\n                    \u0026self,\n                    filter: GetEventsFilter,\n                ) -\u003e std::result::Result\u003cEventsChunk, jsonrpc::Error\u003e\n                {\n                    let args = (filter,);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_getEvents\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: EventsChunk = serde_json::from_value(value)\n                            .map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn getNonce(\n                    \u0026self,\n                    block_id: BlockId,\n                    contract_address: Address,\n                ) -\u003e std::result::Result\u003cFelt, jsonrpc::Error\u003e {\n                    let args = (block_id, contract_address);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_getNonce\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: Felt =\n                            serde_json::from_value(value).map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn getStateUpdate(\n                    \u0026self,\n                    block_id: BlockId,\n                ) -\u003e std::result::Result\u003cGetStateUpdateResult, jsonrpc::Error\u003e\n                {\n                    let args = (block_id,);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_getStateUpdate\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: GetStateUpdateResult =\n                            serde_json::from_value(value).map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn getStorageAt(\n                    \u0026self,\n                    contract_address: Address,\n                    key: StorageKey,\n                    block_id: BlockId,\n                ) -\u003e std::result::Result\u003cFelt, jsonrpc::Error\u003e {\n                    let args = (contract_address, key, block_id);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_getStorageAt\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: Felt =\n                            serde_json::from_value(value).map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn getTransactionByBlockIdAndIndex(\n                    \u0026self,\n                    block_id: BlockId,\n                    index: GetTransactionByBlockIdAndIndexIndex,\n                ) -\u003e std::result::Result\u003c\n                    GetTransactionByBlockIdAndIndexResult,\n                    jsonrpc::Error,\n                \u003e {\n                    let args = (block_id, index);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_getTransactionByBlockIdAndIndex\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: GetTransactionByBlockIdAndIndexResult =\n                            serde_json::from_value(value).map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn getTransactionByHash(\n                    \u0026self,\n                    transaction_hash: TxnHash,\n                ) -\u003e std::result::Result\u003c\n                    GetTransactionByHashResult,\n                    jsonrpc::Error,\n                \u003e {\n                    let args = (transaction_hash,);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_getTransactionByHash\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: GetTransactionByHashResult =\n                            serde_json::from_value(value).map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn getTransactionReceipt(\n                    \u0026self,\n                    transaction_hash: TxnHash,\n                ) -\u003e std::result::Result\u003cTxnReceiptWithBlockInfo, jsonrpc::Error\u003e\n                {\n                    let args = (transaction_hash,);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_getTransactionReceipt\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: TxnReceiptWithBlockInfo =\n                            serde_json::from_value(value).map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn getTransactionStatus(\n                    \u0026self,\n                    transaction_hash: TxnHash,\n                ) -\u003e std::result::Result\u003c\n                    GetTransactionStatusResult,\n                    jsonrpc::Error,\n                \u003e {\n                    let args = (transaction_hash,);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_getTransactionStatus\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: GetTransactionStatusResult =\n                            serde_json::from_value(value).map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn simulateTransactions(\n                    \u0026self,\n                    block_id: BlockId,\n                    transactions: Vec\u003cBroadcastedTxn\u003e,\n                    simulation_flags: Vec\u003cSimulationFlag\u003e,\n                ) -\u003e std::result::Result\u003c\n                    Vec\u003cSimulatedTransaction\u003e,\n                    jsonrpc::Error,\n                \u003e {\n                    let args = (block_id, transactions, simulation_flags);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_simulateTransactions\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: Vec\u003cSimulatedTransaction\u003e =\n                            serde_json::from_value(value).map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn specVersion(\n                    \u0026self,\n                ) -\u003e std::result::Result\u003cString, jsonrpc::Error\u003e\n                {\n                    let req = jsonrpc::Request::new(\n                        \"starknet_specVersion\".to_string(),\n                        serde_json::Value::Array(vec![]),\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: String = serde_json::from_value(value)\n                            .map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn syncing(\n                    \u0026self,\n                ) -\u003e std::result::Result\u003cSyncingResult, jsonrpc::Error\u003e\n                {\n                    let req = jsonrpc::Request::new(\n                        \"starknet_syncing\".to_string(),\n                        serde_json::Value::Array(vec![]),\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: SyncingResult = serde_json::from_value(value)\n                            .map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn traceBlockTransactions(\n                    \u0026self,\n                    block_id: BlockId,\n                ) -\u003e std::result::Result\u003c\n                    Vec\u003cBlockTransactionTrace\u003e,\n                    jsonrpc::Error,\n                \u003e {\n                    let args = (block_id,);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_traceBlockTransactions\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: Vec\u003cBlockTransactionTrace\u003e =\n                            serde_json::from_value(value).map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n\n                fn traceTransaction(\n                    \u0026self,\n                    transaction_hash: TxnHash,\n                ) -\u003e std::result::Result\u003cTransactionTrace, jsonrpc::Error\u003e\n                {\n                    let args = (transaction_hash,);\n\n                    let params: serde_json::Value = serde_json::to_value(args)\n                        .map_err(|e| {\n                            jsonrpc::Error::new(\n                                4001,\n                                format!(\"Invalid params: {e}.\"),\n                            )\n                        })?;\n                    let req = jsonrpc::Request::new(\n                        \"starknet_traceTransaction\".to_string(),\n                        params,\n                    )\n                    .with_id(jsonrpc::Id::Number(1));\n\n                    tracing::debug!(request=?req, \"processing\");\n                    let mut res: jsonrpc::Response =\n                        self.http.post(\u0026self.url, \u0026req)?;\n                    tracing::debug!(response=?res, \"processing\");\n\n                    if let Some(err) = res.error.take() {\n                        tracing::error!(error=?err, \"failed\");\n                        return Err(err);\n                    }\n\n                    if let Some(value) = res.result.take() {\n                        let ret: TransactionTrace =\n                            serde_json::from_value(value).map_err(|e| {\n                                jsonrpc::Error::new(\n                                    5002,\n                                    format!(\"Invalid response object: {e}.\"),\n                                )\n                            })?;\n\n                        tracing::debug!(result=?ret, \"ready\");\n\n                        Ok(ret)\n                    } else {\n                        tracing::error!(\"both error and result are missing\");\n                        Err(jsonrpc::Error::new(\n                            5003,\n                            \"Response missing\".to_string(),\n                        ))\n                    }\n                }\n            }\n        }\n    }\n}\n// ^^^ GENERATED CODE ABOVE ^^^\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","work","Work","Eiger","code","beerus","src","lib.rs"],"content":"pub mod client;\npub mod config;\npub mod exe;\npub mod feeder;\n\n#[cfg(not(tarpaulin_include))] // exclude from code-coverage report\npub mod gen;\n\npub mod proof;\n\n#[cfg(not(target_arch = \"wasm32\"))]\npub mod rpc;\n\npub mod util;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","work","Work","Eiger","code","beerus","src","proof.rs"],"content":"use iamgroot::jsonrpc;\nuse starknet_crypto::{\n    pedersen_hash, poseidon_hash_many, Felt as FieldElement,\n};\n\nuse crate::gen::{\n    Address, BinaryNode, BinaryNodeBinary, ContractData, EdgeNode,\n    EdgeNodeEdge, Felt, GetProofResult, Node, StorageKey,\n};\n\nuse crate::util::{felt_from_bits, felt_to_bits};\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum Direction {\n    Left,\n    Right,\n}\n\nimpl From\u003cbool\u003e for Direction {\n    fn from(flag: bool) -\u003e Self {\n        if flag {\n            Self::Right\n        } else {\n            Self::Left\n        }\n    }\n}\n\nimpl GetProofResult {\n    pub fn verify(\n        \u0026self,\n        global_root: Felt,\n        contract_address: Address,\n        key: StorageKey,\n        value: Felt,\n    ) -\u003e Result\u003c(), jsonrpc::Error\u003e {\n        let contract_data = self.contract_data.as_ref().ok_or(\n            jsonrpc::Error::new(-32700, \"No contract data found\".to_string()),\n        )?;\n        self.verify_storage_proofs(contract_data, key, value)?;\n        self.verify_contract_proof(contract_data, global_root, contract_address)\n    }\n\n    fn verify_storage_proofs(\n        \u0026self,\n        contract_data: \u0026ContractData,\n        key: StorageKey,\n        value: Felt,\n    ) -\u003e Result\u003c(), jsonrpc::Error\u003e {\n        let root = \u0026contract_data.root;\n        let storage_proofs = \u0026contract_data.storage_proofs.as_ref().ok_or(\n            jsonrpc::Error::new(-32700, \"No storage proof found\".to_string()),\n        )?[0];\n\n        match Self::parse_proof(key.as_ref(), value, storage_proofs)? {\n            Some(computed_root) if computed_root.as_ref() == root.as_ref() =\u003e {\n                Ok(())\n            }\n            Some(computed_root)  =\u003e {\n                Err(jsonrpc::Error::new(\n                    -32700,\n                    format!(\n                        \"Proof invalid:\\nprovided-root -\u003e {}\\ncomputed-root -\u003e {}\\n\",\n                        root.as_ref(), computed_root.as_ref()\n                    ),\n                ))\n            },\n            None =\u003e Err(jsonrpc::Error::new(\n                -32700,\n                format!(\"Proof invalid for root -\u003e {}\\n\", root.as_ref()),\n            )),\n        }\n    }\n\n    fn verify_contract_proof(\n        \u0026self,\n        contract_data: \u0026ContractData,\n        global_root: Felt,\n        contract_address: Address,\n    ) -\u003e Result\u003c(), jsonrpc::Error\u003e {\n        let state_hash = Self::calculate_contract_state_hash(contract_data)?;\n\n        match Self::parse_proof(\n            contract_address.0.as_ref(),\n            state_hash,\n            \u0026self.contract_proof,\n        )? {\n            Some(storage_commitment) =\u003e {\n                let class_commitment = self.class_commitment.as_ref().ok_or(\n                    jsonrpc::Error::new(\n                        -32700,\n                        \"No class commitment\".to_string(),\n                    ),\n                )?;\n                let parsed_global_root = Self::calculate_global_root(\n                    class_commitment,\n                    storage_commitment,\n                )\n                .map_err(|_| {\n                    jsonrpc::Error::new(\n                        -32700,\n                        \"Failed to calculate global root\".to_string(),\n                    )\n                })?;\n                let state_commitment = self.state_commitment.as_ref().ok_or(\n                    jsonrpc::Error::new(\n                        -32700,\n                        \"No state commitment\".to_string(),\n                    ),\n                )?;\n                if state_commitment.as_ref() == parsed_global_root.as_ref()\n                    \u0026\u0026 global_root.as_ref() == parsed_global_root.as_ref()\n                {\n                    Ok(())\n                } else {\n                    Err(jsonrpc::Error::new(\n                        -32700,\n                        format!(\"Proof invalid:\\nstate commitment -\u003e {}\\nparsed global root -\u003e {}\\n global root -\u003e {}\", \n                        state_commitment.as_ref(), parsed_global_root.as_ref(), global_root.as_ref())\n                    ))\n                }\n            }\n            None =\u003e Err(jsonrpc::Error::new(\n                -32700,\n                format!(\n                    \"Could not parse global root for root: {}\",\n                    global_root.as_ref()\n                ),\n            )),\n        }\n    }\n\n    fn calculate_contract_state_hash(\n        contract_data: \u0026ContractData,\n    ) -\u003e Result\u003cFelt, jsonrpc::Error\u003e {\n        // The contract state hash is defined as H(H(H(hash, root), nonce), CONTRACT_STATE_HASH_VERSION)\n        const CONTRACT_STATE_HASH_VERSION: FieldElement = FieldElement::ZERO;\n        let hash = pedersen_hash(\n            \u0026FieldElement::from_hex(contract_data.class_hash.as_ref())\n                .map_err(|_| {\n                    jsonrpc::Error::new(\n                        -32701,\n                        \"Failed to create Field Element\".to_string(),\n                    )\n                })?,\n            \u0026FieldElement::from_hex(contract_data.root.as_ref()).map_err(\n                |_| {\n                    jsonrpc::Error::new(\n                        -32701,\n                        \"Failed to create Field Element\".to_string(),\n                    )\n                },\n            )?,\n        );\n        let hash = pedersen_hash(\n            \u0026hash,\n            \u0026FieldElement::from_hex(contract_data.nonce.as_ref()).map_err(\n                |_| {\n                    jsonrpc::Error::new(\n                        -32701,\n                        \"Failed to create Field Element\".to_string(),\n                    )\n                },\n            )?,\n        );\n        let hash = pedersen_hash(\u0026hash, \u0026CONTRACT_STATE_HASH_VERSION);\n        Felt::try_new(\u0026format!(\"0x{:x}\", hash)).map_err(|_| {\n            jsonrpc::Error::new(\n                -32701,\n                \"Failed to create Field Element\".to_string(),\n            )\n        })\n    }\n\n    fn calculate_global_root(\n        class_commitment: \u0026Felt,\n        storage_commitment: Felt,\n    ) -\u003e Result\u003cFelt, jsonrpc::Error\u003e {\n        let global_state_ver =\n            FieldElement::from_bytes_be_slice(b\"STARKNET_STATE_V0\");\n        let hash = poseidon_hash_many(\u0026[\n            global_state_ver,\n            FieldElement::from_hex(storage_commitment.as_ref()).map_err(\n                |_| {\n                    jsonrpc::Error::new(\n                        -32701,\n                        \"Failed to create Field Element\".to_string(),\n                    )\n                },\n            )?,\n            FieldElement::from_hex(class_commitment.as_ref()).map_err(\n                |_| {\n                    jsonrpc::Error::new(\n                        -32701,\n                        \"Failed to create Field Element\".to_string(),\n                    )\n                },\n            )?,\n        ]);\n        Felt::try_new(\u0026format!(\"0x{:x}\", hash)).map_err(|_| {\n            jsonrpc::Error::new(\n                -32701,\n                \"Failed to create Field Element\".to_string(),\n            )\n        })\n    }\n\n    fn parse_proof(\n        key: impl Into\u003cString\u003e,\n        value: Felt,\n        proof: \u0026[Node],\n    ) -\u003e Result\u003cOption\u003cFelt\u003e, jsonrpc::Error\u003e {\n        let key = FieldElement::from_hex(\u0026key.into()).map_err(|_| {\n            jsonrpc::Error::new(\n                -32701,\n                \"Failed to create Field Element\".to_string(),\n            )\n        })?;\n        let key = felt_to_bits(\u0026key.to_bytes_be());\n        if key.len() != 251 {\n            return Ok(None);\n        }\n        let value = FieldElement::from_hex(value.as_ref()).map_err(|_| {\n            jsonrpc::Error::new(\n                -32701,\n                \"Failed to create Field Element\".to_string(),\n            )\n        })?;\n        // initialized to the value so if the last node\n        // in the proof is a binary node we can still verify\n        let (mut hold, mut path_len) = (value, 0);\n        // reverse the proof in order to hash from the leaf towards the root\n        for (i, node) in proof.iter().rev().enumerate() {\n            match node {\n                Node::EdgeNode(EdgeNode {\n                    edge: EdgeNodeEdge { child, path },\n                }) =\u003e {\n                    // calculate edge hash given by provider\n                    let child_felt = FieldElement::from_hex(child.as_ref())\n                        .map_err(|_| {\n                            jsonrpc::Error::new(\n                                -32701,\n                                \"Failed to create Field Element\".to_string(),\n                            )\n                        })?;\n                    let path_value = FieldElement::from_hex(\n                        path.value.as_ref(),\n                    )\n                    .map_err(|_| {\n                        jsonrpc::Error::new(\n                            -32701,\n                            \"Failed to create Field Element\".to_string(),\n                        )\n                    })?;\n                    let provided_hash = pedersen_hash(\u0026child_felt, \u0026path_value)\n                        + FieldElement::from(path.len as u64);\n                    if i == 0 {\n                        // mask storage key\n                        let computed_hash = match felt_from_bits(\n                            \u0026key,\n                            Some(251 - path.len as usize),\n                        ) {\n                            Ok(masked_key) =\u003e {\n                                pedersen_hash(\u0026value, \u0026masked_key)\n                                    + FieldElement::from(path.len as u64)\n                            }\n                            Err(_) =\u003e return Ok(None),\n                        };\n                        // verify computed hash against provided hash\n                        if provided_hash != computed_hash {\n                            return Ok(None);\n                        };\n                    }\n\n                    // walk up the remaining path\n                    path_len += path.len;\n                    hold = provided_hash;\n                }\n                Node::BinaryNode(BinaryNode {\n                    binary: BinaryNodeBinary { left, right },\n                }) =\u003e {\n                    path_len += 1;\n                    let left = FieldElement::from_hex(left.as_ref()).map_err(\n                        |_| {\n                            jsonrpc::Error::new(\n                                -32701,\n                                \"Failed to create Field Element\".to_string(),\n                            )\n                        },\n                    )?;\n                    let right = FieldElement::from_hex(right.as_ref())\n                        .map_err(|_| {\n                            jsonrpc::Error::new(\n                                -32701,\n                                \"Failed to create Field Element\".to_string(),\n                            )\n                        })?;\n                    // identify path direction for this node\n                    let expected_hash =\n                        match Direction::from(key[251 - path_len as usize]) {\n                            Direction::Left =\u003e pedersen_hash(\u0026hold, \u0026right),\n                            Direction::Right =\u003e pedersen_hash(\u0026left, \u0026hold),\n                        };\n\n                    hold = pedersen_hash(\u0026left, \u0026right);\n                    // verify calculated hash vs provided hash for the node\n                    if hold != expected_hash {\n                        return Ok(None);\n                    };\n                }\n            };\n        }\n\n        Ok(Some(Felt::try_new(\u0026format!(\"0x{:x}\", hold))?))\n    }\n}\n#[cfg(test)]\nmod tests {\n    use crate::gen::{\n        Address, ContractData, Felt, GetProofResult, Node, StorageKey,\n    };\n\n    #[test]\n    fn valid_one_level_parse_proof() {\n        let key = \"0x0341c1bdfd89f69748aa00b5742b03adbffd79b8e80cab5c50d91cd8c2a79be1\".to_string();\n        let value =\n            Felt::try_new(\"0x47616d65206f66204c69666520546f6b656e\").unwrap();\n        let edge_node_string = r#\"[{\n            \"edge\": {\n                \"child\": \"0x47616d65206f66204c69666520546f6b656e\",\n                \"path\": {\n                    \"len\": 231,\n                    \"value\": \"0x3dfd89f69748aa00b5742b03adbffd79b8e80cab5c50d91cd8c2a79be1\"\n                }\n            }\n        }]\"#;\n        let proof: Vec\u003cNode\u003e = serde_json::from_str(edge_node_string).unwrap();\n        let ret_val = GetProofResult::parse_proof(key, value, \u0026proof).unwrap();\n\n        assert!(ret_val.is_some());\n        let ret_val = ret_val.unwrap();\n        assert_eq!(\n            ret_val.as_ref(),\n            \"0x1e224db31dfb3e1b8c95670a12f1903d4a32ac7bb83f4b209029e14155bbca9\"\n        );\n    }\n\n    #[test]\n    fn valid_five_level_parse_proof() {\n        let key = \"0x0341c1bdfd89f69748aa00b5742b03adbffd79b8e80cab5c50d91cd8c2a79be1\".to_string();\n        let value =\n            Felt::try_new(\"0x47616d65206f66204c69666520546f6b656e\").unwrap();\n        let proof_string = r#\"[\n        {\n            \"binary\": {\n                \"left\": \"0x46e82293b0564764a071f1aa4488aa7577b1b5bb2e898321f8536d5593d371d\",\n                \"right\": \"0x58adcf6ea8b96992aa316e2f092f2480ca406c3630fe97573046a32900745b5\"\n            }\n        },\n        {\n            \"binary\": {\n                \"left\": \"0x716e211c75f4c0e14dbe46c361812b0129abd061b63faf91ad5569bf22b785c\",\n                \"right\": \"0x3729d9699d4410223e413f3b3aa91a043d94242f888188036e6ea25b6962041\"\n            }\n        },\n        {\n            \"edge\": {\n                \"child\": \"0x6281e42b5941ae1a77ea03836aad1190097f72e1a1ed534fae2e00b4118f504\",\n                \"path\": {\n                    \"len\": 1,\n                    \"value\": \"0x1\"\n                }\n            }\n        },\n        {\n            \"binary\": {\n                \"left\": \"0x3e3800516f62800ef6491b1cb1915b3353026ea6a6afcf35e8d4c54e35b04ea\",\n                \"right\": \"0x1e224db31dfb3e1b8c95670a12f1903d4a32ac7bb83f4b209029e14155bbca9\"\n            }\n        },\n        {\n            \"edge\": {\n                \"child\": \"0x47616d65206f66204c69666520546f6b656e\",\n                \"path\": {\n                    \"len\": 231,\n                    \"value\": \"0x3dfd89f69748aa00b5742b03adbffd79b8e80cab5c50d91cd8c2a79be1\"\n                }\n            }\n        }]\"#;\n        let proof: Vec\u003cNode\u003e = serde_json::from_str(proof_string).unwrap();\n        let ret_val = GetProofResult::parse_proof(key, value, \u0026proof).unwrap();\n\n        assert!(ret_val.is_some());\n        let ret_val = ret_val.unwrap();\n        assert_eq!(\n            ret_val.as_ref(),\n            \"0x6cc50a732b4256f7b642348e19bd1a8bee7ac76bed3fcee3bc34309538c00c6\"\n        );\n    }\n\n    #[test]\n    fn invalid_one_level_parse_proof() {\n        let key = \"0xabc\".to_string();\n        let value = Felt::try_new(\"0xdef\").unwrap();\n        let proof: Vec\u003cNode\u003e = serde_json::from_str(\n            r#\"[{\n            \"edge\": {\n                \"child\": \"0xfaa\",\n                \"path\": {\n                    \"len\": 1,\n                    \"value\": \"0xbad\"\n                }\n            }\n        }]\"#,\n        )\n        .unwrap();\n        assert!(GetProofResult::parse_proof(key, value, \u0026proof)\n            .unwrap()\n            .is_none());\n    }\n\n    #[test]\n    fn invalid_one_level_proof_last_key_byte_2_instead_of_1() {\n        let key = \"0x0341c1bdfd89f69748aa00b5742b03adbffd79b8e80cab5c50d91cd8c2a79be2\".to_string();\n        let value =\n            Felt::try_new(\"0x47616d65206f66204c69666520546f6b656e\").unwrap();\n        let edge_node_string = r#\"[{\n            \"edge\": {\n                \"child\": \"0x47616d65206f66204c69666520546f6b656e\",\n                \"path\": {\n                    \"len\": 231,\n                    \"value\": \"0x3dfd89f69748aa00b5742b03adbffd79b8e80cab5c50d91cd8c2a79be1\"\n                }\n            }\n        }]\"#;\n        let proof: Vec\u003cNode\u003e = serde_json::from_str(edge_node_string).unwrap();\n        assert!(GetProofResult::parse_proof(key, value, \u0026proof)\n            .unwrap()\n            .is_none());\n    }\n\n    #[test]\n    fn invalid_five_level_proof_len_7_instead_of_1() {\n        let key = \"0x0341c1bdfd89f69748aa00b5742b03adbffd79b8e80cab5c50d91cd8c2a79be1\".to_string();\n        let value =\n            Felt::try_new(\"0x47616d65206f66204c69666520546f6b656e\").unwrap();\n        let proof_string = r#\"[\n        {\n            \"binary\": {\n                \"left\": \"0x46e82293b0564764a071f1aa4488aa7577b1b5bb2e898321f8536d5593d371d\",\n                \"right\": \"0x58adcf6ea8b96992aa316e2f092f2480ca406c3630fe97573046a32900745b5\"\n            }\n        },\n        {\n            \"binary\": {\n                \"left\": \"0x716e211c75f4c0e14dbe46c361812b0129abd061b63faf91ad5569bf22b785c\",\n                \"right\": \"0x3729d9699d4410223e413f3b3aa91a043d94242f888188036e6ea25b6962041\"\n            }\n        },\n        {\n            \"edge\": {\n                \"child\": \"0x6281e42b5941ae1a77ea03836aad1190097f72e1a1ed534fae2e00b4118f504\",\n                \"path\": {\n                    \"len\": 7,\n                    \"value\": \"0x1\"\n                }\n            }\n        },\n        {\n            \"binary\": {\n                \"left\": \"0x3e3800516f62800ef6491b1cb1915b3353026ea6a6afcf35e8d4c54e35b04ea\",\n                \"right\": \"0x1e224db31dfb3e1b8c95670a12f1903d4a32ac7bb83f4b209029e14155bbca9\"\n            }\n        },\n        {\n            \"edge\": {\n                \"child\": \"0x47616d65206f66204c69666520546f6b656e\",\n                \"path\": {\n                    \"len\": 231,\n                    \"value\": \"0x3dfd89f69748aa00b5742b03adbffd79b8e80cab5c50d91cd8c2a79be1\"\n                }\n            }\n        }]\"#;\n        let proof: Vec\u003cNode\u003e = serde_json::from_str(proof_string).unwrap();\n        assert!(GetProofResult::parse_proof(key, value, \u0026proof)\n            .unwrap()\n            .is_none());\n    }\n\n    #[test]\n    fn valid_one_level_verify_storage_proof() {\n        let key = StorageKey::try_new(\n            \"0x0341c1bdfd89f69748aa00b5742b03adbffd79b8e80cab5c50d91cd8c2a79be1\",\n        ).unwrap();\n        let value =\n            Felt::try_new(\"0x47616d65206f66204c69666520546f6b656e\").unwrap();\n        let edge_node_string = r#\"[{\n            \"edge\": {\n                \"child\": \"0x47616d65206f66204c69666520546f6b656e\",\n                \"path\": {\n                    \"len\": 231,\n                    \"value\": \"0x3dfd89f69748aa00b5742b03adbffd79b8e80cab5c50d91cd8c2a79be1\"\n                }\n            }\n        }]\"#;\n\n        let storage_proof = GetProofResult {\n            contract_data: Some(ContractData {\n                root: Felt::try_new(\n                    \"0x1e224db31dfb3e1b8c95670a12f1903d4a32ac7bb83f4b209029e14155bbca9\",\n                )\n                .unwrap(),\n                storage_proofs: Some(vec![serde_json::from_str(edge_node_string).unwrap()]),\n                class_hash: Felt::try_new(\"0x0\").unwrap(),\n                contract_state_hash_version: Felt::try_new(\"0x0\").unwrap(),\n                nonce: Felt::try_new(\"0x0\").unwrap(),\n            }),\n            class_commitment: Some(Felt::try_new(\"0x0\").unwrap()),\n            contract_proof: vec![],\n            state_commitment: Some(Felt::try_new(\"0x0\").unwrap())\n        };\n        let contract_data = storage_proof.contract_data.as_ref().unwrap();\n\n        assert!(storage_proof\n            .verify_storage_proofs(contract_data, key, value)\n            .is_ok());\n    }\n\n    #[test]\n    fn invalid_one_level_verify_storage_proof() {\n        let key = StorageKey::try_new(\"0x0341c1bdfd89f69748aa00b5742b03adbffd79b8e80cab5c50d91cd8c2a79be1\").unwrap();\n        let value = Felt::try_new(\"0xdef\").unwrap();\n        let edge_node_string = r#\"[{\n            \"edge\": {\n                \"child\": \"0xbad\",\n                \"path\": {\n                    \"len\": 231,\n                    \"value\": \"0xfaa\"\n                }\n            }\n        }]\"#;\n\n        let storage_proof = GetProofResult {\n            contract_data: Some(ContractData {\n                root: Felt::try_new(\"0x42\").unwrap(),\n                storage_proofs: Some(vec![serde_json::from_str(\n                    edge_node_string,\n                )\n                .unwrap()]),\n                class_hash: Felt::try_new(\"0x0\").unwrap(),\n                contract_state_hash_version: Felt::try_new(\"0x0\").unwrap(),\n                nonce: Felt::try_new(\"0x0\").unwrap(),\n            }),\n            class_commitment: Some(Felt::try_new(\"0x0\").unwrap()),\n            contract_proof: vec![],\n            state_commitment: Some(Felt::try_new(\"0x0\").unwrap()),\n        };\n        let contract_data = storage_proof.contract_data.as_ref().unwrap();\n\n        assert!(storage_proof\n            .verify_storage_proofs(contract_data, key, value)\n            .is_err());\n    }\n\n    #[test]\n    fn contract_state_hash_is_valid() {\n        let contract_data = ContractData {\n            class_hash: Felt::try_new(\"0x123\").unwrap(),\n            root: Felt::try_new(\"0xabc\").unwrap(),\n            nonce: Felt::try_new(\"0xdef\").unwrap(),\n            contract_state_hash_version: Felt::try_new(\"0x0\").unwrap(),\n            storage_proofs: Some(vec![vec![]]),\n        };\n\n        let expected =\n            \"0x30a3c317f49a18c65bb5d22c87172f3f60101d54425457a66237474dd2d66db\";\n        assert_eq!(\n            GetProofResult::calculate_contract_state_hash(\u0026contract_data)\n                .unwrap()\n                .as_ref(),\n            Felt::try_new(expected).unwrap().as_ref()\n        );\n    }\n\n    #[test]\n    fn calculate_global_root_is_valid() {\n        let expected =\n            \"0x42e26eb87a82c4b4130cb6bfbd33be7788436aa66f787ede4aef9456b58939\";\n        assert_eq!(\n            GetProofResult::calculate_global_root(\n                \u0026Felt::try_new(\"0xabc\").unwrap(),\n                Felt::try_new(\"0xdef\").unwrap()\n            )\n            .unwrap()\n            .as_ref(),\n            Felt::try_new(expected).unwrap().as_ref()\n        );\n    }\n\n    #[test]\n    fn valid_verify_contract_proof() {\n        let edge_node_string = r#\"[{\n            \"edge\": {\n                \"child\": \"0x538a7653ef22e217f93066ac54784c0159a5e1e37d808f83c82d1b42d57457d\",\n                \"path\": {\n                    \"len\": 229,\n                    \"value\": \"0x4a03bb9e744479e3298f54705a35966ab04140d3d8dd797c1f6dc49d0\"\n                }\n            }\n        }]\"#;\n        let storage_proof = GetProofResult {\n            contract_proof: serde_json::from_str(edge_node_string).unwrap(),\n            state_commitment: Some(\n                Felt::try_new(\"0x1e2a7a7ee40c1d897c8c0a9515720ea02c8075ee9e00db277f5f8c3e4edcb54\")\n                    .unwrap(),\n            ),\n            contract_data: Some(ContractData {\n                class_hash: Felt::try_new(\n                    \"0x4e635d495504b31ec191cbfc3d99b5d109bfcae4d0d9e16f4909a43b2e24c07\",\n                )\n                .unwrap(),\n                root: Felt::try_new(\n                    \"0x5826149cbab3f8538d346301869ba2742a159d1542463ce19a60a927b826a2f\",\n                )\n                .unwrap(),\n                nonce: Felt::try_new(\"0x0\").unwrap(),\n                contract_state_hash_version: Felt::try_new(\"0x0\").unwrap(),\n                storage_proofs: Some(vec![vec![]])\n            }),\n            class_commitment: Some(Felt::try_new(\"0x0\").unwrap()),\n        };\n\n        let global_root = Felt::try_new(\n            \"0x1e2a7a7ee40c1d897c8c0a9515720ea02c8075ee9e00db277f5f8c3e4edcb54\",\n        )\n        .unwrap();\n        let contract_address = Address(Felt::try_new(\"0x6a05844a03bb9e744479e3298f54705a35966ab04140d3d8dd797c1f6dc49d0\")\n                .unwrap());\n        let contract_data = storage_proof.contract_data.as_ref().unwrap();\n        assert!(storage_proof\n            .verify_contract_proof(contract_data, global_root, contract_address)\n            .is_ok());\n    }\n\n    #[test]\n    fn invalid_verify_contract_proof() {\n        let invalid_storage_proof = GetProofResult {\n            state_commitment: Some(Felt::try_new(\"0x0\").unwrap()),\n            class_commitment: Some(Felt::try_new(\"0x0\").unwrap()),\n            contract_data: Some(ContractData {\n                class_hash: Felt::try_new(\"0x0\").unwrap(),\n                contract_state_hash_version: Felt::try_new(\"0x0\").unwrap(),\n                nonce: Felt::try_new(\"0x0\").unwrap(),\n                root: Felt::try_new(\"0x0\").unwrap(),\n                storage_proofs: Some(vec![vec![]]),\n            }),\n            contract_proof: vec![],\n        };\n        let global_root = Felt::try_new(\"0x0\").unwrap();\n        let contract_address = Address(Felt::try_new(\"0x0\").unwrap());\n        let contract_data =\n            invalid_storage_proof.contract_data.as_ref().unwrap();\n        assert!(invalid_storage_proof\n            .verify_contract_proof(contract_data, global_root, contract_address)\n            .is_err());\n    }\n}\n","traces":[{"line":20,"address":[12601296],"length":1,"stats":{"Line":3}},{"line":21,"address":[12601317,12601308],"length":1,"stats":{"Line":6}},{"line":22,"address":[12601319],"length":1,"stats":{"Line":3}},{"line":24,"address":[12601312],"length":1,"stats":{"Line":3}},{"line":30,"address":[10351274,10351233,10350256],"length":1,"stats":{"Line":2}},{"line":37,"address":[10350505,10351030,10350314,10350738],"length":1,"stats":{"Line":4}},{"line":38,"address":[10350439],"length":1,"stats":{"Line":2}},{"line":40,"address":[10350943,10350614,10351016,10350767],"length":1,"stats":{"Line":4}},{"line":41,"address":[10351001,10350853],"length":1,"stats":{"Line":4}},{"line":44,"address":[10353461,10353646,10351312],"length":1,"stats":{"Line":4}},{"line":50,"address":[10351368],"length":1,"stats":{"Line":3}},{"line":51,"address":[10351553,10351420,10351722,10353561],"length":1,"stats":{"Line":8}},{"line":52,"address":[10351484],"length":1,"stats":{"Line":4}},{"line":53,"address":[10351658,10351761],"length":1,"stats":{"Line":8}},{"line":55,"address":[10353539,10351769],"length":1,"stats":{"Line":4}},{"line":56,"address":[10352252,10352853,10352709],"length":1,"stats":{"Line":9}},{"line":57,"address":[10352903],"length":1,"stats":{"Line":3}},{"line":59,"address":[10352792],"length":1,"stats":{"Line":0}},{"line":60,"address":[10353377],"length":1,"stats":{"Line":0}},{"line":62,"address":[10353240],"length":1,"stats":{"Line":0}},{"line":64,"address":[10353095,10352832,10352977],"length":1,"stats":{"Line":0}},{"line":68,"address":[10352589],"length":1,"stats":{"Line":1}},{"line":70,"address":[10352468,10352228,10352350],"length":1,"stats":{"Line":3}},{"line":75,"address":[10353664,10356898,10357072],"length":1,"stats":{"Line":4}},{"line":81,"address":[10353995,10353829,10353746],"length":1,"stats":{"Line":8}},{"line":83,"address":[10354269,10354456,10354230],"length":1,"stats":{"Line":7}},{"line":84,"address":[10353971],"length":1,"stats":{"Line":4}},{"line":85,"address":[10354105],"length":1,"stats":{"Line":4}},{"line":86,"address":[10354153],"length":1,"stats":{"Line":4}},{"line":88,"address":[10354517],"length":1,"stats":{"Line":3}},{"line":89,"address":[10354557,10356909,10355050,10355258],"length":1,"stats":{"Line":6}},{"line":90,"address":[10355011],"length":1,"stats":{"Line":3}},{"line":92,"address":[10354984],"length":1,"stats":{"Line":3}},{"line":97,"address":[10355155],"length":1,"stats":{"Line":3}},{"line":99,"address":[10535136,10535257],"length":1,"stats":{"Line":0}},{"line":100,"address":[10535214],"length":1,"stats":{"Line":0}},{"line":102,"address":[10535154],"length":1,"stats":{"Line":0}},{"line":105,"address":[10355816,10355448,10355650],"length":1,"stats":{"Line":6}},{"line":106,"address":[10355611],"length":1,"stats":{"Line":3}},{"line":108,"address":[10355584],"length":1,"stats":{"Line":3}},{"line":111,"address":[10356099,10355760,10355850],"length":1,"stats":{"Line":9}},{"line":112,"address":[10355968],"length":1,"stats":{"Line":3}},{"line":114,"address":[10356086],"length":1,"stats":{"Line":3}},{"line":116,"address":[10356672],"length":1,"stats":{"Line":1}},{"line":118,"address":[10356519],"length":1,"stats":{"Line":1}},{"line":119,"address":[10355941,10356382,10356109,10356227],"length":1,"stats":{"Line":4}},{"line":123,"address":[10354824],"length":1,"stats":{"Line":0}},{"line":125,"address":[10354703],"length":1,"stats":{"Line":0}},{"line":127,"address":[10354585,10354493],"length":1,"stats":{"Line":0}},{"line":133,"address":[10358428,10357088],"length":1,"stats":{"Line":3}},{"line":139,"address":[10357126,10357507],"length":1,"stats":{"Line":5}},{"line":140,"address":[10535280],"length":1,"stats":{"Line":0}},{"line":141,"address":[10535321],"length":1,"stats":{"Line":0}},{"line":143,"address":[10535294],"length":1,"stats":{"Line":0}},{"line":146,"address":[10357533,10357854,10357343],"length":1,"stats":{"Line":10}},{"line":147,"address":[10535360],"length":1,"stats":{"Line":0}},{"line":148,"address":[10535401],"length":1,"stats":{"Line":0}},{"line":150,"address":[10535374],"length":1,"stats":{"Line":0}},{"line":157,"address":[10357880,10358284,10357690],"length":1,"stats":{"Line":10}},{"line":158,"address":[10535440],"length":1,"stats":{"Line":0}},{"line":159,"address":[10535481],"length":1,"stats":{"Line":0}},{"line":161,"address":[10535454],"length":1,"stats":{"Line":0}},{"line":166,"address":[10357994],"length":1,"stats":{"Line":5}},{"line":167,"address":[10358195,10358358,10358084],"length":1,"stats":{"Line":15}},{"line":168,"address":[10535598],"length":1,"stats":{"Line":0}},{"line":170,"address":[10535538],"length":1,"stats":{"Line":0}},{"line":175,"address":[10359553,10359579,10358464],"length":1,"stats":{"Line":3}},{"line":179,"address":[10358499],"length":1,"stats":{"Line":3}},{"line":181,"address":[10358976],"length":1,"stats":{"Line":3}},{"line":183,"address":[10358795,10359577,10358573],"length":1,"stats":{"Line":3}},{"line":184,"address":[10535664],"length":1,"stats":{"Line":0}},{"line":185,"address":[10535705],"length":1,"stats":{"Line":0}},{"line":187,"address":[10535678],"length":1,"stats":{"Line":0}},{"line":191,"address":[10358742,10358829,10359130,10359562],"length":1,"stats":{"Line":6}},{"line":192,"address":[10535744],"length":1,"stats":{"Line":0}},{"line":193,"address":[10535785],"length":1,"stats":{"Line":0}},{"line":195,"address":[10535758],"length":1,"stats":{"Line":0}},{"line":200,"address":[10359269,10359398,10359467],"length":1,"stats":{"Line":9}},{"line":201,"address":[10535902],"length":1,"stats":{"Line":0}},{"line":203,"address":[10535842],"length":1,"stats":{"Line":0}},{"line":208,"address":[9059558,9062196,9057280],"length":1,"stats":{"Line":9}},{"line":213,"address":[9057716,9057429,9057509,9057351],"length":1,"stats":{"Line":19}},{"line":214,"address":[10536009],"length":1,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[10535982],"length":1,"stats":{"Line":0}},{"line":219,"address":[9057745],"length":1,"stats":{"Line":5}},{"line":220,"address":[9057799,9057878],"length":1,"stats":{"Line":13}},{"line":221,"address":[9057921],"length":1,"stats":{"Line":0}},{"line":223,"address":[9058001,9058399,9057894,9062169],"length":1,"stats":{"Line":15}},{"line":224,"address":[10536089],"length":1,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[10536062],"length":1,"stats":{"Line":0}},{"line":231,"address":[9058208],"length":1,"stats":{"Line":10}},{"line":233,"address":[9058444,9058332,9058789],"length":1,"stats":{"Line":23}},{"line":234,"address":[9058837],"length":1,"stats":{"Line":9}},{"line":235,"address":[9059656],"length":1,"stats":{"Line":6}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[9060824,9061063,9062164,9059687],"length":1,"stats":{"Line":15}},{"line":240,"address":[10536128],"length":1,"stats":{"Line":0}},{"line":241,"address":[10536169],"length":1,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[10536142],"length":1,"stats":{"Line":0}},{"line":247,"address":[9061097,9061007],"length":1,"stats":{"Line":15}},{"line":249,"address":[10536208],"length":1,"stats":{"Line":0}},{"line":250,"address":[10536249],"length":1,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[10536222],"length":1,"stats":{"Line":0}},{"line":255,"address":[9061407,9061272],"length":1,"stats":{"Line":17}},{"line":256,"address":[9061384],"length":1,"stats":{"Line":5}},{"line":257,"address":[9061450],"length":1,"stats":{"Line":6}},{"line":259,"address":[9061594,9061650],"length":1,"stats":{"Line":14}},{"line":260,"address":[9061456],"length":1,"stats":{"Line":9}},{"line":261,"address":[9061629,9061532],"length":1,"stats":{"Line":6}},{"line":263,"address":[9061661],"length":1,"stats":{"Line":7}},{"line":264,"address":[9061693,9061878],"length":1,"stats":{"Line":10}},{"line":265,"address":[9061855],"length":1,"stats":{"Line":7}},{"line":267,"address":[9061746],"length":1,"stats":{"Line":0}},{"line":270,"address":[9061932],"length":1,"stats":{"Line":8}},{"line":271,"address":[9061984],"length":1,"stats":{"Line":3}},{"line":276,"address":[9062061,9062138,9061493],"length":1,"stats":{"Line":11}},{"line":277,"address":[9062069],"length":1,"stats":{"Line":5}},{"line":279,"address":[9059575],"length":1,"stats":{"Line":4}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[9059622,9059752,9059725],"length":1,"stats":{"Line":6}},{"line":283,"address":[9059733,9060034,9059780,9060814],"length":1,"stats":{"Line":6}},{"line":284,"address":[10536288],"length":1,"stats":{"Line":0}},{"line":285,"address":[10536329],"length":1,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[10536302],"length":1,"stats":{"Line":0}},{"line":291,"address":[9060387,9060071,9059975,9060812],"length":1,"stats":{"Line":6}},{"line":292,"address":[10536368],"length":1,"stats":{"Line":0}},{"line":293,"address":[10536409],"length":1,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[10536382],"length":1,"stats":{"Line":0}},{"line":299,"address":[9060421,9060314],"length":1,"stats":{"Line":6}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[9060600,9060530],"length":1,"stats":{"Line":6}},{"line":302,"address":[9060637,9060565],"length":1,"stats":{"Line":6}},{"line":305,"address":[9060602,9060639],"length":1,"stats":{"Line":6}},{"line":307,"address":[9060671],"length":1,"stats":{"Line":3}},{"line":308,"address":[9060723],"length":1,"stats":{"Line":1}},{"line":314,"address":[9058876,9059088,9059309,9059005],"length":1,"stats":{"Line":12}}],"covered":86,"coverable":144},{"path":["/","home","work","Work","Eiger","code","beerus","src","rpc.rs"],"content":"use axum::{\n    extract::State, response::IntoResponse, routing::post, Json, Router,\n};\nuse iamgroot::jsonrpc;\nuse serde::{Deserialize, Serialize};\nuse std::sync::Arc;\nuse tokio::{\n    net::{TcpListener, ToSocketAddrs},\n    sync::{oneshot, RwLock},\n    task::JoinHandle,\n};\n\nuse crate::client::{Http, State as ClientState};\n\nuse crate::exe::err::Error;\n\nuse super::gen::*;\nuse gen::GetBlockWithTxHashesResult;\n\npub struct Server(oneshot::Sender\u003c()\u003e, JoinHandle\u003c()\u003e, u16);\n\nimpl Server {\n    /// Send signal for terminating the server and await until it is terminated\n    pub async fn stop(self) {\n        let _ = self.0.send(());\n        let _ = self.1.await;\n    }\n\n    /// Wait until the server is terminated (without initiating the termination)\n    pub async fn done(self) {\n        let _ = self.1.await;\n    }\n\n    /// Return server's listening port (convenience method for testing)\n    pub fn port(\u0026self) -\u003e u16 {\n        self.2\n    }\n}\n\npub async fn serve\u003cA: ToSocketAddrs\u003e(\n    url: \u0026str,\n    addr: A,\n    state: Arc\u003cRwLock\u003cClientState\u003e\u003e,\n) -\u003e Result\u003cServer, Error\u003e {\n    let listener = TcpListener::bind(addr).await?;\n    let server = serve_on(url, listener, state)?;\n    Ok(server)\n}\n\nfn serve_on(\n    url: \u0026str,\n    listener: TcpListener,\n    state: Arc\u003cRwLock\u003cClientState\u003e\u003e,\n) -\u003e Result\u003cServer, Error\u003e {\n    const DEFAULT_TIMEOUT: std::time::Duration =\n        std::time::Duration::from_secs(30);\n    let client = reqwest::ClientBuilder::new()\n        .connect_timeout(DEFAULT_TIMEOUT)\n        .timeout(DEFAULT_TIMEOUT)\n        .build()?;\n\n    let ctx = Context {\n        url: url.to_owned(),\n        client: Arc::new(gen::client::Client::new(url, Http(client))),\n        state,\n    };\n\n    let app = Router::new().route(\"/rpc\", post(handle_request)).with_state(ctx);\n\n    let (tx, rx) = oneshot::channel::\u003c()\u003e();\n    let port = listener.local_addr()?.port();\n    let jh = tokio::spawn(async move {\n        let ret = axum::serve(listener, app.into_make_service())\n            .with_graceful_shutdown(async move {\n                let _ = rx.await;\n            })\n            .await;\n        if let Err(e) = ret {\n            tracing::error!(\"server shut down with error: {e:?}\");\n        }\n    });\n\n    Ok(Server(tx, jh, port))\n}\n\n#[derive(Deserialize, Serialize)]\n#[serde(untagged)]\nenum Request {\n    Single(jsonrpc::Request),\n    Batch(Vec\u003cjsonrpc::Request\u003e),\n}\n\n#[derive(Default, Deserialize, Serialize)]\n#[serde(untagged)]\nenum Response {\n    #[default]\n    Empty,\n    Single(jsonrpc::Response),\n    Batch(Vec\u003cjsonrpc::Response\u003e),\n}\n\nstruct RpcError(jsonrpc::Error);\n\nimpl IntoResponse for RpcError {\n    fn into_response(self) -\u003e axum::response::Response {\n        let code = axum::http::StatusCode::INTERNAL_SERVER_ERROR;\n        (code, self.0.message).into_response()\n    }\n}\n\n#[derive(Clone)]\nstruct Context {\n    url: String,\n    client: Arc\u003cgen::client::Client\u003cHttp\u003e\u003e,\n    state: Arc\u003cRwLock\u003cClientState\u003e\u003e,\n}\n\nimpl Context {\n    async fn get_state(\n        \u0026self,\n        block_id: BlockId,\n    ) -\u003e std::result::Result\u003cClientState, jsonrpc::Error\u003e {\n        let block = self.getBlockWithTxHashes(block_id).await?;\n        let gen::GetBlockWithTxHashesResult::BlockWithTxHashes(block) = block\n        else {\n            return Err(jsonrpc::Error {\n                code: -1,\n                message: \"Pending block received\".to_owned(),\n            });\n        };\n        Ok(ClientState {\n            block_number: *block.block_header.block_number.as_ref() as u64,\n            block_hash: block.block_header.block_hash.0,\n            root: block.block_header.new_root,\n        })\n    }\n\n    async fn resolve_block_id(\n        \u0026self,\n        block_id: BlockId,\n    ) -\u003e std::result::Result\u003c(BlockId, Felt), jsonrpc::Error\u003e {\n        let state = \u0026self.state.read().await;\n        match block_id {\n            gen::BlockId::BlockNumber { block_number } =\u003e {\n                self.resolve_block_by_number(block_number, state).await\n            }\n            gen::BlockId::BlockHash { block_hash } =\u003e {\n                self.resolve_block_by_hash(block_hash, state).await\n            }\n            gen::BlockId::BlockTag(BlockTag::Latest) =\u003e {\n                let block_number =\n                    BlockNumber::try_new(state.block_number as i64)?;\n                Ok((BlockId::BlockNumber { block_number }, state.root.clone()))\n            }\n            gen::BlockId::BlockTag(BlockTag::Pending) =\u003e Err(jsonrpc::Error {\n                code: -1,\n                message: \"Pending block is not supported\".to_owned(),\n            }),\n        }\n    }\n\n    async fn resolve_block_by_number(\n        \u0026self,\n        block_number: BlockNumber,\n        current_state: \u0026ClientState,\n    ) -\u003e Result\u003c(BlockId, Felt), jsonrpc::Error\u003e {\n        let req_block_number = *block_number.as_ref() as u64;\n        if req_block_number \u003e= current_state.block_number {\n            return Ok((\n                BlockId::BlockNumber {\n                    block_number: BlockNumber::try_new(\n                        current_state.block_number as i64,\n                    )?,\n                },\n                current_state.root.clone(),\n            ));\n        }\n        let state = self\n            .get_state(BlockId::BlockNumber {\n                block_number: block_number.clone(),\n            })\n            .await?;\n        if state.block_number != req_block_number {\n            return Err(jsonrpc::Error {\n                code: -1,\n                message: \"Failed to verify requested block by number\"\n                    .to_string(),\n            });\n        }\n        Ok((BlockId::BlockNumber { block_number }, state.root))\n    }\n\n    async fn resolve_block_by_hash(\n        \u0026self,\n        block_hash: BlockHash,\n        current_state: \u0026ClientState,\n    ) -\u003e Result\u003c(BlockId, Felt), jsonrpc::Error\u003e {\n        if block_hash.0.as_ref() == current_state.block_hash.as_ref() {\n            return Ok((\n                BlockId::BlockHash { block_hash },\n                current_state.root.clone(),\n            ));\n        }\n        let state = self\n            .get_state(BlockId::BlockHash { block_hash: block_hash.clone() })\n            .await?;\n        if block_hash.0.as_ref() != state.block_hash.as_ref()\n            || state.block_number \u003e= current_state.block_number\n        {\n            return Err(jsonrpc::Error {\n                code: -1,\n                message: \"Failed to verify requested block by hash\".to_string(),\n            });\n        }\n        Ok((BlockId::BlockHash { block_hash }, state.root))\n    }\n}\n\nasync fn handle_request(\n    State(ctx): State\u003cContext\u003e,\n    Json(req): Json\u003cRequest\u003e,\n) -\u003e Result\u003cimpl IntoResponse, RpcError\u003e {\n    match req {\n        Request::Single(req) =\u003e {\n            let res = gen::handle(\u0026ctx, \u0026req).await;\n            if req.id.is_some() {\n                Ok(Json(Response::Single(res)))\n            } else {\n                Ok(Json::default()) // no response for notifications\n            }\n        }\n        Request::Batch(reqs) =\u003e {\n            let mut ret = Vec::with_capacity(reqs.len());\n            for req in reqs {\n                let ctx = ctx.clone();\n                let res = gen::handle(\u0026ctx, \u0026req).await;\n                if req.id.is_some() {\n                    ret.push(res);\n                }\n            }\n            Ok(Json(Response::Batch(ret)))\n        }\n    }\n}\n\n#[async_trait::async_trait]\nimpl gen::Rpc for Context {\n    async fn addDeclareTransaction(\n        \u0026self,\n        declare_transaction: BroadcastedDeclareTxn,\n    ) -\u003e std::result::Result\u003cAddDeclareTransactionResult, jsonrpc::Error\u003e {\n        self.client.addDeclareTransaction(declare_transaction).await\n    }\n\n    async fn addDeployAccountTransaction(\n        \u0026self,\n        deploy_account_transaction: BroadcastedDeployAccountTxn,\n    ) -\u003e std::result::Result\u003cAddDeployAccountTransactionResult, jsonrpc::Error\u003e\n    {\n        self.client\n            .addDeployAccountTransaction(deploy_account_transaction)\n            .await\n    }\n\n    async fn addInvokeTransaction(\n        \u0026self,\n        invoke_transaction: BroadcastedInvokeTxn,\n    ) -\u003e std::result::Result\u003cAddInvokeTransactionResult, jsonrpc::Error\u003e {\n        self.client.addInvokeTransaction(invoke_transaction).await\n    }\n\n    async fn blockHashAndNumber(\n        \u0026self,\n    ) -\u003e std::result::Result\u003cBlockHashAndNumberResult, jsonrpc::Error\u003e {\n        self.client.blockHashAndNumber().await\n    }\n\n    async fn blockNumber(\n        \u0026self,\n    ) -\u003e std::result::Result\u003cBlockNumber, jsonrpc::Error\u003e {\n        self.client.blockNumber().await\n    }\n\n    async fn call(\n        \u0026self,\n        request: FunctionCall,\n        block_id: BlockId,\n    ) -\u003e std::result::Result\u003cVec\u003cFelt\u003e, jsonrpc::Error\u003e {\n        let client = gen::client::blocking::Client::new(\u0026self.url, Http::new());\n        let state = self.state.read().await.clone();\n\n        // TODO: address that effectively only the 'latest' block is supported\n        tracing::warn!(requested_block=?block_id, current_state=?state, \"call\");\n\n        let call_info = tokio::task::spawn_blocking(move || {\n            crate::exe::call(client.clone(), request, state)\n        })\n        .await\n        .map_err(|e| {\n            iamgroot::jsonrpc::Error::new(500, format!(\"join error: {e}\"))\n        })??;\n\n        let ret: Result\u003cVec\u003cFelt\u003e, Error\u003e = call_info\n            .execution\n            .retdata\n            .0\n            .into_iter()\n            .map(|e| e.try_into())\n            .collect();\n\n        Ok(ret?)\n    }\n\n    async fn chainId(\u0026self) -\u003e std::result::Result\u003cChainId, jsonrpc::Error\u003e {\n        self.client.chainId().await\n    }\n\n    async fn estimateFee(\n        \u0026self,\n        request: Vec\u003cBroadcastedTxn\u003e,\n        simulation_flags: Vec\u003cSimulationFlagForEstimateFee\u003e,\n        block_id: BlockId,\n    ) -\u003e std::result::Result\u003cVec\u003cFeeEstimate\u003e, jsonrpc::Error\u003e {\n        self.client.estimateFee(request, simulation_flags, block_id).await\n    }\n\n    async fn estimateMessageFee(\n        \u0026self,\n        message: MsgFromL1,\n        block_id: BlockId,\n    ) -\u003e std::result::Result\u003cFeeEstimate, jsonrpc::Error\u003e {\n        self.client.estimateMessageFee(message, block_id).await\n    }\n\n    async fn getBlockTransactionCount(\n        \u0026self,\n        block_id: BlockId,\n    ) -\u003e std::result::Result\u003cGetBlockTransactionCountResult, jsonrpc::Error\u003e\n    {\n        self.client.getBlockTransactionCount(block_id).await\n    }\n\n    async fn getBlockWithReceipts(\n        \u0026self,\n        block_id: BlockId,\n    ) -\u003e std::result::Result\u003cGetBlockWithReceiptsResult, jsonrpc::Error\u003e {\n        self.client.getBlockWithReceipts(block_id).await\n    }\n\n    async fn getBlockWithTxHashes(\n        \u0026self,\n        block_id: BlockId,\n    ) -\u003e std::result::Result\u003cGetBlockWithTxHashesResult, jsonrpc::Error\u003e {\n        self.client.getBlockWithTxHashes(block_id).await\n    }\n\n    async fn getBlockWithTxs(\n        \u0026self,\n        block_id: BlockId,\n    ) -\u003e std::result::Result\u003cGetBlockWithTxsResult, jsonrpc::Error\u003e {\n        self.client.getBlockWithTxs(block_id).await\n    }\n\n    async fn getClass(\n        \u0026self,\n        block_id: BlockId,\n        class_hash: Felt,\n    ) -\u003e std::result::Result\u003cGetClassResult, jsonrpc::Error\u003e {\n        self.client.getClass(block_id, class_hash).await\n    }\n\n    async fn getClassAt(\n        \u0026self,\n        block_id: BlockId,\n        contract_address: Address,\n    ) -\u003e std::result::Result\u003cGetClassAtResult, jsonrpc::Error\u003e {\n        self.client.getClassAt(block_id, contract_address).await\n    }\n\n    async fn getClassHashAt(\n        \u0026self,\n        block_id: BlockId,\n        contract_address: Address,\n    ) -\u003e std::result::Result\u003cFelt, jsonrpc::Error\u003e {\n        self.client.getClassHashAt(block_id, contract_address).await\n    }\n\n    async fn getEvents(\n        \u0026self,\n        filter: GetEventsFilter,\n    ) -\u003e std::result::Result\u003cEventsChunk, jsonrpc::Error\u003e {\n        self.client.getEvents(filter).await\n    }\n\n    async fn getNonce(\n        \u0026self,\n        block_id: BlockId,\n        contract_address: Address,\n    ) -\u003e std::result::Result\u003cFelt, jsonrpc::Error\u003e {\n        self.client.getNonce(block_id, contract_address).await\n    }\n\n    async fn getStateUpdate(\n        \u0026self,\n        block_id: BlockId,\n    ) -\u003e std::result::Result\u003cGetStateUpdateResult, jsonrpc::Error\u003e {\n        self.client.getStateUpdate(block_id).await\n    }\n\n    async fn getStorageAt(\n        \u0026self,\n        contract_address: Address,\n        key: StorageKey,\n        block_id: BlockId,\n    ) -\u003e std::result::Result\u003cFelt, jsonrpc::Error\u003e {\n        let (block_id, state_root) = self.resolve_block_id(block_id).await?;\n\n        let result = self\n            .client\n            .getStorageAt(\n                contract_address.clone(),\n                key.clone(),\n                block_id.clone(),\n            )\n            .await?;\n        tracing::info!(\n            ?contract_address,\n            ?key,\n            ?block_id,\n            ?result,\n            \"getStorageAt\"\n        );\n\n        let proof = self\n            .client\n            .getProof(block_id, contract_address.clone(), vec![key.clone()])\n            .await?;\n\n        proof.verify(state_root, contract_address, key, result.clone())?;\n        tracing::info!(\"getProof: verified\");\n\n        Ok(result)\n    }\n\n    async fn getTransactionByBlockIdAndIndex(\n        \u0026self,\n        block_id: BlockId,\n        index: GetTransactionByBlockIdAndIndexIndex,\n    ) -\u003e std::result::Result\u003c\n        GetTransactionByBlockIdAndIndexResult,\n        jsonrpc::Error,\n    \u003e {\n        self.client.getTransactionByBlockIdAndIndex(block_id, index).await\n    }\n\n    async fn getTransactionByHash(\n        \u0026self,\n        transaction_hash: TxnHash,\n    ) -\u003e std::result::Result\u003cGetTransactionByHashResult, jsonrpc::Error\u003e {\n        self.client.getTransactionByHash(transaction_hash).await\n    }\n\n    async fn getTransactionReceipt(\n        \u0026self,\n        transaction_hash: TxnHash,\n    ) -\u003e std::result::Result\u003cTxnReceiptWithBlockInfo, jsonrpc::Error\u003e {\n        self.client.getTransactionReceipt(transaction_hash).await\n    }\n\n    async fn getTransactionStatus(\n        \u0026self,\n        transaction_hash: TxnHash,\n    ) -\u003e std::result::Result\u003cGetTransactionStatusResult, jsonrpc::Error\u003e {\n        self.client.getTransactionStatus(transaction_hash).await\n    }\n\n    async fn simulateTransactions(\n        \u0026self,\n        block_id: BlockId,\n        transactions: Vec\u003cBroadcastedTxn\u003e,\n        simulation_flags: Vec\u003cSimulationFlag\u003e,\n    ) -\u003e std::result::Result\u003cVec\u003cSimulatedTransaction\u003e, jsonrpc::Error\u003e {\n        self.client\n            .simulateTransactions(block_id, transactions, simulation_flags)\n            .await\n    }\n\n    async fn specVersion(\u0026self) -\u003e std::result::Result\u003cString, jsonrpc::Error\u003e {\n        self.client.specVersion().await\n    }\n\n    async fn syncing(\n        \u0026self,\n    ) -\u003e std::result::Result\u003cSyncingResult, jsonrpc::Error\u003e {\n        self.client.syncing().await\n    }\n\n    async fn traceBlockTransactions(\n        \u0026self,\n        block_id: BlockId,\n    ) -\u003e std::result::Result\u003cVec\u003cBlockTransactionTrace\u003e, jsonrpc::Error\u003e {\n        self.client.traceBlockTransactions(block_id).await\n    }\n\n    async fn traceTransaction(\n        \u0026self,\n        transaction_hash: TxnHash,\n    ) -\u003e std::result::Result\u003cTransactionTrace, jsonrpc::Error\u003e {\n        self.client.traceTransaction(transaction_hash).await\n    }\n\n    async fn getProof(\n        \u0026self,\n        block_id: gen::BlockId,\n        contract_address: gen::Address,\n        keys: Vec\u003cgen::StorageKey\u003e,\n    ) -\u003e std::result::Result\u003cgen::GetProofResult, jsonrpc::Error\u003e {\n        self.client.getProof(block_id, contract_address, keys).await\n    }\n\n    async fn getTxStatus(\n        \u0026self,\n        transaction_hash: gen::TxnHash,\n    ) -\u003e std::result::Result\u003cgen::TxGatewayStatus, jsonrpc::Error\u003e {\n        self.client.getTxStatus(transaction_hash).await\n    }\n\n    async fn version(\u0026self) -\u003e std::result::Result\u003cString, jsonrpc::Error\u003e {\n        self.client.version().await\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::sync::Arc;\n\n    use iamgroot::jsonrpc;\n    use tokio::sync::RwLock;\n    use wiremock::{\n        matchers::any, Mock, MockGuard, MockServer, ResponseTemplate,\n    };\n\n    use crate::{\n        client::Http,\n        rpc::{BlockHash, BlockId, BlockNumber, BlockTag, Felt},\n    };\n\n    use super::{client::Client, ClientState, Context};\n\n    fn make_state(block_number: u64, block_hash: \u0026str) -\u003e ClientState {\n        ClientState {\n            block_number,\n            block_hash: Felt::try_new(block_hash).unwrap(),\n            root: Felt::try_new(\"0x0\").unwrap(),\n        }\n    }\n\n    fn make_context(\n        url_local: \u0026str,\n        url_client: \u0026str,\n        state: ClientState,\n    ) -\u003e Context {\n        let client = reqwest::Client::new();\n        Context {\n            url: url_local.to_string(),\n            client: Arc::new(Client::new(url_client, Http(client))),\n            state: Arc::new(RwLock::new(state)),\n        }\n    }\n\n    fn block_from_hash(block_hash: \u0026str) -\u003e BlockId {\n        BlockId::BlockHash {\n            block_hash: BlockHash(Felt::try_new(block_hash).unwrap()),\n        }\n    }\n\n    fn block_from_number(block_number: u64) -\u003e BlockId {\n        BlockId::BlockNumber {\n            block_number: BlockNumber::try_new(block_number as i64).unwrap(),\n        }\n    }\n\n    fn block_from_tag(tag: \u0026str) -\u003e BlockId {\n        match tag {\n            \"pending\" =\u003e BlockId::BlockTag(BlockTag::Pending),\n            _ =\u003e BlockId::BlockTag(BlockTag::Latest),\n        }\n    }\n\n    fn eq(lhs: \u0026BlockId, rhs: \u0026BlockId) -\u003e bool {\n        match (lhs, rhs) {\n            (\n                BlockId::BlockNumber { block_number: lhs },\n                BlockId::BlockNumber { block_number: rhs },\n            ) =\u003e lhs.as_ref() == rhs.as_ref(),\n            (\n                BlockId::BlockHash { block_hash: lhs },\n                BlockId::BlockHash { block_hash: rhs },\n            ) =\u003e lhs.0.as_ref() == rhs.0.as_ref(),\n            (\n                BlockId::BlockTag(BlockTag::Latest),\n                BlockId::BlockTag(BlockTag::Latest),\n            ) =\u003e true,\n            (\n                BlockId::BlockTag(BlockTag::Pending),\n                BlockId::BlockTag(BlockTag::Pending),\n            ) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    fn get_block_with_tx_hashes_response(\n        block_num: u64,\n        block_hash: \u0026str,\n    ) -\u003e String {\n        serde_json::to_string(\u0026serde_json::json!(\n            {\n                \"jsonrpc\": \"2.0\",\n                \"id\":1,\n                \"result\": {\n                    \"block_hash\": block_hash,\n                    \"block_number\": block_num,\n                    \"l1_gas_price\": {\n                        \"price_in_fri\": \"0x2\",\n                        \"price_in_wei\": \"0x3\"\n                    },\n                    \"new_root\": \"0x4\",\n                    \"parent_hash\": \"0x5\",\n                    \"sequencer_address\": \"0x6\",\n                    \"starknet_version\": \"0.13.1\",\n                    \"status\": \"ACCEPTED_ON_L1\",\n                    \"timestamp\": 1,\n                    \"transactions\" : []\n                }\n            }\n        ))\n        .unwrap()\n    }\n\n    async fn setup_test_env(\n        starknet_server: \u0026MockServer,\n        block_num: u64,\n        starknet_response_block_num: u64,\n        starknet_response_block_hash: \u0026str,\n        expect_request: u64,\n    ) -\u003e (MockGuard, Context) {\n        let mock_guard = Mock::given(any())\n            .respond_with(ResponseTemplate::new(200).set_body_string(\n                get_block_with_tx_hashes_response(\n                    starknet_response_block_num,\n                    starknet_response_block_hash,\n                ),\n            ))\n            .expect(expect_request)\n            .mount_as_scoped(starknet_server)\n            .await;\n        let state = make_state(block_num, \"0x27\");\n        let context =\n            make_context(\"127.0.0.1:3030\", \u0026starknet_server.uri(), state);\n\n        (mock_guard, context)\n    }\n\n    async fn resolve_block_by_number_test(\n        requested_starknet_block_num: u64,\n        block_num: u64,\n        starknet_response_block_num: u64,\n        expect_request: u64,\n    ) -\u003e Result\u003c(BlockId, Felt), jsonrpc::Error\u003e {\n        let starknet_server = MockServer::start().await;\n        let request_block_num =\n            BlockNumber::try_new(requested_starknet_block_num as i64).unwrap();\n\n        let (_mock_guard, context) = setup_test_env(\n            \u0026starknet_server,\n            block_num,\n            starknet_response_block_num,\n            \"0x3\",\n            expect_request,\n        )\n        .await;\n\n        let state = \u0026context.state.read().await;\n        context.resolve_block_by_number(request_block_num, state).await\n    }\n\n    async fn resolve_block_by_hash_test(\n        requested_starknet_block_hash: \u0026str,\n        block_num: u64,\n        starknet_response_block_hash: \u0026str,\n        starknet_response_block_num: u64,\n        expect_request: u64,\n    ) -\u003e Result\u003c(BlockId, Felt), jsonrpc::Error\u003e {\n        let starknet_server = MockServer::start().await;\n        let request_block_hash =\n            BlockHash(Felt::try_new(requested_starknet_block_hash).unwrap());\n\n        let (_mock_guard, context) = setup_test_env(\n            \u0026starknet_server,\n            block_num,\n            starknet_response_block_num,\n            starknet_response_block_hash,\n            expect_request,\n        )\n        .await;\n\n        let state = \u0026context.state.read().await;\n        context.resolve_block_by_hash(request_block_hash, state).await\n    }\n\n    async fn resolve_block_id_test(\n        block: BlockId,\n        block_num: u64,\n        starknet_response_block_num: u64,\n        starknet_response_block_hash: \u0026str,\n        expect_request: u64,\n    ) -\u003e Result\u003c(BlockId, Felt), jsonrpc::Error\u003e {\n        let starknet_server = MockServer::start().await;\n\n        let (_mock_guard, context) = setup_test_env(\n            \u0026starknet_server,\n            block_num,\n            starknet_response_block_num,\n            starknet_response_block_hash,\n            expect_request,\n        )\n        .await;\n\n        context.resolve_block_id(block).await\n    }\n\n    #[tokio::test]\n    async fn resolve_block_by_number_request_lower_success() {\n        let requested_starknet_block_num = 3;\n        let state_block_num = 27;\n        let starknet_response_block_number = 3;\n        let expected_num_request = 1;\n\n        let result = resolve_block_by_number_test(\n            requested_starknet_block_num,\n            state_block_num,\n            starknet_response_block_number,\n            expected_num_request,\n        )\n        .await;\n\n        assert!(result.is_ok());\n        let (returned_block, _) = result.unwrap();\n        assert!(eq(\n            \u0026block_from_number(requested_starknet_block_num),\n            \u0026returned_block\n        ));\n    }\n\n    #[tokio::test]\n    async fn resolve_block_by_number_request_higher_success() {\n        let requested_starknet_block_num = 42;\n        let state_block_num = 27;\n        let starknet_response_block_number = 42;\n        let expected_num_request = 0;\n\n        let result = resolve_block_by_number_test(\n            requested_starknet_block_num,\n            state_block_num,\n            starknet_response_block_number,\n            expected_num_request,\n        )\n        .await;\n\n        assert!(result.is_ok());\n        let (returned_block, _) = result.unwrap();\n        assert!(eq(\n            \u0026block_from_number(state_block_num),\n            \u0026returned_block\n        ));\n    }\n\n    #[tokio::test]\n    async fn resolve_block_by_number_same_success() {\n        let requested_starknet_block_num = 27;\n        let state_block_num = 27;\n        let starknet_response_block_number = requested_starknet_block_num;\n        let expected_num_request = 0;\n\n        let result = resolve_block_by_number_test(\n            requested_starknet_block_num,\n            state_block_num,\n            starknet_response_block_number,\n            expected_num_request,\n        )\n        .await;\n\n        assert!(result.is_ok());\n        let (returned_block, _) = result.unwrap();\n        assert!(eq(\n            \u0026block_from_number(requested_starknet_block_num),\n            \u0026returned_block\n        ));\n    }\n\n    #[tokio::test]\n    async fn resolve_block_by_number_wrong_number_return() {\n        let requested_starknet_block_num = 5;\n        let state_block_num = 27;\n        let starknet_response_block_number = 999;\n        let expected_num_request = 1;\n\n        let result = resolve_block_by_number_test(\n            requested_starknet_block_num,\n            state_block_num,\n            starknet_response_block_number,\n            expected_num_request,\n        )\n        .await;\n\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn resolve_block_by_hash_different_success() {\n        let requested_starknet_block_hash = \"0x3\";\n        let state_block_num = 27;\n        let starknet_response_block_hash = requested_starknet_block_hash;\n        let starknet_response_block_num = 3;\n        let expected_num_request = 1;\n\n        let result = resolve_block_by_hash_test(\n            requested_starknet_block_hash,\n            state_block_num,\n            starknet_response_block_hash,\n            starknet_response_block_num,\n            expected_num_request,\n        )\n        .await;\n\n        assert!(result.is_ok());\n        let (returned_block, _) = result.unwrap();\n        assert!(eq(\n            \u0026block_from_hash(requested_starknet_block_hash),\n            \u0026returned_block\n        ));\n    }\n\n    #[tokio::test]\n    async fn resolve_block_by_hash_same_success() {\n        let requested_starknet_block_hash = \"0x27\";\n        let state_block_num = 27;\n        let starknet_response_block_hash = requested_starknet_block_hash;\n        let starknet_response_block_num = 27;\n        let expected_num_request = 0;\n\n        let result = resolve_block_by_hash_test(\n            requested_starknet_block_hash,\n            state_block_num,\n            starknet_response_block_hash,\n            starknet_response_block_num,\n            expected_num_request,\n        )\n        .await;\n\n        assert!(result.is_ok());\n        let (returned_block, _) = result.unwrap();\n        assert!(eq(\n            \u0026block_from_hash(requested_starknet_block_hash),\n            \u0026returned_block\n        ));\n    }\n\n    #[tokio::test]\n    async fn resolve_block_by_hash_wrong_number_return_error() {\n        let requested_starknet_block_hash = \"0x99\";\n        let state_block_num = 27;\n        let starknet_response_block_hash = requested_starknet_block_hash;\n        let starknet_response_block_num = 27;\n        let expected_num_request = 1;\n\n        let result = resolve_block_by_hash_test(\n            requested_starknet_block_hash,\n            state_block_num,\n            starknet_response_block_hash,\n            starknet_response_block_num,\n            expected_num_request,\n        )\n        .await;\n\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn resolve_block_by_hash_wrong_hash_return_error() {\n        let requested_starknet_block_hash = \"0x99\";\n        let state_block_num = 27;\n        let starknet_response_block_hash = \"0xbad\";\n        let starknet_response_block_num = 3;\n        let expected_num_request = 1;\n\n        let result = resolve_block_by_hash_test(\n            requested_starknet_block_hash,\n            state_block_num,\n            starknet_response_block_hash,\n            starknet_response_block_num,\n            expected_num_request,\n        )\n        .await;\n\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn resolve_block_id_number_success() {\n        let request_block = block_from_number(3);\n        let block_num = 27;\n        let starknet_response_block_num = 3;\n        let starknet_response_block_hash = \"0x3\";\n        let expected_num_request = 1;\n\n        let result = resolve_block_id_test(\n            request_block.clone(),\n            block_num,\n            starknet_response_block_num,\n            starknet_response_block_hash,\n            expected_num_request,\n        )\n        .await;\n\n        assert!(result.is_ok());\n        let (returned_block, _) = result.unwrap();\n        assert!(eq(\u0026request_block, \u0026returned_block));\n    }\n\n    #[tokio::test]\n    async fn resolve_block_id_hash_success() {\n        let request_block = block_from_hash(\"0x3\");\n        let block_num = 27;\n        let starknet_response_block_num = 3;\n        let starknet_response_block_hash = \"0x3\";\n        let expected_num_request = 1;\n\n        let result = resolve_block_id_test(\n            request_block.clone(),\n            block_num,\n            starknet_response_block_num,\n            starknet_response_block_hash,\n            expected_num_request,\n        )\n        .await;\n\n        assert!(result.is_ok());\n        let (returned_block, _) = result.unwrap();\n        assert!(eq(\u0026request_block, \u0026returned_block));\n    }\n\n    #[tokio::test]\n    async fn resolve_block_id_tag_latest_success() {\n        let request_block = block_from_tag(\"latest\");\n        let block_num = 27;\n        let starknet_response_block_num = 33;\n        let starknet_response_block_hash = \"0x33\";\n        let expected_num_request = 0;\n\n        let result = resolve_block_id_test(\n            request_block.clone(),\n            block_num,\n            starknet_response_block_num,\n            starknet_response_block_hash,\n            expected_num_request,\n        )\n        .await;\n\n        assert!(result.is_ok());\n        let (returned_block, _) = result.unwrap();\n        assert!(eq(\u0026block_from_number(block_num), \u0026returned_block));\n    }\n\n    #[tokio::test]\n    async fn resolve_block_id_tag_pending_error() {\n        let request_block = block_from_tag(\"pending\");\n        let block_num = 27;\n        let starknet_response_block_num = 33;\n        let starknet_response_block_hash = \"0x33\";\n        let expected_num_request = 0;\n\n        let result = resolve_block_id_test(\n            request_block.clone(),\n            block_num,\n            starknet_response_block_num,\n            starknet_response_block_hash,\n            expected_num_request,\n        )\n        .await;\n\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":24,"address":[13740496,13740499],"length":1,"stats":{"Line":0}},{"line":30,"address":[13740531,13740528],"length":1,"stats":{"Line":0}},{"line":31,"address":[8293471,8293513,8293637,8293573],"length":1,"stats":{"Line":0}},{"line":35,"address":[13740560],"length":1,"stats":{"Line":16}},{"line":36,"address":[13740565],"length":1,"stats":{"Line":16}},{"line":40,"address":[8292000],"length":1,"stats":{"Line":14}},{"line":45,"address":[],"length":0,"stats":{"Line":28}},{"line":46,"address":[],"length":0,"stats":{"Line":32}},{"line":47,"address":[],"length":0,"stats":{"Line":16}},{"line":50,"address":[13740576,13742377,13742567],"length":1,"stats":{"Line":16}},{"line":57,"address":[13740767,13740635,13742474,13741010],"length":1,"stats":{"Line":32}},{"line":63,"address":[13740982],"length":1,"stats":{"Line":15}},{"line":64,"address":[13741082,13741158],"length":1,"stats":{"Line":16}},{"line":68,"address":[13741259,13741321,13742408],"length":1,"stats":{"Line":32}},{"line":70,"address":[13741651,13741567],"length":1,"stats":{"Line":32}},{"line":71,"address":[13741675,13741735],"length":1,"stats":{"Line":32}},{"line":72,"address":[13521023,13521207,13521599,13524846,13520992],"length":1,"stats":{"Line":19}},{"line":73,"address":[13521382,13521085,13521250,13521567,13521521,13521770],"length":1,"stats":{"Line":7}},{"line":74,"address":[13524896,13521342,13524915,13525014,13524986,13525084,13525287],"length":1,"stats":{"Line":14}},{"line":75,"address":[13524962,13525054,13525007,13525116],"length":1,"stats":{"Line":13}},{"line":77,"address":[13521802,13521237,13521470,13521640,13521537],"length":1,"stats":{"Line":18}},{"line":78,"address":[13521862,13522066],"length":1,"stats":{"Line":0}},{"line":79,"address":[13524304,13522122,13523477,13524494,13523019,13522538,13522867,13522737,13523798,13523989,13523379,13523203,13537035,13523734,13537192],"length":1,"stats":{"Line":0}},{"line":83,"address":[13742083],"length":1,"stats":{"Line":16}},{"line":105,"address":[13742608],"length":1,"stats":{"Line":0}},{"line":106,"address":[13742619],"length":1,"stats":{"Line":0}},{"line":107,"address":[13742626],"length":1,"stats":{"Line":0}},{"line":119,"address":[13742720],"length":1,"stats":{"Line":2}},{"line":123,"address":[13313950],"length":1,"stats":{"Line":7}},{"line":124,"address":[13525953,13526087],"length":1,"stats":{"Line":7}},{"line":126,"address":[13526954],"length":1,"stats":{"Line":0}},{"line":128,"address":[13526113],"length":1,"stats":{"Line":0}},{"line":131,"address":[13526259],"length":1,"stats":{"Line":2}},{"line":132,"address":[13526089,13526192],"length":1,"stats":{"Line":5}},{"line":133,"address":[13526195],"length":1,"stats":{"Line":2}},{"line":134,"address":[13526227],"length":1,"stats":{"Line":3}},{"line":138,"address":[13742768],"length":1,"stats":{"Line":4}},{"line":142,"address":[13318412],"length":1,"stats":{"Line":6}},{"line":143,"address":[13528159,13527883],"length":1,"stats":{"Line":4}},{"line":144,"address":[13528098],"length":1,"stats":{"Line":2}},{"line":145,"address":[13318432],"length":1,"stats":{"Line":6}},{"line":147,"address":[13527973],"length":1,"stats":{"Line":2}},{"line":148,"address":[13318455],"length":1,"stats":{"Line":6}},{"line":151,"address":[13528583,13528634,13528782],"length":1,"stats":{"Line":4}},{"line":153,"address":[13528851,13528740],"length":1,"stats":{"Line":2}},{"line":155,"address":[13529172],"length":1,"stats":{"Line":2}},{"line":157,"address":[13528599],"length":1,"stats":{"Line":2}},{"line":162,"address":[13742816],"length":1,"stats":{"Line":2}},{"line":167,"address":[13530292,13530173],"length":1,"stats":{"Line":4}},{"line":168,"address":[13530304],"length":1,"stats":{"Line":2}},{"line":169,"address":[13530756],"length":1,"stats":{"Line":1}},{"line":170,"address":[13530598],"length":1,"stats":{"Line":1}},{"line":171,"address":[13530675,13530930,13530515,13530349],"length":1,"stats":{"Line":2}},{"line":172,"address":[13530345],"length":1,"stats":{"Line":1}},{"line":175,"address":[13530624],"length":1,"stats":{"Line":1}},{"line":178,"address":[13531796,13530461,13531365,13531194,13531076,13530407],"length":1,"stats":{"Line":9}},{"line":179,"address":[13530381],"length":1,"stats":{"Line":2}},{"line":180,"address":[13530319],"length":1,"stats":{"Line":2}},{"line":182,"address":[13323540],"length":1,"stats":{"Line":10}},{"line":183,"address":[13531308],"length":1,"stats":{"Line":3}},{"line":184,"address":[13531686],"length":1,"stats":{"Line":1}},{"line":186,"address":[13531615],"length":1,"stats":{"Line":1}},{"line":190,"address":[13531402],"length":1,"stats":{"Line":2}},{"line":193,"address":[13742864],"length":1,"stats":{"Line":2}},{"line":198,"address":[13532090,13531975],"length":1,"stats":{"Line":4}},{"line":199,"address":[13532482],"length":1,"stats":{"Line":1}},{"line":200,"address":[13532189],"length":1,"stats":{"Line":1}},{"line":201,"address":[13532262],"length":1,"stats":{"Line":1}},{"line":204,"address":[13533811,13532796,13532917,13533168,13532384,13532330],"length":1,"stats":{"Line":10}},{"line":205,"address":[13532298,13532165],"length":1,"stats":{"Line":5}},{"line":206,"address":[13322225],"length":1,"stats":{"Line":10}},{"line":207,"address":[13533111,13533254],"length":1,"stats":{"Line":8}},{"line":208,"address":[13533340],"length":1,"stats":{"Line":3}},{"line":210,"address":[13533701],"length":1,"stats":{"Line":2}},{"line":212,"address":[13533363],"length":1,"stats":{"Line":1}},{"line":215,"address":[13533393],"length":1,"stats":{"Line":2}},{"line":219,"address":[13742928],"length":1,"stats":{"Line":7}},{"line":223,"address":[13534204],"length":1,"stats":{"Line":7}},{"line":224,"address":[13534309],"length":1,"stats":{"Line":4}},{"line":225,"address":[13309116],"length":1,"stats":{"Line":17}},{"line":226,"address":[13535463,13535248,13535326],"length":1,"stats":{"Line":3}},{"line":227,"address":[13535351],"length":1,"stats":{"Line":1}},{"line":229,"address":[13535465,13535332],"length":1,"stats":{"Line":0}},{"line":232,"address":[13534395],"length":1,"stats":{"Line":0}},{"line":233,"address":[13534684,13534446],"length":1,"stats":{"Line":0}},{"line":234,"address":[13536353,13534841,13536421,13534710],"length":1,"stats":{"Line":0}},{"line":235,"address":[13536460],"length":1,"stats":{"Line":0}},{"line":236,"address":[13309141],"length":1,"stats":{"Line":0}},{"line":237,"address":[13535999,13536071],"length":1,"stats":{"Line":0}},{"line":238,"address":[13536089],"length":1,"stats":{"Line":0}},{"line":241,"address":[13536495],"length":1,"stats":{"Line":0}},{"line":252,"address":[13223025],"length":1,"stats":{"Line":0}},{"line":260,"address":[13540410,13540602,13540226,13540348],"length":1,"stats":{"Line":0}},{"line":261,"address":[13540291],"length":1,"stats":{"Line":0}},{"line":262,"address":[13226033],"length":1,"stats":{"Line":0}},{"line":269,"address":[13221665],"length":1,"stats":{"Line":0}},{"line":275,"address":[13220900],"length":1,"stats":{"Line":2}},{"line":281,"address":[13216324],"length":1,"stats":{"Line":2}},{"line":289,"address":[13544400,13544497],"length":1,"stats":{"Line":4}},{"line":290,"address":[13209980],"length":1,"stats":{"Line":3}},{"line":293,"address":[13546336,13595739,13546054,13545439,13547041,13547428,13548248,13595896,13546943,13546764,13545855,13546184,13547352],"length":1,"stats":{"Line":5}},{"line":295,"address":[13546494,13552224,13552516,13551799,13549251,13549754,13551844,13549061,13549331,13549502,13552567],"length":1,"stats":{"Line":5}},{"line":296,"address":[13552345,13552246],"length":1,"stats":{"Line":2}},{"line":298,"address":[13210005],"length":1,"stats":{"Line":4}},{"line":299,"address":[13552903,13552608],"length":1,"stats":{"Line":0}},{"line":300,"address":[13552858,13552759],"length":1,"stats":{"Line":0}},{"line":303,"address":[13549647,13549827],"length":1,"stats":{"Line":2}},{"line":308,"address":[13552928,13552945],"length":1,"stats":{"Line":2}},{"line":311,"address":[13550111,13549952,13549881],"length":1,"stats":{"Line":2}},{"line":314,"address":[13553043,13553145,13553008,13553577,13553882,13553393],"length":1,"stats":{"Line":3}},{"line":315,"address":[13212132],"length":1,"stats":{"Line":2}},{"line":324,"address":[13216446],"length":1,"stats":{"Line":3}},{"line":332,"address":[13221025],"length":1,"stats":{"Line":0}},{"line":340,"address":[13224638],"length":1,"stats":{"Line":3}},{"line":347,"address":[13221822],"length":1,"stats":{"Line":0}},{"line":354,"address":[13221982],"length":1,"stats":{"Line":7}},{"line":361,"address":[13219678],"length":1,"stats":{"Line":3}},{"line":369,"address":[13213026],"length":1,"stats":{"Line":3}},{"line":377,"address":[13214770],"length":1,"stats":{"Line":3}},{"line":385,"address":[13218978],"length":1,"stats":{"Line":3}},{"line":392,"address":[13214465],"length":1,"stats":{"Line":0}},{"line":400,"address":[13213250],"length":1,"stats":{"Line":3}},{"line":407,"address":[13219198],"length":1,"stats":{"Line":0}},{"line":416,"address":[13217535],"length":1,"stats":{"Line":5}},{"line":418,"address":[13571488,13571346,13571747,13571857,13572218,13577284,13570952],"length":1,"stats":{"Line":5}},{"line":421,"address":[13571122,13571181],"length":1,"stats":{"Line":2}},{"line":422,"address":[13571189,13571262],"length":1,"stats":{"Line":2}},{"line":423,"address":[13571270],"length":1,"stats":{"Line":1}},{"line":425,"address":[13217561],"length":1,"stats":{"Line":4}},{"line":426,"address":[13575378,13596315,13596472,13573407,13573207,13573681,13573055,13572726,13574068,13573992,13573583,13572925,13572310],"length":1,"stats":{"Line":5}},{"line":434,"address":[13577026,13577476,13577556,13577946,13573362,13581314,13577168],"length":1,"stats":{"Line":5}},{"line":436,"address":[13577225,13577109,13576605],"length":1,"stats":{"Line":2}},{"line":437,"address":[13217587],"length":1,"stats":{"Line":4}},{"line":439,"address":[13581204,13577983,13577710,13578202,13578388],"length":1,"stats":{"Line":2}},{"line":440,"address":[13579361,13579209,13579925,13580624,13597048,13578880,13579079,13596891,13578464,13579648,13579827,13580188,13580252],"length":1,"stats":{"Line":5}},{"line":442,"address":[13579516],"length":1,"stats":{"Line":1}},{"line":453,"address":[13226798],"length":1,"stats":{"Line":3}},{"line":460,"address":[13222142],"length":1,"stats":{"Line":3}},{"line":467,"address":[13223182],"length":1,"stats":{"Line":3}},{"line":474,"address":[13222302],"length":1,"stats":{"Line":3}},{"line":483,"address":[13587811,13587354,13587630,13587544],"length":1,"stats":{"Line":0}},{"line":484,"address":[13587421],"length":1,"stats":{"Line":0}},{"line":485,"address":[13222466],"length":1,"stats":{"Line":0}},{"line":488,"address":[13588243,13588593,13589082,13588208,13588345,13588777],"length":1,"stats":{"Line":3}},{"line":489,"address":[13216884],"length":1,"stats":{"Line":2}},{"line":495,"address":[13212244],"length":1,"stats":{"Line":2}},{"line":502,"address":[13223678],"length":1,"stats":{"Line":0}},{"line":509,"address":[13220126],"length":1,"stats":{"Line":0}},{"line":518,"address":[13213474],"length":1,"stats":{"Line":3}},{"line":525,"address":[13216734],"length":1,"stats":{"Line":0}},{"line":528,"address":[13594921,13595658,13594819,13595353,13595169,13594784],"length":1,"stats":{"Line":0}},{"line":529,"address":[13212356],"length":1,"stats":{"Line":0}}],"covered":114,"coverable":152},{"path":["/","home","work","Work","Eiger","code","beerus","src","util.rs"],"content":"use bitvec::prelude::{BitSlice, BitVec, Msb0};\nuse bitvec::view::BitView;\nuse eyre::{eyre, Result};\nuse starknet_crypto::Felt as FieldElement;\n\npub fn felt_to_bits(felt: \u0026[u8; 32]) -\u003e BitVec\u003cu8, Msb0\u003e {\n    felt.view_bits::\u003cMsb0\u003e()[5..].to_bitvec()\n}\n\npub fn felt_from_bits(\n    bits: \u0026BitSlice\u003cu8, Msb0\u003e,\n    mask: Option\u003cusize\u003e,\n) -\u003e Result\u003cFieldElement\u003e {\n    if bits.len() != 251 {\n        return Err(eyre!(\"expecting 251 bits\"));\n    }\n\n    let mask = match mask {\n        Some(x) =\u003e {\n            if x \u003e 251 {\n                return Err(eyre!(\"Mask cannot be bigger than 251\"));\n            }\n            x\n        }\n        None =\u003e 0,\n    };\n\n    let mut bytes = [0u8; 32];\n    bytes.view_bits_mut::\u003cMsb0\u003e()[5 + mask..].copy_from_bitslice(\u0026bits[mask..]);\n\n    Ok(FieldElement::from_bytes_be(\u0026bytes))\n}\n\n#[cfg(test)]\nmod tests {\n    use bitvec::{order::Msb0, slice::BitSlice};\n    use starknet_crypto::Felt as FieldElement;\n\n    use super::{felt_from_bits, felt_to_bits};\n\n    #[test]\n    fn test_felt_to_bits_three() {\n        let val = FieldElement::THREE;\n        let mut slice = [0u8; 32];\n        let bit_slice = BitSlice::\u003cu8, Msb0\u003e::from_slice_mut(\u0026mut slice);\n        bit_slice.set(249, true);\n        bit_slice.set(250, true);\n        assert_eq!(felt_to_bits(\u0026val.to_bytes_be()), \u0026bit_slice[..251]);\n    }\n\n    #[test]\n    fn test_felt_to_bits_fourteen() {\n        let val = FieldElement::from_dec_str(\"14\").unwrap();\n        let mut slice = [0u8; 32];\n        let bit_slice = BitSlice::\u003cu8, Msb0\u003e::from_slice_mut(\u0026mut slice);\n        bit_slice.set(247, true);\n        bit_slice.set(248, true);\n        bit_slice.set(249, true);\n        assert_eq!(felt_to_bits(\u0026val.to_bytes_be()), \u0026bit_slice[..251]);\n    }\n\n    #[test]\n    fn test_felt_from_bits_one() {\n        let mut slice = [0u8; 32];\n        let bit_slice = BitSlice::\u003cu8, Msb0\u003e::from_slice_mut(\u0026mut slice);\n        bit_slice.set(250, true);\n        assert_eq!(\n            felt_from_bits(\u0026bit_slice[..251], None).unwrap(),\n            FieldElement::ONE\n        );\n    }\n\n    #[test]\n    fn test_felt_from_bits_seven() {\n        let mut slice = [0u8; 32];\n        let bit_slice = BitSlice::\u003cu8, Msb0\u003e::from_slice_mut(\u0026mut slice);\n        bit_slice.set(248, true);\n        bit_slice.set(249, true);\n        bit_slice.set(250, true);\n        assert_eq!(\n            felt_from_bits(\u0026bit_slice[..251], None).unwrap(),\n            FieldElement::from_dec_str(\"7\").unwrap()\n        );\n    }\n\n    #[test]\n    fn test_felt_from_bits_mask() {\n        let mut slice = [0u8; 32];\n        let bit_slice = BitSlice::\u003cu8, Msb0\u003e::from_slice_mut(\u0026mut slice);\n        bit_slice.set(0, true);\n        bit_slice.set(250, true);\n        assert_eq!(\n            felt_from_bits(\u0026bit_slice[..251], None).unwrap(),\n            FieldElement::from_dec_str(\n                \"1809251394333065553493296640760748560207343510400633813116524750123642650625\"\n            )\n            .unwrap()\n        );\n        assert_eq!(\n            felt_from_bits(\u0026bit_slice[..251], Some(1)).unwrap(),\n            FieldElement::from_dec_str(\"1\").unwrap()\n        );\n    }\n\n    #[test]\n    fn test_felt_from_bits_wrong_mask_value() {\n        let mut slice = [0u8; 32];\n        let bit_slice = BitSlice::\u003cu8, Msb0\u003e::from_slice_mut(\u0026mut slice);\n        assert!(felt_from_bits(\u0026bit_slice[..251], Some(252)).is_err());\n    }\n}\n","traces":[{"line":6,"address":[12602352],"length":1,"stats":{"Line":6}},{"line":7,"address":[22206347,22206414,22206309],"length":1,"stats":{"Line":3}},{"line":10,"address":[67163591],"length":1,"stats":{"Line":3}},{"line":14,"address":[22201468,22201377],"length":1,"stats":{"Line":6}},{"line":15,"address":[67163941],"length":1,"stats":{"Line":0}},{"line":18,"address":[12602531],"length":1,"stats":{"Line":3}},{"line":19,"address":[12602623],"length":1,"stats":{"Line":6}},{"line":20,"address":[12602641],"length":1,"stats":{"Line":3}},{"line":21,"address":[12602738],"length":1,"stats":{"Line":1}},{"line":23,"address":[12602728],"length":1,"stats":{"Line":6}},{"line":25,"address":[104245059],"length":1,"stats":{"Line":2}},{"line":28,"address":[99273856,99273675,99273656],"length":1,"stats":{"Line":3}},{"line":29,"address":[12602827,12602992,12602671],"length":1,"stats":{"Line":9}},{"line":31,"address":[12602908],"length":1,"stats":{"Line":6}}],"covered":13,"coverable":14},{"path":["/","home","work","Work","Eiger","code","beerus","tests","account_katana.rs"],"content":"use std::{sync::Arc, thread, time};\n\nuse beerus::{\n    client::{Http, State},\n    gen::{\n        client::Client, Address, BlockId, BlockTag, BroadcastedDeclareTxn,\n        BroadcastedDeployAccountTxn, BroadcastedInvokeTxn, BroadcastedTxn,\n        DeployAccountTxn, DeployAccountTxnV1, DeployAccountTxnV1Type,\n        DeployAccountTxnV1Version, Felt, InvokeTxn, InvokeTxnV1,\n        InvokeTxnV1Type, InvokeTxnV1Version, Rpc, SimulationFlagForEstimateFee,\n        TxnHash,\n    },\n    rpc::{serve, Server},\n};\nuse common::err::Error;\nuse starknet::{\n    constants::{\n        CLASS_HASH, COMPILED_ACCOUNT_CONTRACT_V2, COMPILED_ACCOUNT_CONTRACT_V3,\n        CONTRACT_ADDRESS, DECLARE_ACCOUNT_V2, DECLARE_ACCOUNT_V3,\n        SENDER_ADDRESS,\n    },\n    starkli::{PreFundedAccount, Starkli},\n    utils,\n};\nuse starknet::{katana::Katana, scarb};\nuse tokio::sync::RwLock;\n\nmod common;\nmod starknet;\n\nasync fn setup() -\u003e (Katana, Client\u003cHttp\u003e) {\n    let katana = Katana::init(\"http://127.0.0.1:0\").await.unwrap();\n    let url = format!(\"http://127.0.0.1:{}\", katana.port());\n    let client = Client::new(\u0026url, Http::new());\n    (katana, client)\n}\n\nasync fn setup_beerus_with_katana() -\u003e Result\u003c(Server, Katana), Error\u003e {\n    let katana = Katana::init(\"http://127.0.0.1:0\").await?;\n    let state = State {\n        block_number: 0,\n        block_hash: Felt::try_new(\"0x0\")?,\n        root: Felt::try_new(\"0x0\")?,\n    };\n    let beerus = serve(\n        \u0026format!(\"http://127.0.0.1:{}\", katana.port()),\n        \"127.0.0.1:0\",\n        Arc::new(RwLock::new(state)),\n    )\n    .await?;\n    Ok((beerus, katana))\n}\n\n#[tokio::test]\nasync fn declare_account_v3() {\n    let (_katana, client) = setup().await;\n    declare(\u0026client, COMPILED_ACCOUNT_CONTRACT_V3, DECLARE_ACCOUNT_V3).await;\n}\n\n#[tokio::test]\nasync fn declare_deploy_account_v2() {\n    let (_katana, client) = setup().await;\n    declare(\u0026client, COMPILED_ACCOUNT_CONTRACT_V2, DECLARE_ACCOUNT_V2).await;\n    estimate_deploy(\u0026client).await;\n    transfer_eth(\u0026client).await;\n    deploy(client).await;\n}\n\n#[tokio::test]\n#[ignore]\nasync fn deploy_account_on_katana() -\u003e Result\u003c(), Error\u003e {\n    let (beerus, katana) = setup_beerus_with_katana().await?;\n\n    let account = utils::prepare_account()?;\n    scarb::compile_blocking(account.toml).await?;\n\n    let mut starkli = Starkli::new(\n        \u0026format!(\"http://127.0.0.1:{}/rpc\", beerus.port()),\n        \u0026account.folder,\n        PreFundedAccount::Katana,\n    );\n    let key = starkli.create_keystore()?;\n    let class_hash = starkli.extract_class_hash()?;\n    let address = starkli.create_account(key.clone(), class_hash).await?;\n    starkli.declare_account().await?;\n    starkli.invoke_eth_transfer(address, 5e18 as u64).await?;\n    starkli.deploy_account().await?;\n\n    // Redirect starkli to katana in verification because katana does not support\n    // pathfinder methods which are being called in beerus stateless call execution\n    // TODO: Use beerus when test node with supported pathfinder methods is used\n    starkli.rpc = format!(\"http://127.0.0.1:{}\", katana.port());\n\n    let res_id = starkli.call(address, \"id\").await?;\n    assert_eq!(res_id.len(), 2);\n    assert_eq!(res_id[0].to_string(), account.id);\n    assert_eq!(res_id[1], starknet_crypto::Felt::ZERO);\n\n    let res_public_key = starkli.call(address, \"public_key\").await?;\n    assert_eq!(res_public_key.len(), 1);\n    assert_eq!(res_public_key[0], key.verifying_key().scalar());\n\n    Ok(())\n}\n\nasync fn declare(\n    client: \u0026Client\u003cHttp\u003e,\n    compiled_contract: \u0026str,\n    declare_account: \u0026str,\n) {\n    let block_id = BlockId::BlockTag(BlockTag::Pending);\n    let class_hash = Felt::try_new(CLASS_HASH).unwrap();\n    let contract_address = Address(Felt::try_new(SENDER_ADDRESS).unwrap());\n\n    let res_chain_id = client.chainId().await;\n    assert!(res_chain_id.is_ok());\n    assert_eq!(res_chain_id.unwrap().as_ref(), \"0x4b4154414e41\");\n\n    let res_class = client.getClass(block_id.clone(), class_hash.clone()).await;\n    assert!(res_class.is_err());\n    assert!(res_class.unwrap_err().message.contains(\"Class hash not found\"));\n\n    let res_nonce = client.getNonce(block_id.clone(), contract_address).await;\n    assert!(res_nonce.is_ok());\n    assert_eq!(res_nonce.unwrap().as_ref(), \"0x0\");\n\n    let res_spec_version = client.specVersion().await;\n    assert!(res_spec_version.is_ok());\n    assert_eq!(res_spec_version.unwrap().as_str(), \"0.7.1\");\n\n    let contract: Vec\u003cBroadcastedTxn\u003e =\n        serde_json::from_str(compiled_contract).unwrap();\n    let simulation_flags: Vec\u003cSimulationFlagForEstimateFee\u003e = vec![];\n    let res_estimate_fee =\n        client.estimateFee(contract, simulation_flags, block_id.clone()).await;\n    assert!(res_estimate_fee.is_ok());\n\n    let declare_account: BroadcastedDeclareTxn =\n        serde_json::from_str(declare_account).unwrap();\n    let res_declare_account =\n        client.addDeclareTransaction(declare_account).await;\n    assert!(res_declare_account.is_ok());\n\n    let block_mining_time = time::Duration::from_millis(1000);\n    thread::sleep(block_mining_time);\n\n    let res_class = client.getClass(block_id, class_hash).await;\n    assert!(res_class.is_ok());\n}\n\nasync fn estimate_deploy(client: \u0026Client\u003cHttp\u003e) {\n    let block_id = BlockId::BlockTag(BlockTag::Pending);\n    let contract_address = Address(Felt::try_new(CONTRACT_ADDRESS).unwrap());\n\n    let res_chain_id = client.chainId().await;\n    assert!(res_chain_id.is_ok());\n    assert_eq!(res_chain_id.unwrap().as_ref(), \"0x4b4154414e41\");\n\n    let res_nonce = client.getNonce(block_id.clone(), contract_address).await;\n    assert!(res_nonce.is_err());\n\n    let res_spec_version = client.specVersion().await;\n    assert!(res_spec_version.is_ok());\n    assert_eq!(res_spec_version.unwrap().as_str(), \"0.7.1\");\n\n    let max_fee = Felt::try_new(\"0x0\").unwrap();\n    let signature = vec![\n        Felt::try_new(\n            \"0x4695bbb6bc179a263b534f6083ca3dc45ffe3935ea86f3cc54a55c6de34eaa6\",\n        )\n        .unwrap(),\n        Felt::try_new(\n            \"0x2bd23130483dc20cbca45bd8f9f2c67e3393c2dd6763c7d08f99821a12e3ac5\",\n        )\n        .unwrap(),\n    ];\n    let version =\n        DeployAccountTxnV1Version::V0x100000000000000000000000000000001;\n    let deploy_account: Vec\u003cBroadcastedTxn\u003e =\n        vec![BroadcastedTxn::BroadcastedDeployAccountTxn(deploy_tx(\n            max_fee, signature, version,\n        ))];\n    let simulation_flags: Vec\u003cSimulationFlagForEstimateFee\u003e = vec![];\n    let res_estimate_fee =\n        client.estimateFee(deploy_account, simulation_flags, block_id).await;\n    assert!(res_estimate_fee.is_ok());\n}\n\nasync fn transfer_eth(client: \u0026Client\u003cHttp\u003e) {\n    let block_id = BlockId::BlockTag(BlockTag::Pending);\n    let sender_address = Address(Felt::try_new(SENDER_ADDRESS).unwrap());\n\n    let res_chain_id = client.chainId().await;\n    assert!(res_chain_id.is_ok());\n    assert_eq!(res_chain_id.unwrap().as_ref(), \"0x4b4154414e41\");\n\n    let res_chain_id = client.chainId().await;\n    assert!(res_chain_id.is_ok());\n    assert_eq!(res_chain_id.unwrap().as_ref(), \"0x4b4154414e41\");\n\n    let res_nonce =\n        client.getNonce(block_id.clone(), sender_address.clone()).await;\n    assert!(res_nonce.is_ok());\n    assert_eq!(res_nonce.unwrap().as_ref(), \"0x1\");\n\n    let res_spec_version = client.specVersion().await;\n    assert!(res_spec_version.is_ok());\n    assert_eq!(res_spec_version.unwrap().as_str(), \"0.7.1\");\n\n    let max_fee_estimate = Felt::try_new(\"0x0\").unwrap();\n    let signature_estimate = vec![\n        Felt::try_new(\n            \"0x1bc1b911315a5d7b5b2201b49e9622d755dbb383cf156523a369db0e742e266\",\n        )\n        .unwrap(),\n        Felt::try_new(\n            \"0x104e9068ad119cd9284e5c7822530bf224460c53dd99bd24e00ccd85dd15e6e\",\n        )\n        .unwrap(),\n    ];\n    let version_estimate_fee =\n        InvokeTxnV1Version::V0x100000000000000000000000000000001;\n    let estimate_fee_tx =\n        vec![BroadcastedTxn::BroadcastedInvokeTxn(invoke_tx(\n            sender_address.clone(),\n            max_fee_estimate,\n            signature_estimate,\n            version_estimate_fee,\n        ))];\n    let simulation_flags: Vec\u003cSimulationFlagForEstimateFee\u003e = vec![];\n    let res_estimate_fee = client\n        .estimateFee(estimate_fee_tx, simulation_flags, block_id.clone())\n        .await;\n    assert!(res_estimate_fee.is_ok());\n\n    let max_fee_invoke = Felt::try_new(\"0x17a70d4b0e800\").unwrap();\n    let signature_invoke = vec![\n        Felt::try_new(\n            \"0x5d4ef80a4e4217d8de52475799b4f3df3c82acaede506d90d34f44eedc0506b\",\n        )\n        .unwrap(),\n        Felt::try_new(\n            \"0x6786f06333100af063a9fce3388f5b733f0e2e7d247738a909594b92b90d8b9\",\n        )\n        .unwrap(),\n    ];\n    let version_invoke = InvokeTxnV1Version::V0x1;\n    let transfer_eth_tx = invoke_tx(\n        sender_address,\n        max_fee_invoke,\n        signature_invoke,\n        version_invoke,\n    );\n    let res_invoke_tx = client.addInvokeTransaction(transfer_eth_tx).await;\n    assert!(res_invoke_tx.is_ok());\n}\n\nasync fn deploy(client: Client\u003cHttp\u003e) {\n    let block_id = BlockId::BlockTag(BlockTag::Pending);\n    let contract_address = Address(Felt::try_new(CONTRACT_ADDRESS).unwrap());\n\n    let res_nonce = client.getNonce(block_id, contract_address).await;\n    assert!(res_nonce.is_err());\n\n    let max_fee = Felt::try_new(\"0x1c484e3020c00\").unwrap();\n    let signature = vec![\n        Felt::try_new(\n            \"0x1892f4e8d35a0f73f4eab5fd085c25ec576c9887da17af82f13b8caecb3cb9c\",\n        )\n        .unwrap(),\n        Felt::try_new(\n            \"0x11408b2e3e95e3c5d9dbdb354cf9c06dd66d1f99e86ac31e5820c6db4647a64\",\n        )\n        .unwrap(),\n    ];\n    let version = DeployAccountTxnV1Version::V0x1;\n    let deploy_account_tx = deploy_tx(max_fee, signature, version);\n    let res_deploy =\n        client.addDeployAccountTransaction(deploy_account_tx).await;\n    assert!(res_deploy.is_ok());\n\n    let block_mining_time = time::Duration::from_millis(1000);\n    thread::sleep(block_mining_time);\n\n    let tx_hash = TxnHash(\n        Felt::try_new(\n            \"0x1eb7ad201058042d681bb3159068978046b1d992561fdefa0bffcd4bc187572\",\n        )\n        .unwrap(),\n    );\n    let res_get_receipt = client.getTransactionReceipt(tx_hash).await;\n    assert!(res_get_receipt.is_ok());\n}\n\nfn deploy_tx(\n    max_fee: Felt,\n    signature: Vec\u003cFelt\u003e,\n    version: DeployAccountTxnV1Version,\n) -\u003e BroadcastedDeployAccountTxn {\n    BroadcastedDeployAccountTxn(DeployAccountTxn::DeployAccountTxnV1(DeployAccountTxnV1{\n        class_hash: Felt::try_new(CLASS_HASH).unwrap(),\n        constructor_calldata: vec![\n            Felt::try_new(\"0x44c65058267bdcca53dbc4323fe64e547942389abe448d19daae570d99b3c0a\").unwrap(),\n        ],\n        contract_address_salt: Felt::try_new(\"0x608eca42681e117e32199488d442377b68ced54f71b8af6b0aa5b8163caaf8f\").unwrap(),\n        max_fee,\n        nonce: Felt::try_new(\"0x0\").unwrap(),\n        r#type: DeployAccountTxnV1Type::DeployAccount,\n        signature,\n        version,\n    }))\n}\n\nfn invoke_tx(\n    sender_address: Address,\n    max_fee: Felt,\n    signature: Vec\u003cFelt\u003e,\n    version: InvokeTxnV1Version,\n) -\u003e BroadcastedInvokeTxn {\n    BroadcastedInvokeTxn(InvokeTxn::InvokeTxnV1(InvokeTxnV1{\n            calldata: vec![\n                Felt::try_new(\"0x1\").unwrap(),\n                Felt::try_new(\"0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\").unwrap(),\n                Felt::try_new(\"0x83afd3f4caedc6eebf44246fe54e38c95e3179a5ec9ea81740eca5b482d12e\").unwrap(),\n                Felt::try_new(\"0x3\").unwrap(),\n                Felt::try_new(CONTRACT_ADDRESS).unwrap(),\n                Felt::try_new(\"0x4563918244f40000\").unwrap(),\n                Felt::try_new(\"0x0\").unwrap(),\n            ],\n            max_fee,\n            nonce: Felt::try_new(\"0x1\").unwrap(),\n            r#type: InvokeTxnV1Type::Invoke,\n            sender_address,\n            signature,\n            version,\n    }))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","work","Work","Eiger","code","beerus","tests","account_mock.rs"],"content":"use beerus::gen::{Address, BlockId, BlockTag, Felt, Rpc, TxnHash};\n\nuse mock::{\n    dummies::{\n        declare_transaction, deploy_transaction, estimate_fee_transaction,\n        invoke_transaction,\n    },\n    matchers::StarknetMatcher::{\n        self, AddDeclareTransaction, AddDeclareTransactionMalicious,\n        AddDeployAccountTransaction, AddInvokeTransaction, ChainId,\n        ChainIdMalicious, ClassError, ClassMalicious, ClassSuccess,\n        EstimateFee, EstimateFeeMalicious, GetTransactionReceipt, Nonce,\n        NonceMalicious, SpecVersion, SpecVersionMalicious,\n    },\n    node::setup_client_with_mock_starknet_node,\n};\n\nmod mock;\n\n#[tokio::test]\nasync fn chain_id_test() {\n    let (client, _starknet_node) =\n        setup_client_with_mock_starknet_node(vec![ChainId]).await;\n    let result = client.chainId().await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn chain_id_nonce() {\n    let (client, _starknet_node) =\n        setup_client_with_mock_starknet_node(vec![ChainId, Nonce]).await;\n    assert!(client.chainId().await.is_ok());\n    assert!(client\n        .getNonce(\n            BlockId::BlockTag(BlockTag::Latest),\n            Address(Felt::try_new(\"0x0\").unwrap())\n        )\n        .await\n        .is_ok())\n}\n\n#[tokio::test]\nasync fn chain_id_called_twice() {\n    let (client, _starknet_node) =\n        setup_client_with_mock_starknet_node(vec![ChainId, ChainId]).await;\n    assert!(client.chainId().await.is_ok());\n    assert!(client.chainId().await.is_ok());\n}\n\n#[tokio::test]\nasync fn get_class_error() {\n    let (client, _starknet_node) =\n        setup_client_with_mock_starknet_node(vec![ClassError]).await;\n    assert!(client\n        .getClass(\n            BlockId::BlockTag(BlockTag::Latest),\n            Felt::try_new(\"0x0\").unwrap()\n        )\n        .await\n        .is_err());\n}\n\n#[tokio::test]\nasync fn get_class_success() {\n    let (client, _starknet_node) =\n        setup_client_with_mock_starknet_node(vec![ClassSuccess]).await;\n    assert!(client\n        .getClass(\n            BlockId::BlockTag(BlockTag::Latest),\n            Felt::try_new(\"0x0\").unwrap()\n        )\n        .await\n        .is_ok());\n}\n\n#[tokio::test]\nasync fn spec_version_estimate_fee() {\n    let (client, _starknet_node) =\n        setup_client_with_mock_starknet_node(vec![SpecVersion, EstimateFee])\n            .await;\n    let tx = estimate_fee_transaction();\n    assert!(client.specVersion().await.is_ok());\n    let res = client\n        .estimateFee(vec![tx], vec![], BlockId::BlockTag(BlockTag::Latest))\n        .await;\n    assert!(res.is_ok());\n}\n\n#[tokio::test]\nasync fn add_declare_transaction() {\n    let tx = declare_transaction();\n    let (client, _starknet_node) =\n        setup_client_with_mock_starknet_node(vec![AddDeclareTransaction]).await;\n    assert!(client.addDeclareTransaction(tx).await.is_ok());\n}\n\n#[tokio::test]\nasync fn declare_account() {\n    let (client, _starknet_node) = setup_client_with_mock_starknet_node(vec![\n        ChainId,\n        ClassError,\n        ChainId,\n        Nonce,\n        SpecVersion,\n        EstimateFee,\n        AddDeclareTransaction,\n    ])\n    .await;\n    let block_id = BlockId::BlockTag(BlockTag::Latest);\n    let class_hash = Felt::try_new(\"0x0\").unwrap();\n    let contract_address = Address(class_hash.clone());\n    let estimate_tx = estimate_fee_transaction();\n    let declare_tx = declare_transaction();\n\n    assert!(client.chainId().await.is_ok());\n    assert!(client.getClass(block_id.clone(), class_hash).await.is_err());\n    assert!(client.chainId().await.is_ok());\n    assert!(client.getNonce(block_id.clone(), contract_address).await.is_ok());\n    assert!(client.specVersion().await.is_ok());\n    assert!(client\n        .estimateFee(vec![estimate_tx], vec![], block_id)\n        .await\n        .is_ok());\n    assert!(client.addDeclareTransaction(declare_tx).await.is_ok());\n}\n\n#[tokio::test]\nasync fn malicious_data_results_in_err() {\n    let (client, _starknet_node) = setup_client_with_mock_starknet_node(vec![\n        AddDeclareTransactionMalicious,\n        ChainIdMalicious,\n        ClassMalicious,\n        EstimateFeeMalicious,\n        NonceMalicious,\n        SpecVersionMalicious,\n    ])\n    .await;\n    let block_id = BlockId::BlockTag(BlockTag::Latest);\n    let class_hash = Felt::try_new(\"0x0\").unwrap();\n    let contract_address = Address(class_hash.clone());\n    let declare_tx = declare_transaction();\n    let estimate_tx = estimate_fee_transaction();\n\n    assert!(client.addDeclareTransaction(declare_tx).await.is_err());\n    assert!(client.chainId().await.is_err());\n    assert!(client\n        .estimateFee(vec![estimate_tx], vec![], block_id.clone())\n        .await\n        .is_err());\n    assert!(client.getClass(block_id.clone(), class_hash).await.is_err());\n    assert!(client.getNonce(block_id, contract_address).await.is_err());\n    assert!(client.specVersion().await.is_err());\n}\n\n#[tokio::test]\nasync fn deploy_account() {\n    let mut account_deploy: Vec\u003cStarknetMatcher\u003e =\n        vec![ChainId, Nonce, SpecVersion, EstimateFee];\n    let mut invoke_eth_transfer: Vec\u003cStarknetMatcher\u003e = vec![\n        ChainId,\n        ChainId,\n        Nonce,\n        SpecVersion,\n        EstimateFee,\n        AddInvokeTransaction,\n    ];\n    let mut account_deploy_last: Vec\u003cStarknetMatcher\u003e =\n        vec![Nonce, AddDeployAccountTransaction, GetTransactionReceipt];\n    account_deploy.append(\u0026mut invoke_eth_transfer);\n    account_deploy.append(\u0026mut account_deploy_last);\n    let (client, _starknet_node) =\n        setup_client_with_mock_starknet_node(account_deploy).await;\n    let block_id = BlockId::BlockTag(BlockTag::Latest);\n    let class_hash = Felt::try_new(\"0x0\").unwrap();\n    let contract_address = Address(class_hash.clone());\n    let estimate_tx = estimate_fee_transaction();\n    let invoke_tx = invoke_transaction();\n    let deploy_tx = deploy_transaction();\n    let tx_hash = TxnHash(class_hash);\n\n    assert!(client.chainId().await.is_ok());\n    assert!(client\n        .getNonce(block_id.clone(), contract_address.clone())\n        .await\n        .is_ok());\n    assert!(client.specVersion().await.is_ok());\n    assert!(client\n        .estimateFee(vec![estimate_tx.clone()], vec![], block_id.clone())\n        .await\n        .is_ok());\n\n    assert!(client.chainId().await.is_ok());\n    assert!(client.chainId().await.is_ok());\n    assert!(client\n        .getNonce(block_id.clone(), contract_address.clone())\n        .await\n        .is_ok());\n    assert!(client.specVersion().await.is_ok());\n    assert!(client\n        .estimateFee(vec![estimate_tx], vec![], block_id.clone())\n        .await\n        .is_ok());\n    assert!(client.addInvokeTransaction(invoke_tx).await.is_ok());\n    assert!(client.getNonce(block_id, contract_address).await.is_ok());\n    assert!(client.addDeployAccountTransaction(deploy_tx).await.is_ok());\n    assert!(client.getTransactionReceipt(tx_hash).await.is_ok());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","work","Work","Eiger","code","beerus","tests","common","ctx.rs"],"content":"use std::sync::Arc;\n\nuse beerus::client::{Http, State};\nuse beerus::gen::Felt;\nuse beerus::{\n    gen::client::Client,\n    rpc::{serve, Server},\n};\nuse tokio::sync::RwLock;\n\n#[allow(dead_code)] // used in macros\npub struct Context {\n    pub client: Client\u003cHttp\u003e,\n    pub server: Server,\n}\n\n#[allow(dead_code)]\npub async fn ctx_mainnet() -\u003e Option\u003cContext\u003e {\n    let url = std::env::var(\"STARKNET_MAINNET_URL\").ok()?;\n\n    let state = State {\n        block_number: 652076,\n        block_hash: Felt::try_new(\n            \"0x189fbe3beb92b93c74f3cdeeca9445ce0c889242ca8eb0be4eeaaa42a3b215a\",\n        )\n        .unwrap(),\n        root: Felt::try_new(\n            \"0x73be19f53a5f6daed7ac4f5111d75ed28f3b6ebbc51f058d3df3b47e51ffab9\",\n        )\n        .unwrap(),\n    };\n    ctx(url, state).await\n}\n\n#[allow(dead_code)]\npub async fn ctx_sepolia() -\u003e Option\u003cContext\u003e {\n    let url = std::env::var(\"STARKNET_SEPOLIA_URL\").ok()?;\n\n    let state = State {\n        block_number: 293268,\n        block_hash: Felt::try_new(\n            \"0x7799ec4953a1786e59e5ad02b4576cd59fa3b9efa059b7d56a9eb2b6ad6f2e\",\n        )\n        .unwrap(),\n        root: Felt::try_new(\n            \"0x54882b0dcb575e5e18bfac4c22b00f0cadcd83885d8c35b0b9d6e0e125ce3be\",\n        )\n        .unwrap(),\n    };\n    ctx(url, state).await\n}\n\n#[allow(dead_code)] // used in macros\nasync fn ctx(url: String, state: State) -\u003e Option\u003cContext\u003e {\n    let state = Arc::new(RwLock::new(state));\n    let server = serve(\u0026url, \"127.0.0.1:0\", state.clone()).await.ok()?;\n    tracing::info!(port = server.port(), \"test server is up\");\n\n    let url = format!(\"http://localhost:{}/rpc\", server.port());\n    let client = Client::new(\u0026url, Http::new());\n    Some(Context { server, client })\n}\n\n#[macro_export]\nmacro_rules! setup {\n    () =\u003e {\n        setup!(\"mainnet\")\n    };\n    ($e:expr) =\u003e {{\n        let run: bool = std::env::var(\"BEERUS_TEST_RUN\")\n            .ok()\n            .map(|value| \u0026value == \"1\")\n            .unwrap_or_default();\n        if !run {\n            return Ok(());\n        }\n        let context = match $e {\n            \"sepolia\" =\u003e common::ctx::ctx_sepolia().await,\n            \"mainnet\" =\u003e common::ctx::ctx_mainnet().await,\n            unknown =\u003e panic!(\"Unknown network: {unknown}. Supported networks: mainnet, sepolia\"),\n        };\n        if let Some(ctx) = context {\n            ctx\n        } else {\n            panic!(\"Invalid test setup\");\n        }\n    }};\n}\n\n#[macro_export]\nmacro_rules! client {\n    () =\u003e {{\n        let run: bool = std::env::var(\"BEERUS_TEST_RUN\")\n            .ok()\n            .map(|value| \u0026value == \"1\")\n            .unwrap_or_default();\n        if !run {\n            return Ok(());\n        }\n        if let Ok(url) = std::env::var(\"STARKNET_MAINNET_URL\") {\n            Client::new(\u0026url, beerus::client::Http::new())\n        } else {\n            panic!(\"Invalid test setup\");\n        }\n    }};\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","work","Work","Eiger","code","beerus","tests","common","err.rs"],"content":"use thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum Error {\n    #[error(\"rpc call failed: {0:?}\")]\n    Rpc(#[from] iamgroot::jsonrpc::Error),\n    #[error(\"missing env variable: {0:?}\")]\n    Var(#[from] std::env::VarError),\n    #[error(\"execution failed: {0:?}\")]\n    Exe(#[from] beerus::exe::err::Error),\n    #[error(\"serde failed: {0:?}\")]\n    Json(#[from] serde_json::Error),\n    #[error(\"starknet api error: {0:?}\")]\n    Api(#[from] starknet_api::StarknetApiError),\n    #[error(\"IO error: {0:?}\")]\n    IO(#[from] std::io::Error),\n    #[error(\"Anyhow error: {0:?}\")]\n    Anyhow(#[from] anyhow::Error),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","work","Work","Eiger","code","beerus","tests","common","mod.rs"],"content":"pub mod ctx;\npub mod err;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","work","Work","Eiger","code","beerus","tests","exe.rs"],"content":"use beerus::{\n    client::{Http, State},\n    exe::call,\n    gen::{self, blocking::Rpc, client::blocking::Client, FunctionCall},\n};\n\nmod common;\n\nuse common::err::Error;\n\n#[test]\nfn test_call_deprecated_contract_class() -\u003e Result\u003c(), Error\u003e {\n    let client = client!();\n\n    // TX: 0xcbb2b87d5378e682d650e0e7d36679b4557ba2bfa9d4e285b7168c04376b21\n    let json = serde_json::json!({\n      \"calldata\": [\n        \"0x2\",\n        \"0x57c4b510d66eb1188a7173f31cccee47b9736d40185da8144377b896d5ff3\",\n        \"0x2f0b3c5710379609eb5495f1ecd348cb28167711b73609fe565a72734550354\",\n        \"0x0\",\n        \"0x1\",\n        \"0x57c4b510d66eb1188a7173f31cccee47b9736d40185da8144377b896d5ff3\",\n        \"0x2f0b3c5710379609eb5495f1ecd348cb28167711b73609fe565a72734550354\",\n        \"0x1\",\n        \"0x1\",\n        \"0x2\",\n        \"0x0\",\n        \"0x1\"\n      ],\n      \"contract_address\": \"0x13e3ca9a377084c37dc7eacbd1d9f8c3e3733935bcbad887c32a0e213cd6fe0\",\n      \"entry_point_selector\": \"0x162da33a4585851fe8d3af3c2a9c60b557814e221e0d4f30ff0b2189d9c7775\"\n    });\n    let function_call: FunctionCall = serde_json::from_value(json)?;\n\n    let state = get_latest_state(\u0026client);\n    let call_info = call(client, function_call, state)?;\n\n    assert!(call_info.execution.retdata.0.is_empty());\n\n    Ok(())\n}\n\n#[test]\nfn test_call_regular_contract_class() -\u003e Result\u003c(), Error\u003e {\n    let client = client!();\n\n    let json = serde_json::json!({\n      \"calldata\": [],\n      \"contract_address\": \"0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n      \"entry_point_selector\": \"0x361458367e696363fbcc70777d07ebbd2394e89fd0adcaf147faccd1d294d60\"\n    });\n    let function_call: FunctionCall = serde_json::from_value(json)?;\n\n    let state = get_latest_state(\u0026client);\n    let call_info = call(client, function_call, state)?;\n\n    assert_eq!(call_info.execution.retdata.0.len(), 1);\n    assert_eq!(\n        call_info.execution.retdata.0[0].to_hex_string(),\n        \"0x4574686572\"\n    );\n\n    Ok(())\n}\n\nfn get_state(client: \u0026Client\u003cHttp\u003e, block_id: gen::BlockId) -\u003e State {\n    let block = client.getBlockWithTxHashes(block_id).unwrap();\n    let gen::GetBlockWithTxHashesResult::BlockWithTxHashes(block) = block\n    else {\n        panic!(\"Pending block received\");\n    };\n    State {\n        block_number: *block.block_header.block_number.as_ref() as u64,\n        block_hash: block.block_header.block_hash.0,\n        root: block.block_header.new_root,\n    }\n}\n\nfn get_latest_state(client: \u0026Client\u003cHttp\u003e) -\u003e State {\n    let block_id = gen::BlockId::BlockTag(gen::BlockTag::Latest);\n    get_state(client, block_id)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","work","Work","Eiger","code","beerus","tests","mock","dummies.rs"],"content":"use beerus::gen::{\n    Address, BroadcastedDeclareTxn, BroadcastedDeclareTxnV3,\n    BroadcastedDeclareTxnV3Type, BroadcastedDeclareTxnV3Version,\n    BroadcastedDeployAccountTxn, BroadcastedInvokeTxn, BroadcastedTxn,\n    ContractClass, ContractClassEntryPointsByType, DaMode, DeployAccountTxn,\n    DeployAccountTxnV3, DeployAccountTxnV3Type, DeployAccountTxnV3Version,\n    Felt, InvokeTxn, InvokeTxnV3, InvokeTxnV3Type, InvokeTxnV3Version,\n    ResourceBounds, ResourceBoundsMapping, SierraEntryPoint, U128, U64,\n};\n\n#[allow(dead_code)]\npub fn declare_transaction() -\u003e BroadcastedDeclareTxn {\n    BroadcastedDeclareTxn::BroadcastedDeclareTxnV3(\n        dummy_declare_transaction_v3(),\n    )\n}\n\n#[allow(dead_code)]\npub fn estimate_fee_transaction() -\u003e BroadcastedTxn {\n    BroadcastedTxn::BroadcastedDeclareTxn(\n        BroadcastedDeclareTxn::BroadcastedDeclareTxnV3(\n            dummy_declare_transaction_v3(),\n        ),\n    )\n}\n\n#[allow(dead_code)]\npub fn invoke_transaction() -\u003e BroadcastedInvokeTxn {\n    BroadcastedInvokeTxn(InvokeTxn::InvokeTxnV3(dummy_invoke_transaction_v3()))\n}\n\n#[allow(dead_code)]\npub fn deploy_transaction() -\u003e BroadcastedDeployAccountTxn {\n    BroadcastedDeployAccountTxn(DeployAccountTxn::DeployAccountTxnV3(\n        dummy_deploy_transaction_v3(),\n    ))\n}\n\n#[allow(dead_code)]\nfn dummy_declare_transaction_v3() -\u003e BroadcastedDeclareTxnV3 {\n    BroadcastedDeclareTxnV3 {\n        account_deployment_data: vec![Felt::try_new(\"0x0\").unwrap()],\n        compiled_class_hash: Felt::try_new(\"0x0\").unwrap(),\n        contract_class: ContractClass {\n            sierra_program: vec![Felt::try_new(\"0x1\").unwrap()],\n            contract_class_version: \"0.1.0\".to_string(),\n            entry_points_by_type: ContractClassEntryPointsByType {\n                constructor: vec![SierraEntryPoint {\n                    selector: Felt::try_new(\"0x2\").unwrap(),\n                    function_idx: 2,\n                }],\n                external: vec![\n                    SierraEntryPoint {\n                        selector: Felt::try_new(\"0x3\").unwrap(),\n                        function_idx: 3,\n                    },\n                    SierraEntryPoint {\n                        selector: Felt::try_new(\"0x4\").unwrap(),\n                        function_idx: 4,\n                    },\n                ],\n                l1_handler: vec![],\n            },\n            abi: Some(\"some_abi\".to_string()),\n        },\n        fee_data_availability_mode: DaMode::L1,\n        nonce: Felt::try_new(\"0x0\").unwrap(),\n        r#type: BroadcastedDeclareTxnV3Type::Declare,\n        signature: vec![Felt::try_new(\"0x5\").unwrap()],\n        sender_address: Address(Felt::try_new(\"0x6\").unwrap()),\n        version:\n            BroadcastedDeclareTxnV3Version::V0x100000000000000000000000000000003,\n        nonce_data_availability_mode: DaMode::L1,\n        paymaster_data: vec![Felt::try_new(\"0x7\").unwrap()],\n        resource_bounds: ResourceBoundsMapping {\n            l1_gas: ResourceBounds {\n                max_amount: U64::try_new(\"0x0\").unwrap(),\n                max_price_per_unit: U128::try_new(\"0x0\").unwrap(),\n            },\n            l2_gas: ResourceBounds {\n                max_amount: U64::try_new(\"0x0\").unwrap(),\n                max_price_per_unit: U128::try_new(\"0x0\").unwrap(),\n            },\n        },\n        tip: U64::try_new(\"0x0\").unwrap(),\n    }\n}\n\n#[allow(dead_code)]\nfn dummy_invoke_transaction_v3() -\u003e InvokeTxnV3 {\n    InvokeTxnV3 {\n        account_deployment_data: vec![Felt::try_new(\"0x0\").unwrap()],\n        calldata: vec![Felt::try_new(\"0x1\").unwrap()],\n        fee_data_availability_mode: DaMode::L1,\n        nonce: Felt::try_new(\"0x2\").unwrap(),\n        nonce_data_availability_mode: DaMode::L1,\n        paymaster_data: vec![Felt::try_new(\"0x1\").unwrap()],\n        r#type: InvokeTxnV3Type::Invoke,\n        resource_bounds: ResourceBoundsMapping {\n            l1_gas: ResourceBounds {\n                max_amount: U64::try_new(\"0x0\").unwrap(),\n                max_price_per_unit: U128::try_new(\"0x0\").unwrap(),\n            },\n            l2_gas: ResourceBounds {\n                max_amount: U64::try_new(\"0x0\").unwrap(),\n                max_price_per_unit: U128::try_new(\"0x0\").unwrap(),\n            },\n        },\n        sender_address: Address(Felt::try_new(\"0x3\").unwrap()),\n        signature: vec![Felt::try_new(\"0x4\").unwrap()],\n        tip: U64::try_new(\"0x0\").unwrap(),\n        version: InvokeTxnV3Version::V0x3,\n    }\n}\n\n#[allow(dead_code)]\nfn dummy_deploy_transaction_v3() -\u003e DeployAccountTxnV3 {\n    DeployAccountTxnV3 {\n        class_hash: Felt::try_new(\"0x0\").unwrap(),\n        constructor_calldata: vec![Felt::try_new(\"0x1\").unwrap()],\n        contract_address_salt: Felt::try_new(\"0x2\").unwrap(),\n        fee_data_availability_mode: DaMode::L1,\n        nonce: Felt::try_new(\"0x3\").unwrap(),\n        nonce_data_availability_mode: DaMode::L1,\n        paymaster_data: vec![Felt::try_new(\"0x4\").unwrap()],\n        r#type: DeployAccountTxnV3Type::DeployAccount,\n        resource_bounds: ResourceBoundsMapping {\n            l1_gas: ResourceBounds {\n                max_amount: U64::try_new(\"0x0\").unwrap(),\n                max_price_per_unit: U128::try_new(\"0x0\").unwrap(),\n            },\n            l2_gas: ResourceBounds {\n                max_amount: U64::try_new(\"0x0\").unwrap(),\n                max_price_per_unit: U128::try_new(\"0x0\").unwrap(),\n            },\n        },\n        signature: vec![Felt::try_new(\"0x5\").unwrap()],\n        tip: U64::try_new(\"0x0\").unwrap(),\n        version: DeployAccountTxnV3Version::V0x3,\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","work","Work","Eiger","code","beerus","tests","mock","matchers.rs"],"content":"use iamgroot::jsonrpc;\nuse serde_json::Value;\nuse wiremock::{Match, Request};\n\n#[allow(dead_code)]\n#[derive(Eq, Hash, PartialEq)]\npub enum StarknetMatcher {\n    AddDeclareTransaction,\n    AddDeclareTransactionMalicious,\n    AddDeployAccountTransaction,\n    AddInvokeTransaction,\n    ChainId,\n    ChainIdMalicious,\n    ClassError,\n    ClassSuccess,\n    ClassMalicious,\n    EstimateFee,\n    EstimateFeeMalicious,\n    GetTransactionReceipt,\n    Nonce,\n    NonceMalicious,\n    SpecVersion,\n    SpecVersionMalicious,\n}\n\npub trait Response {\n    fn response(\u0026self) -\u003e Value;\n}\n\npub struct ChainIdMatcher {\n    pub response: Value,\n}\n\nimpl ChainIdMatcher {\n    pub fn malicious() -\u003e Self {\n        Self {\n            response: serde_json::json!(\n            {\n                \"jsonrpc\": \"2.0\",\n                \"id\": 1,\n                \"result\": \"malicious_result\"\n            }),\n        }\n    }\n}\n\nimpl Default for ChainIdMatcher {\n    fn default() -\u003e Self {\n        Self {\n            response: serde_json::json!(\n            {\n                \"jsonrpc\": \"2.0\",\n                \"id\": 1,\n                \"result\": \"0x4b4154414e41\"\n            }),\n        }\n    }\n}\n\nimpl Response for ChainIdMatcher {\n    fn response(\u0026self) -\u003e Value {\n        self.response.clone()\n    }\n}\n\nimpl Match for ChainIdMatcher {\n    fn matches(\u0026self, request: \u0026Request) -\u003e bool {\n        let request = request.body_json::\u003cjsonrpc::Request\u003e().unwrap();\n        matches!(request.method.as_str(), \"starknet_chainId\")\n    }\n}\n\npub struct NonceMatcher {\n    pub response: Value,\n}\n\nimpl NonceMatcher {\n    pub fn malicious() -\u003e Self {\n        Self {\n            response: serde_json::json!(\n            {\n                \"jsonrpc\": \"2.0\",\n                \"id\": 1,\n                \"result\": \"malicious_result\"\n            }),\n        }\n    }\n}\n\nimpl Default for NonceMatcher {\n    fn default() -\u003e Self {\n        Self {\n            response: serde_json::json!(\n            {\n                \"jsonrpc\": \"2.0\",\n                \"id\": 1,\n                \"result\": \"0x0\"\n            }),\n        }\n    }\n}\n\nimpl Match for NonceMatcher {\n    fn matches(\u0026self, request: \u0026Request) -\u003e bool {\n        let request = request.body_json::\u003cjsonrpc::Request\u003e().unwrap();\n        matches!(request.method.as_str(), \"starknet_getNonce\")\n    }\n}\n\nimpl Response for NonceMatcher {\n    fn response(\u0026self) -\u003e Value {\n        self.response.clone()\n    }\n}\n\npub struct ClassMatcher {\n    pub response: Value,\n}\n\nimpl ClassMatcher {\n    pub fn error() -\u003e Self {\n        Self {\n            response: serde_json::json!(\n            {\n                \"jsonrpc\": \"2.0\",\n                \"id\": 1,\n                \"error\": {\n                    \"code\": 28,\n                    \"message\": \"Class hash not found\"\n                }\n            }),\n        }\n    }\n\n    pub fn success() -\u003e Self {\n        Self {\n            response: serde_json::json!(\n            {\n                \"jsonrpc\": \"2.0\",\n                \"id\": 1,\n                \"result\": {\n                    \"sierra_program\": [\"0x1\"],\n                    \"contract_class_version\": \"0.1.0\",\n                    \"entry_points_by_type\": {\n                        \"CONSTRUCTOR\": [{\n                            \"selector\": \"0x2\",\n                            \"function_idx\": 2,\n                        }],\n                        \"EXTERNAL\": [{\n                            \"selector\": \"0x3\",\n                            \"function_idx\": 3,\n                        }, {\n                            \"selector\": \"0x4\",\n                            \"function_idx\": 4,\n                        }],\n                        \"L1_HANDLER\": [],\n                    },\n                    \"abi\": \"some_abi\"\n                }\n            }),\n        }\n    }\n\n    pub fn malicious() -\u003e Self {\n        Self {\n            response: serde_json::json!(\n            {\n                \"jsonrpc\": \"2.0\",\n                \"id\": 1,\n                \"result\": \"malicious\"\n            }),\n        }\n    }\n}\n\nimpl Match for ClassMatcher {\n    fn matches(\u0026self, request: \u0026Request) -\u003e bool {\n        let request = request.body_json::\u003cjsonrpc::Request\u003e().unwrap();\n        matches!(request.method.as_str(), \"starknet_getClass\")\n    }\n}\n\nimpl Response for ClassMatcher {\n    fn response(\u0026self) -\u003e Value {\n        self.response.clone()\n    }\n}\n\npub struct SpecVersionMatcher {\n    pub response: Value,\n}\n\nimpl SpecVersionMatcher {\n    pub fn malicious() -\u003e Self {\n        Self {\n            response: serde_json::json!(\n            {\n                \"jsonrpc\": \"2.0\",\n                \"id\": 1,\n                \"result\": 42\n            }),\n        }\n    }\n}\n\nimpl Default for SpecVersionMatcher {\n    fn default() -\u003e Self {\n        Self {\n            response: serde_json::json!(\n            {\n                \"jsonrpc\": \"2.0\",\n                \"id\": 1,\n                \"result\": \"0.6.0\"\n            }),\n        }\n    }\n}\n\nimpl Match for SpecVersionMatcher {\n    fn matches(\u0026self, request: \u0026Request) -\u003e bool {\n        let request = request.body_json::\u003cjsonrpc::Request\u003e().unwrap();\n        matches!(request.method.as_str(), \"starknet_specVersion\")\n    }\n}\n\nimpl Response for SpecVersionMatcher {\n    fn response(\u0026self) -\u003e Value {\n        self.response.clone()\n    }\n}\n\npub struct EstimateFeeMatcher {\n    pub response: Value,\n}\n\nimpl EstimateFeeMatcher {\n    pub fn malicious() -\u003e Self {\n        Self {\n            response: serde_json::json!(\n            {\n                \"jsonrpc\": \"2.0\",\n                \"id\": 1,\n                \"result\": \"malicious\"\n            }),\n        }\n    }\n}\n\nimpl Default for EstimateFeeMatcher {\n    fn default() -\u003e Self {\n        Self {\n            response: serde_json::json!(\n            {\n                \"jsonrpc\": \"2.0\",\n                \"id\": 1,\n                \"result\": [{\n                    \"gas_consumed\": \"0x18bf\",\n                    \"gas_price\": \"0x174876e800\",\n                    \"overall_fee\": \"0x2402a36771800\",\n                    \"unit\": \"WEI\"\n                }]\n            }),\n        }\n    }\n}\n\nimpl Match for EstimateFeeMatcher {\n    fn matches(\u0026self, request: \u0026Request) -\u003e bool {\n        let request = request.body_json::\u003cjsonrpc::Request\u003e().unwrap();\n        matches!(request.method.as_str(), \"starknet_estimateFee\")\n    }\n}\n\nimpl Response for EstimateFeeMatcher {\n    fn response(\u0026self) -\u003e Value {\n        self.response.clone()\n    }\n}\n\npub struct AddDeclareTransactionMatcher {\n    pub response: Value,\n}\n\nimpl AddDeclareTransactionMatcher {\n    pub fn malicious() -\u003e Self {\n        Self {\n            response: serde_json::json!(\n            {\n                \"jsonrpc\": \"2.0\",\n                \"id\": 1,\n                \"result\": 42\n            }),\n        }\n    }\n}\n\nimpl Default for AddDeclareTransactionMatcher {\n    fn default() -\u003e Self {\n        Self {\n            response: serde_json::json!(\n            {\n                \"jsonrpc\": \"2.0\",\n                \"id\": 1,\n                \"result\": {\n                    \"transaction_hash\": \"0x0\",\n                    \"class_hash\": \"0x1\",\n                }\n            }),\n        }\n    }\n}\n\nimpl Match for AddDeclareTransactionMatcher {\n    fn matches(\u0026self, request: \u0026Request) -\u003e bool {\n        let request = request.body_json::\u003cjsonrpc::Request\u003e().unwrap();\n        matches!(request.method.as_str(), \"starknet_addDeclareTransaction\")\n    }\n}\n\nimpl Response for AddDeclareTransactionMatcher {\n    fn response(\u0026self) -\u003e Value {\n        self.response.clone()\n    }\n}\n\npub struct AddInvokeTransactionMatcher {\n    pub response: Value,\n}\n\nimpl Default for AddInvokeTransactionMatcher {\n    fn default() -\u003e Self {\n        Self {\n            response: serde_json::json!(\n            {\n                \"jsonrpc\": \"2.0\",\n                \"id\": 1,\n                \"result\": {\n                    \"transaction_hash\": \"0x0\",\n                }\n            }),\n        }\n    }\n}\n\nimpl Match for AddInvokeTransactionMatcher {\n    fn matches(\u0026self, request: \u0026Request) -\u003e bool {\n        let request = request.body_json::\u003cjsonrpc::Request\u003e().unwrap();\n        matches!(request.method.as_str(), \"starknet_addInvokeTransaction\")\n    }\n}\n\nimpl Response for AddInvokeTransactionMatcher {\n    fn response(\u0026self) -\u003e Value {\n        self.response.clone()\n    }\n}\n\npub struct AddDeployAccountTransactionMatcher {\n    pub response: Value,\n}\n\nimpl Default for AddDeployAccountTransactionMatcher {\n    fn default() -\u003e Self {\n        Self {\n            response: serde_json::json!(\n            {\n                \"jsonrpc\": \"2.0\",\n                \"id\": 1,\n                \"result\": {\n                    \"contract_address\": \"0x0\",\n                    \"transaction_hash\": \"0x0\",\n                }\n            }),\n        }\n    }\n}\n\nimpl Match for AddDeployAccountTransactionMatcher {\n    fn matches(\u0026self, request: \u0026Request) -\u003e bool {\n        let request = request.body_json::\u003cjsonrpc::Request\u003e().unwrap();\n        matches!(\n            request.method.as_str(),\n            \"starknet_addDeployAccountTransaction\"\n        )\n    }\n}\n\nimpl Response for AddDeployAccountTransactionMatcher {\n    fn response(\u0026self) -\u003e Value {\n        self.response.clone()\n    }\n}\n\npub struct GetTransactionReceiptMatcher {\n    pub response: Value,\n}\n\nimpl Default for GetTransactionReceiptMatcher {\n    fn default() -\u003e Self {\n        Self {\n            response: serde_json::json!(\n            {\n                \"jsonrpc\":\"2.0\",\n                \"result\": {\n                    \"transaction_hash\":\"0x1\",\n                    \"actual_fee\": {\n                        \"amount\":\"0x2\",\n                        \"unit\":\"WEI\"\n                    },\n                    \"finality_status\":\"ACCEPTED_ON_L2\",\n                    \"messages_sent\":[],\n                    \"events\":[{\n                        \"from_address\":\"0x3\",\n                        \"keys\":[\n                            \"0x4\"\n                        ],\n                        \"data\":[\n                            \"0x5\",\n                            \"0x6\",\n                            \"0x7\",\n                            \"0x8\"\n                        ]\n                    }],\n                    \"execution_resources\": {\n                        \"steps\": 1,\n                        \"memory_holes\": 2,\n                        \"range_check_builtin_applications\": 3,\n                        \"pedersen_builtin_applications\": 4,\n                        \"ec_op_builtin_applications\": 5,\n                        \"data_availability\": {\n                            \"l1_gas\": 6,\n                            \"l1_data_gas\": 7\n                        }\n                    },\n                    \"execution_status\":\"SUCCEEDED\",\n                    \"type\":\"DEPLOY_ACCOUNT\",\n                    \"contract_address\":\"0x9\",\n                    \"block_hash\":\"0x10\",\n                    \"block_number\":8\n                },\n                \"id\":1\n            }),\n        }\n    }\n}\n\nimpl Match for GetTransactionReceiptMatcher {\n    fn matches(\u0026self, request: \u0026Request) -\u003e bool {\n        let request = request.body_json::\u003cjsonrpc::Request\u003e().unwrap();\n        matches!(request.method.as_str(), \"starknet_getTransactionReceipt\")\n    }\n}\n\nimpl Response for GetTransactionReceiptMatcher {\n    fn response(\u0026self) -\u003e Value {\n        self.response.clone()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","work","Work","Eiger","code","beerus","tests","mock","mod.rs"],"content":"pub mod dummies;\npub mod matchers;\npub mod node;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","work","Work","Eiger","code","beerus","tests","mock","node.rs"],"content":"use std::collections::HashMap;\n\nuse beerus::{client::Http, gen::client::Client};\nuse wiremock::{Match, Mock, MockGuard, MockServer, ResponseTemplate};\n\nuse super::matchers::{\n    AddDeclareTransactionMatcher, AddDeployAccountTransactionMatcher,\n    AddInvokeTransactionMatcher, ChainIdMatcher, ClassMatcher,\n    EstimateFeeMatcher, GetTransactionReceiptMatcher, NonceMatcher, Response,\n    SpecVersionMatcher, StarknetMatcher,\n};\n\n#[allow(dead_code)]\npub async fn setup_client_with_mock_starknet_node(\n    methods: Vec\u003cStarknetMatcher\u003e,\n) -\u003e (Client\u003cHttp\u003e, StarknetNode) {\n    let mut starknet_node = StarknetNode::new().await;\n    let mut map_methods = HashMap::new();\n    for method in methods {\n        *map_methods.entry(method).or_insert(0) += 1;\n    }\n    starknet_node.add_methods(map_methods).await;\n    let client = Client::new(\u0026starknet_node.server.uri(), Http::new());\n    (client, starknet_node)\n}\n\npub struct StarknetNode {\n    pub server: MockServer,\n    pub mock_guard: Vec\u003cMockGuard\u003e,\n}\n\nimpl StarknetNode {\n    pub async fn new() -\u003e Self {\n        let server = MockServer::start().await;\n        Self { server, mock_guard: vec![] }\n    }\n\n    pub async fn add_methods(\n        \u0026mut self,\n        requests: HashMap\u003cStarknetMatcher, u64\u003e,\n    ) {\n        let mut vec_mock_guards = Vec::with_capacity(requests.len());\n        for (request, num_request) in requests.into_iter() {\n            let mock_guard = match request {\n                StarknetMatcher::AddDeclareTransaction =\u003e {\n                    self.create_mock_guard(\n                        AddDeclareTransactionMatcher::default(),\n                        num_request,\n                    )\n                    .await\n                }\n                StarknetMatcher::AddDeclareTransactionMalicious =\u003e {\n                    self.create_mock_guard(\n                        AddDeclareTransactionMatcher::malicious(),\n                        num_request,\n                    )\n                    .await\n                }\n                StarknetMatcher::AddDeployAccountTransaction =\u003e {\n                    self.create_mock_guard(\n                        AddDeployAccountTransactionMatcher::default(),\n                        num_request,\n                    )\n                    .await\n                }\n                StarknetMatcher::AddInvokeTransaction =\u003e {\n                    self.create_mock_guard(\n                        AddInvokeTransactionMatcher::default(),\n                        num_request,\n                    )\n                    .await\n                }\n                StarknetMatcher::ClassError =\u003e {\n                    self.create_mock_guard(ClassMatcher::error(), num_request)\n                        .await\n                }\n                StarknetMatcher::ClassSuccess =\u003e {\n                    self.create_mock_guard(ClassMatcher::success(), num_request)\n                        .await\n                }\n                StarknetMatcher::ClassMalicious =\u003e {\n                    self.create_mock_guard(\n                        ClassMatcher::malicious(),\n                        num_request,\n                    )\n                    .await\n                }\n                StarknetMatcher::ChainId =\u003e {\n                    self.create_mock_guard(\n                        ChainIdMatcher::default(),\n                        num_request,\n                    )\n                    .await\n                }\n                StarknetMatcher::ChainIdMalicious =\u003e {\n                    self.create_mock_guard(\n                        ChainIdMatcher::malicious(),\n                        num_request,\n                    )\n                    .await\n                }\n                StarknetMatcher::EstimateFee =\u003e {\n                    self.create_mock_guard(\n                        EstimateFeeMatcher::default(),\n                        num_request,\n                    )\n                    .await\n                }\n                StarknetMatcher::EstimateFeeMalicious =\u003e {\n                    self.create_mock_guard(\n                        EstimateFeeMatcher::malicious(),\n                        num_request,\n                    )\n                    .await\n                }\n                StarknetMatcher::GetTransactionReceipt =\u003e {\n                    self.create_mock_guard(\n                        GetTransactionReceiptMatcher::default(),\n                        num_request,\n                    )\n                    .await\n                }\n                StarknetMatcher::Nonce =\u003e {\n                    self.create_mock_guard(NonceMatcher::default(), num_request)\n                        .await\n                }\n                StarknetMatcher::NonceMalicious =\u003e {\n                    self.create_mock_guard(\n                        NonceMatcher::malicious(),\n                        num_request,\n                    )\n                    .await\n                }\n                StarknetMatcher::SpecVersion =\u003e {\n                    self.create_mock_guard(\n                        SpecVersionMatcher::default(),\n                        num_request,\n                    )\n                    .await\n                }\n                StarknetMatcher::SpecVersionMalicious =\u003e {\n                    self.create_mock_guard(\n                        SpecVersionMatcher::malicious(),\n                        num_request,\n                    )\n                    .await\n                }\n            };\n            vec_mock_guards.push(mock_guard);\n        }\n        self.mock_guard = vec_mock_guards;\n    }\n\n    async fn create_mock_guard(\n        \u0026self,\n        matcher: impl Match + Response + 'static,\n        num_request: u64,\n    ) -\u003e MockGuard {\n        let response = matcher.response();\n        Mock::given(matcher)\n            .respond_with(ResponseTemplate::new(200).set_body_json(response))\n            .expect(num_request)\n            .mount_as_scoped(\u0026self.server)\n            .await\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","work","Work","Eiger","code","beerus","tests","rpc.rs"],"content":"use std::{thread, time};\n\nuse beerus::{\n    config::MAINNET_STARKNET_CHAINID,\n    gen::{\n        Address, BlockHash, BlockId, BlockNumber, BlockTag,\n        BroadcastedInvokeTxn, BroadcastedTxn, Felt, FunctionCall,\n        GetBlockWithTxHashesResult, GetBlockWithTxsResult, GetClassAtResult,\n        GetClassResult, GetTransactionByBlockIdAndIndexIndex, InvokeTxn,\n        InvokeTxnV1, InvokeTxnV1Version, PriceUnit, Rpc, StorageKey,\n        SyncingResult, Txn, TxnExecutionStatus, TxnHash, TxnReceipt,\n        TxnReceiptWithBlockInfo, TxnStatus,\n    },\n};\n\nmod common;\nmod starknet;\n\nuse common::err::Error;\nuse starknet::{\n    scarb,\n    starkli::{PreFundedAccount, Starkli},\n    utils,\n};\n\n#[tokio::test]\n#[allow(non_snake_case)]\nasync fn test_specVersion() -\u003e Result\u003c(), Error\u003e {\n    let ctx = setup!();\n\n    let ret = ctx.client.specVersion().await?;\n    assert_eq!(ret, \"0.7.1\");\n    Ok(())\n}\n\n#[tokio::test]\n#[allow(non_snake_case)]\nasync fn test_chainId() -\u003e Result\u003c(), Error\u003e {\n    let ctx = setup!();\n\n    let ret = ctx.client.chainId().await?;\n    assert_eq!(ret.as_ref(), MAINNET_STARKNET_CHAINID);\n    Ok(())\n}\n\n#[tokio::test]\n#[allow(non_snake_case)]\nasync fn test_blockHashAndNumber() -\u003e Result\u003c(), Error\u003e {\n    let ctx = setup!();\n\n    let ret = ctx.client.blockHashAndNumber().await?;\n    assert!(*ret.block_number.as_ref() \u003e 600612);\n    assert!(!ret.block_hash.0.as_ref().is_empty());\n    Ok(())\n}\n\n#[tokio::test]\n#[allow(non_snake_case)]\nasync fn test_blockNumber() -\u003e Result\u003c(), Error\u003e {\n    let ctx = setup!();\n\n    let ret = ctx.client.blockNumber().await?;\n    assert!(*ret.as_ref() \u003e 600612);\n    Ok(())\n}\n\n#[tokio::test]\n#[allow(non_snake_case)]\nasync fn test_estimateFee() -\u003e Result\u003c(), Error\u003e {\n    let ctx = setup!();\n\n    let calldata = vec![\n        \"0x2\",\n        \"0x57c4b510d66eb1188a7173f31cccee47b9736d40185da8144377b896d5ff3\",\n        \"0x2f0b3c5710379609eb5495f1ecd348cb28167711b73609fe565a72734550354\",\n        \"0x0\",\n        \"0x1\",\n        \"0x57c4b510d66eb1188a7173f31cccee47b9736d40185da8144377b896d5ff3\",\n        \"0x2f0b3c5710379609eb5495f1ecd348cb28167711b73609fe565a72734550354\",\n        \"0x1\",\n        \"0x1\",\n        \"0x2\",\n        \"0x0\",\n        \"0x1\",\n    ];\n    let calldata: Result\u003cVec\u003cFelt\u003e, _\u003e =\n        calldata.into_iter().map(Felt::try_new).collect();\n\n    let signature = vec![\n        \"0x42527ffe9912b338983cbed67e139cfcc26a4d8cf1d1c2a85e4125fdf5f59ed\",\n        \"0x636147d06fefd02ed37984b752556d4b9aefdac1a50b3df0528ec7c201ad84b\",\n    ];\n    let signature: Result\u003cVec\u003cFelt\u003e, _\u003e =\n        signature.into_iter().map(Felt::try_new).collect();\n\n    let request = vec![\n        BroadcastedTxn::BroadcastedInvokeTxn(\n            BroadcastedInvokeTxn(\n                InvokeTxn::InvokeTxnV1(\n                    InvokeTxnV1 {\n                        calldata: calldata?,\n                        signature: signature?,\n                        sender_address: Address(Felt::try_new(\"0x13e3ca9a377084c37dc7eacbd1d9f8c3e3733935bcbad887c32a0e213cd6fe0\")?), \n                        max_fee: Felt::try_new(\"0x28ed6103d0000\")?, \n                        nonce: Felt::try_new(\"0x1\")?,\n                        version: InvokeTxnV1Version::V0x1,\n                        r#type: beerus::gen::InvokeTxnV1Type::Invoke, \n                    }\n                )\n            )\n        )\n    ];\n\n    let simulation_flags = vec![];\n\n    let block_id =\n        BlockId::BlockNumber { block_number: BlockNumber::try_new(59999)? };\n\n    let ret =\n        ctx.client.estimateFee(request, simulation_flags, block_id).await?;\n    assert_eq!(ret.len(), 1);\n    assert_eq!(ret[0].overall_fee.as_ref(), \"0x1abd7b153e472\");\n    assert_eq!(ret[0].gas_price.as_ref(), \"0x67edb4f57\");\n    assert_eq!(ret[0].gas_consumed.as_ref(), \"0x41de\");\n    assert!(matches!(ret[0].unit, PriceUnit::Wei));\n    Ok(())\n}\n\n#[tokio::test]\n#[allow(non_snake_case)]\nasync fn test_getBlockTransactionCount() -\u003e Result\u003c(), Error\u003e {\n    let ctx = setup!();\n\n    let block_id = BlockId::BlockTag(BlockTag::Latest);\n\n    let ret = ctx.client.getBlockTransactionCount(block_id).await?;\n    assert!(*ret.as_ref() \u003e 0);\n    Ok(())\n}\n\n#[tokio::test]\n#[allow(non_snake_case)]\nasync fn test_getBlockWithTxHashes() -\u003e Result\u003c(), Error\u003e {\n    let ctx = setup!();\n\n    let block_id = BlockId::BlockTag(BlockTag::Latest);\n\n    let ret = ctx.client.getBlockWithTxHashes(block_id).await?;\n    assert!(matches!(ret, GetBlockWithTxHashesResult::BlockWithTxHashes(_)));\n    let GetBlockWithTxHashesResult::BlockWithTxHashes(ret) = ret else {\n        panic!(\"unexpected pending block\");\n    };\n    assert!(!ret.block_body_with_tx_hashes.transactions.is_empty());\n    Ok(())\n}\n\n#[tokio::test]\n#[allow(non_snake_case)]\nasync fn test_getBlockWithTxs() -\u003e Result\u003c(), Error\u003e {\n    let ctx = setup!();\n\n    let block_id = BlockId::BlockTag(BlockTag::Latest);\n\n    let ret = ctx.client.getBlockWithTxs(block_id).await?;\n    assert!(matches!(ret, GetBlockWithTxsResult::BlockWithTxs(_)));\n    let GetBlockWithTxsResult::BlockWithTxs(ret) = ret else {\n        panic!(\"unexpected pending block\");\n    };\n    assert!(!ret.block_body_with_txs.transactions.is_empty());\n    Ok(())\n}\n\n#[tokio::test]\n#[allow(non_snake_case)]\nasync fn test_syncing() -\u003e Result\u003c(), Error\u003e {\n    let ctx = setup!();\n\n    let ret = ctx.client.syncing().await?;\n    assert!(matches!(ret, SyncingResult::SyncStatus(_)));\n    Ok(())\n}\n\n#[tokio::test]\n#[allow(non_snake_case)]\nasync fn test_getNonce() -\u003e Result\u003c(), Error\u003e {\n    let ctx = setup!();\n\n    let block_id = BlockId::BlockTag(BlockTag::Latest);\n\n    let address = Address(Felt::try_new(\n        \"0x10b6c96d364cf182964fbd4a3438a5ae84cab990770c07994f9cb99fd26f6dc\",\n    )?);\n\n    let ret = ctx.client.getNonce(block_id, address).await?;\n    assert!(!ret.as_ref().is_empty());\n    Ok(())\n}\n\n#[tokio::test]\n#[allow(non_snake_case)]\nasync fn test_getTransactionByHash() -\u003e Result\u003c(), Error\u003e {\n    let ctx = setup!();\n\n    let hash =\n        \"0x2e2a98c1731ece2691edfbb4ed9b057182cec569735bd89825f17e3b342583a\";\n\n    let transaction_hash = TxnHash(Felt::try_new(hash)?);\n\n    let ret = ctx.client.getTransactionByHash(transaction_hash).await?;\n    assert!(matches!(ret.txn, Txn::InvokeTxn(InvokeTxn::InvokeTxnV1(_))));\n    assert_eq!(ret.transaction_hash.0.as_ref(), hash);\n    Ok(())\n}\n\n#[tokio::test]\n#[allow(non_snake_case)]\nasync fn test_getTransactionByBlockIdAndIndex() -\u003e Result\u003c(), Error\u003e {\n    let ctx = setup!();\n\n    let block_id = BlockId::BlockTag(BlockTag::Latest);\n\n    let index = GetTransactionByBlockIdAndIndexIndex::try_new(0)?;\n\n    let ret =\n        ctx.client.getTransactionByBlockIdAndIndex(block_id, index).await?;\n    assert!(!ret.transaction_hash.0.as_ref().is_empty());\n    Ok(())\n}\n\n#[tokio::test]\n#[allow(non_snake_case)]\nasync fn test_getStorageAt() -\u003e Result\u003c(), Error\u003e {\n    let ctx = setup!();\n\n    let contract_address = Address(Felt::try_new(\n        \"0x6a05844a03bb9e744479e3298f54705a35966ab04140d3d8dd797c1f6dc49d0\",\n    )?);\n\n    let key = StorageKey::try_new(\n        \"0x0341c1bdfd89f69748aa00b5742b03adbffd79b8e80cab5c50d91cd8c2a79be1\",\n    )?;\n\n    const EXPECTED: \u0026str = \"0x47616d65206f66204c69666520546f6b656e\";\n\n    let block_id_number =\n        BlockId::BlockNumber { block_number: BlockNumber::try_new(600612)? };\n    let ret = ctx\n        .client\n        .getStorageAt(contract_address.clone(), key.clone(), block_id_number)\n        .await?;\n    assert_eq!(ret.as_ref(), EXPECTED);\n\n    let block_id_hash = BlockId::BlockHash {\n        block_hash: BlockHash(Felt::try_new(\n            \"0x1cbed30c5f1eb355f13e69562eda81b3f3edd5b46d5ef261ce5f24de55f0bdb\",\n        )?),\n    };\n    let ret = ctx\n        .client\n        .getStorageAt(contract_address.clone(), key.clone(), block_id_hash)\n        .await?;\n    assert_eq!(ret.as_ref(), EXPECTED);\n\n    let block_id_tag = BlockId::BlockTag(BlockTag::Latest);\n    let ret = ctx\n        .client\n        .getStorageAt(contract_address.clone(), key.clone(), block_id_tag)\n        .await?;\n    assert_eq!(ret.as_ref(), EXPECTED);\n\n    let block_id_tag = BlockId::BlockTag(BlockTag::Pending);\n    let ret =\n        ctx.client.getStorageAt(contract_address, key, block_id_tag).await;\n    assert!(ret.is_err());\n    Ok(())\n}\n\n#[tokio::test]\n#[allow(non_snake_case)]\nasync fn test_getProof() -\u003e Result\u003c(), Error\u003e {\n    let ctx = setup!();\n\n    let contract_address = Address(Felt::try_new(\n        \"0x49D36570D4e46f48e99674bd3fcc84644DdD6b96F7C741B1562B82f9e004dC7\",\n    )?);\n\n    let key = StorageKey::try_new(\n        \"0x02c401056f9582175d3219f1ac8f974b7960f2edfc8bc03197718dc8967ba1ab\",\n    )?;\n\n    let block_id =\n        BlockId::BlockNumber { block_number: BlockNumber::try_new(354824)? };\n\n    let ret =\n        ctx.client.getProof(block_id, contract_address, vec![key]).await?;\n    assert_eq!(\n        ret.class_commitment.unwrap().as_ref(),\n        \"0x4570dad16b85ea5076806bfb74c85bbb2b38485e6f3bd1bf163ab5f9ce1de53\"\n    );\n    assert_eq!(\n        ret.state_commitment.unwrap().as_ref(),\n        \"0xd9b8e8d51f3f284e62eb8c1fd7278c20bd4c0cd3033c4cce32c513e93ed663\"\n    );\n    Ok(())\n}\n\n#[tokio::test]\n#[allow(non_snake_case)]\nasync fn test_getTransactionStatus() -\u003e Result\u003c(), Error\u003e {\n    let ctx = setup!();\n\n    let transaction_hash = TxnHash(Felt::try_new(\n        \"0x2e2a98c1731ece2691edfbb4ed9b057182cec569735bd89825f17e3b342583a\",\n    )?);\n\n    let ret = ctx.client.getTransactionStatus(transaction_hash).await?;\n    assert!(matches!(\n        ret.execution_status,\n        Some(TxnExecutionStatus::Succeeded)\n    ));\n    assert!(matches!(ret.finality_status, TxnStatus::AcceptedOnL1));\n    Ok(())\n}\n\n#[tokio::test]\n#[allow(non_snake_case)]\nasync fn test_getTransactionReceipt() -\u003e Result\u003c(), Error\u003e {\n    let ctx = setup!();\n\n    let hash =\n        \"0x4c1672e824b5cd7477fca31ee3ab5a1058534ed1820bb27abc976c2e6095151\";\n\n    let transaction_hash = TxnHash(Felt::try_new(hash)?);\n\n    let ret = ctx.client.getTransactionReceipt(transaction_hash).await?;\n    let TxnReceiptWithBlockInfo {\n        txn_receipt: TxnReceipt::InvokeTxnReceipt(ret),\n        ..\n    } = ret\n    else {\n        panic!(\"unexpected pending block\");\n    };\n    assert_eq!(ret.common_receipt_properties.transaction_hash.0.as_ref(), hash);\n    Ok(())\n}\n\n#[tokio::test]\n#[allow(non_snake_case)]\nasync fn test_getClass() -\u003e Result\u003c(), Error\u003e {\n    let ctx = setup!();\n\n    let block_id = BlockId::BlockTag(BlockTag::Latest);\n\n    let class_hash = Felt::try_new(\n        \"0xd0e183745e9dae3e4e78a8ffedcce0903fc4900beace4e0abf192d4c202da3\",\n    )?;\n\n    let ret = ctx.client.getClass(block_id, class_hash).await?;\n    let GetClassResult::DeprecatedContractClass(ret) = ret else {\n        panic!(\"unexpected contract class type\");\n    };\n\n    assert!(!ret.program.as_ref().is_empty());\n\n    assert!(matches!(ret.abi, Some(vec) if !vec.is_empty()));\n\n    assert!(\n        matches!(ret.entry_points_by_type.constructor, Some(vec) if !vec.is_empty())\n    );\n    assert!(\n        matches!(ret.entry_points_by_type.l1_handler, Some(vec) if !vec.is_empty())\n    );\n    assert!(\n        matches!(ret.entry_points_by_type.external, Some(vec) if !vec.is_empty())\n    );\n    Ok(())\n}\n\n#[tokio::test]\n#[allow(non_snake_case)]\nasync fn test_getClassAt() -\u003e Result\u003c(), Error\u003e {\n    let ctx = setup!();\n\n    let block_id = BlockId::BlockTag(BlockTag::Latest);\n\n    let contract_address = Address(Felt::try_new(\n        \"0x40688250Ef0074B4c9e1057B19F9b62139ac28179c7d35e2daE5abAD909d558\",\n    )?);\n\n    let ret = ctx.client.getClassAt(block_id, contract_address).await?;\n    let GetClassAtResult::ContractClass(ret) = ret else {\n        panic!(\"unexpected contract class type\");\n    };\n\n    assert!(!ret.abi.unwrap_or_default().is_empty());\n\n    assert_eq!(ret.contract_class_version, \"0.1.0\");\n\n    assert!(!ret.entry_points_by_type.constructor.is_empty());\n    assert!(!ret.entry_points_by_type.external.is_empty());\n    assert!(ret.entry_points_by_type.l1_handler.is_empty());\n\n    assert!(!ret.sierra_program.is_empty());\n\n    Ok(())\n}\n\n#[tokio::test]\n#[allow(non_snake_case)]\nasync fn test_getClassHashAt() -\u003e Result\u003c(), Error\u003e {\n    let ctx = setup!();\n\n    let block_id = BlockId::BlockTag(BlockTag::Latest);\n\n    let contract_address = Address(Felt::try_new(\n        \"0x7f38ab7537dbb5f8dc2d049d441f2b250c2186a13d943b8467cfa86b8dba12b\",\n    )?);\n\n    let ret = ctx.client.getClassHashAt(block_id, contract_address).await?;\n    assert_eq!(\n        ret.as_ref(),\n        \"0x1a736d6ed154502257f02b1ccdf4d9d1089f80811cd6acad48e6b6a9d1f2003\"\n    );\n    Ok(())\n}\n\n#[tokio::test]\nasync fn erc20_call() -\u003e Result\u003c(), Error\u003e {\n    let ctx = setup!();\n    let block_id = BlockId::BlockTag(BlockTag::Pending);\n    let erc20_address = Address(Felt::try_new(\n        \"0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n    )?);\n\n    let felt_name = Felt::try_new(\n        \"0x361458367e696363fbcc70777d07ebbd2394e89fd0adcaf147faccd1d294d60\",\n    )?;\n    let request_name = FunctionCall {\n        calldata: vec![],\n        contract_address: erc20_address.clone(),\n        entry_point_selector: felt_name,\n    };\n    let res_call_name = ctx.client.call(request_name, block_id.clone()).await?;\n    assert_eq!(res_call_name.len(), 1);\n    let ether = \"0x4574686572\";\n    assert_eq!(res_call_name[0].as_ref(), ether);\n\n    let felt_decimals = Felt::try_new(\n        \"0x4c4fb1ab068f6039d5780c68dd0fa2f8742cceb3426d19667778ca7f3518a9\",\n    )?;\n    let request_decimals = FunctionCall {\n        calldata: vec![],\n        contract_address: erc20_address.clone(),\n        entry_point_selector: felt_decimals,\n    };\n    let res_call_decimals =\n        ctx.client.call(request_decimals, block_id.clone()).await?;\n    assert_eq!(res_call_decimals.len(), 1);\n    let twelve = \"0x12\";\n    assert_eq!(res_call_decimals[0].as_ref(), twelve);\n\n    let felt_symbol = Felt::try_new(\n        \"0x216b05c387bab9ac31918a3e61672f4618601f3c598a2f3f2710f37053e1ea4\",\n    )?;\n    let request_symbol = FunctionCall {\n        calldata: vec![],\n        contract_address: erc20_address,\n        entry_point_selector: felt_symbol,\n    };\n    let res_call_symbol = ctx.client.call(request_symbol, block_id).await?;\n    assert_eq!(res_call_symbol.len(), 1);\n    let eth = \"0x455448\";\n    assert_eq!(res_call_symbol[0].as_ref(), eth);\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn account_call() -\u003e Result\u003c(), Error\u003e {\n    let ctx = setup!(\"sepolia\");\n    let block_id = BlockId::BlockTag(BlockTag::Pending);\n    let account_address = Address(Felt::try_new(\n        \"0x61ce2b8e048c19ee48af79a95e984769366611bb3f46c45cf70460b82efff8e\",\n    )?);\n\n    let felt_public_key = Felt::try_new(\n        \"0x3b28019ccfdbd30ffc65951d94bb85c9e2b8434111a000b5afd533ce65f57a4\",\n    )?;\n    let request_name = FunctionCall {\n        calldata: vec![],\n        contract_address: account_address.clone(),\n        entry_point_selector: felt_public_key,\n    };\n    let res_call_public_key =\n        ctx.client.call(request_name, block_id.clone()).await?;\n    assert_eq!(res_call_public_key.len(), 1);\n    let public_key =\n        \"0x145b000feec4f33c8622e91311922950d813ff8514b6a6552fc662eeb61cdf9\";\n    assert_eq!(res_call_public_key[0].as_ref(), public_key);\n\n    let interface = Felt::try_new(\n        \"0x2ceccef7f994940b3962a6c67e0ba4fcd37df7d131417c604f91e03caecc1cd\",\n    )?;\n    let felt_supports_interface = Felt::try_new(\n        \"0xfe80f537b66d12a00b6d3c072b44afbb716e78dde5c3f0ef116ee93d3e3283\",\n    )?;\n    let request_supports_interface = FunctionCall {\n        calldata: vec![interface],\n        contract_address: account_address.clone(),\n        entry_point_selector: felt_supports_interface,\n    };\n    let res_call_supports_interface =\n        ctx.client.call(request_supports_interface, block_id.clone()).await?;\n    assert_eq!(res_call_supports_interface.len(), 1);\n    assert_eq!(res_call_supports_interface[0].as_ref(), \"0x1\");\n\n    let hash = Felt::try_new(\n        \"0x259cbf64e5b2beb31cfac3b444b8dd20650e841581b25be14d5e08947e81cf2\",\n    )?;\n    let array_size = Felt::try_new(\"0x2\")?;\n    let signature_r = Felt::try_new(\n        \"0x58f1ad9bb6331bb460c80260eee0c65980b4c1a659a5d84e7e51418afdf7311\",\n    )?;\n    let signature_s = Felt::try_new(\n        \"0x74d9f54825e422fc5004533c33813ab2772057f87652e75a24e10ffac14726d\",\n    )?;\n    let felt_is_valid_signature = Felt::try_new(\n        \"0x28420862938116cb3bbdbedee07451ccc54d4e9412dbef71142ad1980a30941\",\n    )?;\n    let request_is_valid_signature = FunctionCall {\n        calldata: vec![hash, array_size, signature_r, signature_s],\n        contract_address: account_address,\n        entry_point_selector: felt_is_valid_signature,\n    };\n    let res_call_is_valid_signature =\n        ctx.client.call(request_is_valid_signature, block_id).await?;\n    assert_eq!(res_call_is_valid_signature.len(), 1);\n    let valid = \"0x56414c4944\";\n    assert_eq!(res_call_is_valid_signature[0].as_ref(), valid);\n\n    Ok(())\n}\n\n#[tokio::test]\n#[ignore = \"Needs to be run explicitly: deploys an account to the testnet\"]\nasync fn deploy_account_on_sepolia() -\u003e Result\u003c(), Error\u003e {\n    let ctx = setup!(\"sepolia\");\n\n    let account = utils::prepare_account()?;\n    scarb::compile_blocking(account.toml).await?;\n\n    let mut starkli = Starkli::new(\n        \u0026format!(\"http://127.0.0.1:{}/rpc\", ctx.server.port()),\n        \u0026account.folder,\n        PreFundedAccount::Sepolia,\n    );\n    let key = starkli.create_keystore()?;\n    let class_hash = starkli.extract_class_hash()?;\n    let address = starkli.create_account(key.clone(), class_hash).await?;\n    starkli.declare_account().await?;\n\n    let time_for_transaction_validation = time::Duration::from_secs(60);\n    thread::sleep(time_for_transaction_validation);\n\n    // Usual account deployment fee is ~1e9\n    // Added additional eth just to be safe\n    let amount_to_transfer = 1e12 as u64;\n    starkli.invoke_eth_transfer(address, amount_to_transfer).await?;\n\n    thread::sleep(time_for_transaction_validation);\n    starkli.deploy_account().await?;\n\n    // Unable to verify via beerus due to hard coded L1 state\n    // and time for newly created account to arrive on L1\n    starkli.rpc = std::env::var(\"STARKNET_SEPOLIA_URL\").ok().unwrap();\n\n    let res_id = starkli.call(address, \"id\").await?;\n    assert_eq!(res_id.len(), 2);\n    assert_eq!(res_id[0].to_string(), account.id);\n    assert_eq!(res_id[1], starknet_crypto::Felt::ZERO);\n\n    let res_public_key = starkli.call(address, \"public_key\").await?;\n    assert_eq!(res_public_key.len(), 1);\n    assert_eq!(res_public_key[0], key.verifying_key().scalar());\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","work","Work","Eiger","code","beerus","tests","starknet","constants.rs"],"content":"#[allow(dead_code)]\npub const COMPILED_ACCOUNT_CONTRACT_V2: \u0026str =\n    include_str!(\"./clob/compiled_account_contract_v2.txt\");\n#[allow(dead_code)]\npub const COMPILED_ACCOUNT_CONTRACT_V3: \u0026str =\n    include_str!(\"./clob/compiled_account_contract_v3.txt\");\n#[allow(dead_code)]\npub const DECLARE_ACCOUNT_V2: \u0026str =\n    include_str!(\"./clob/declare_account_v2.txt\");\n#[allow(dead_code)]\npub const DECLARE_ACCOUNT_V3: \u0026str =\n    include_str!(\"./clob/declare_account_v3.txt\");\n\n#[allow(dead_code)]\npub const CLASS_HASH: \u0026str =\n    \"0x6b46f84b1bbb779e588a9c5f577907c3dfb66e6b13cf4c4f480d4fb1677c2ba\";\n#[allow(dead_code)]\npub const CONTRACT_ADDRESS: \u0026str =\n    \"0x5f177e96c32bcc09607d9e2adf1864b8a8dc54c7fb5a283afac58f2b6ddc7da\";\n#[allow(dead_code)]\npub const SENDER_ADDRESS: \u0026str =\n    \"0x6162896d1d7ab204c7ccac6dd5f8e9e7c25ecd5ae4fcb4ad32e57786bb46e03\";\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","work","Work","Eiger","code","beerus","tests","starknet","katana.rs"],"content":"use std::str::FromStr;\n\nuse alloy_primitives::U256;\nuse anyhow::Result;\nuse katana_core::backend::config::{Environment, StarknetConfig};\nuse katana_core::constants::DEFAULT_SEQUENCER_ADDRESS;\n#[allow(deprecated)]\nuse katana_core::sequencer::SequencerConfig;\nuse katana_node::{start, NodeHandle};\nuse katana_primitives::block::GasPrices;\nuse katana_primitives::chain::ChainId;\nuse katana_primitives::genesis::{\n    allocation::DevAllocationsGenerator,\n    constant::DEFAULT_PREFUNDED_ACCOUNT_BALANCE, Genesis,\n};\nuse katana_rpc::config::ServerConfig;\nuse katana_rpc_api::ApiKind;\nuse starknet_types_core::felt::Felt;\nuse url::Url;\n\npub struct Katana {\n    rpc_handle: NodeHandle,\n}\n\nimpl Katana {\n    #[allow(dead_code)]\n    pub async fn init(url: \u0026str) -\u003e Result\u003cSelf\u003e {\n        let sequencer_config = get_sequencer_config();\n        let server_config = get_server_config(url)?;\n        let starknet_config = get_starknet_config();\n        let (rpc_handle, _) =\n            start(server_config, sequencer_config, starknet_config).await?;\n        Ok(Katana { rpc_handle })\n    }\n\n    #[allow(dead_code)]\n    pub fn port(\u0026self) -\u003e u16 {\n        self.rpc_handle.addr.port()\n    }\n\n    #[allow(dead_code)]\n    pub fn stop(\u0026self) -\u003e Result\u003c()\u003e {\n        self.rpc_handle.handle.stop()?;\n        Ok(())\n    }\n}\n\nimpl Drop for Katana {\n    fn drop(\u0026mut self) {\n        let _ = self.rpc_handle.handle.stop();\n    }\n}\n\n#[allow(deprecated)]\n#[allow(dead_code)]\nfn get_sequencer_config() -\u003e SequencerConfig {\n    SequencerConfig { block_time: None, no_mining: false }\n}\n\n#[allow(dead_code)]\nfn get_server_config(url: \u0026str) -\u003e Result\u003cServerConfig\u003e {\n    let url = Url::parse(url)?;\n    Ok(ServerConfig {\n        apis: vec![\n            ApiKind::Starknet,\n            ApiKind::Katana,\n            ApiKind::Torii,\n            ApiKind::Saya,\n        ],\n        port: url.port().unwrap(),\n        host: url.host().unwrap().to_string(),\n        max_connections: 100,\n        allowed_origins: None,\n        metrics: None,\n    })\n}\n\n#[allow(dead_code)]\nfn get_starknet_config() -\u003e StarknetConfig {\n    let gas_prices = GasPrices { eth: 100000000000, strk: 100000000000 };\n    let accounts = DevAllocationsGenerator::new(10)\n        .with_seed(parse_seed(\"0\"))\n        .with_balance(U256::from(DEFAULT_PREFUNDED_ACCOUNT_BALANCE))\n        .generate();\n    let mut genesis = Genesis {\n        gas_prices,\n        sequencer_address: *DEFAULT_SEQUENCER_ADDRESS,\n        ..Default::default()\n    };\n    genesis\n        .extend_allocations(accounts.into_iter().map(|(k, v)| (k, v.into())));\n\n    StarknetConfig {\n        disable_fee: true,\n        disable_validate: false,\n        fork_rpc_url: None,\n        fork_block_number: None,\n        env: Environment {\n            chain_id: ChainId::Id(Felt::from_str(\"0x4b4154414e41\").unwrap()),\n            invoke_max_steps: 1000000,\n            validate_max_steps: 1000000,\n        },\n        db_dir: None,\n        genesis,\n    }\n}\n\n#[allow(dead_code)]\nfn parse_seed(seed: \u0026str) -\u003e [u8; 32] {\n    let seed = seed.as_bytes();\n    let mut actual_seed = [0u8; 32];\n    seed.iter().enumerate().for_each(|(i, b)| actual_seed[i] = *b);\n    actual_seed\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","work","Work","Eiger","code","beerus","tests","starknet","mod.rs"],"content":"pub mod constants;\npub mod katana;\npub mod scarb;\npub mod starkli;\npub mod utils;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","work","Work","Eiger","code","beerus","tests","starknet","scarb.rs"],"content":"use anyhow::Error;\nuse scarb::{\n    core::{Config, PackageId, PackageName, SourceId, TargetKind},\n    ops::{self, CompileOpts, FeaturesOpts, FeaturesSelector},\n};\nuse semver::Version;\nuse std::{fs::canonicalize, path::PathBuf};\n\n#[allow(dead_code)]\npub async fn compile_blocking(toml: String) -\u003e Result\u003c(), Error\u003e {\n    tokio::task::spawn_blocking(move || -\u003e Result\u003c(), Error\u003e { compile(toml) })\n        .await?\n}\n\n#[allow(dead_code)]\npub fn compile(toml: String) -\u003e Result\u003c(), Error\u003e {\n    let toml_absolute = canonicalize(PathBuf::from(toml))?;\n    let opts = CompileOpts {\n        include_target_kinds: vec![],\n        exclude_target_kinds: vec![TargetKind::new(\"test\")],\n        include_target_names: vec![],\n        features: FeaturesOpts {\n            features: FeaturesSelector::Features(vec![]),\n            no_default_features: false,\n        },\n    };\n    let packages = vec![PackageId::new(\n        PackageName::new(\"account\"),\n        Version::new(0, 1, 0),\n        SourceId::for_path(toml_absolute.to_str().unwrap().into())?,\n    )];\n    let config = Config::builder(toml_absolute.to_str().unwrap()).build()?;\n    let ws = ops::read_workspace(config.manifest_path(), \u0026config)?;\n\n    scarb::ops::compile(packages, opts, \u0026ws)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","work","Work","Eiger","code","beerus","tests","starknet","starkli.rs"],"content":"use std::{fs, io::Write};\n\nuse anyhow::{anyhow, Error};\nuse clap::Parser;\nuse starkli::{\n    account::{\n        AccountConfig, AccountVariant, DeploymentStatus, OzAccountConfig,\n        UndeployedStatus,\n    },\n    signer::AnySigner,\n    utils::{Cli, Subcommands},\n};\nuse starknet::{\n    core::types::contract::SierraClass,\n    signers::{LocalWallet, Signer, SigningKey},\n};\nuse starknet_crypto::Felt;\n\n#[allow(dead_code)]\npub struct Starkli {\n    pub rpc: String,\n    account_folder: String,\n    prefunded_account: PreFundedAccount,\n    persist_logger: bool,\n}\n\n#[allow(dead_code)]\npub enum PreFundedAccount {\n    Katana,\n    Sepolia,\n}\n\nconst ACCOUNT: \u0026str = \"account.json\";\nconst COMPILED_ACCOUNT: \u0026str = \"target/dev/account_Account.contract_class.json\";\nconst KEY: \u0026str = \"key.json\";\nconst PASSWORD: \u0026str = \"password\";\n\n#[allow(dead_code)]\nimpl Starkli {\n    pub fn new(\n        rpc: \u0026str,\n        account_folder: \u0026str,\n        prefunded_account: PreFundedAccount,\n    ) -\u003e Self {\n        Self {\n            rpc: rpc.into(),\n            account_folder: account_folder.into(),\n            prefunded_account,\n            persist_logger: false,\n        }\n    }\n\n    pub fn create_keystore(\u0026self) -\u003e Result\u003cSigningKey, Error\u003e {\n        let key = SigningKey::from_random();\n        let key_file = self.account_folder.clone() + KEY;\n        key.save_as_keystore(key_file, PASSWORD)?;\n        Ok(key)\n    }\n\n    pub fn extract_class_hash(\u0026self) -\u003e Result\u003cFelt, Error\u003e {\n        let compiled = self.account_folder.clone() + COMPILED_ACCOUNT;\n        let class = serde_json::from_reader::\u003c_, SierraClass\u003e(\n            std::fs::File::open(compiled)?,\n        )?;\n        Ok(class.class_hash()?)\n    }\n\n    pub async fn create_account(\n        \u0026self,\n        key: SigningKey,\n        class_hash: Felt,\n    ) -\u003e Result\u003cFelt, Error\u003e {\n        let signer = AnySigner::LocalWallet(LocalWallet::from_signing_key(key));\n        let salt = SigningKey::from_random().secret_scalar();\n        let account_config = AccountConfig {\n            version: 1,\n            variant: AccountVariant::OpenZeppelin(OzAccountConfig {\n                version: 1,\n                public_key: signer.get_public_key().await?.scalar(),\n                legacy: false,\n            }),\n            deployment: DeploymentStatus::Undeployed(UndeployedStatus {\n                class_hash,\n                salt,\n                context: None,\n            }),\n        };\n        let target_deployment_address =\n            account_config.deploy_account_address()?;\n        let mut file =\n            std::fs::File::create(self.account_folder.clone() + ACCOUNT)?;\n        serde_json::to_writer_pretty(\u0026mut file, \u0026account_config)?;\n        file.write_all(b\"\\n\")?;\n        Ok(target_deployment_address)\n    }\n\n    pub async fn declare_account(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        let compiled_contract = self.account_folder.clone() + COMPILED_ACCOUNT;\n        let rpc = self.rpc.clone();\n        let mut input = vec![\n            \"starkli\".to_string(),\n            \"declare\".to_string(),\n            compiled_contract,\n            \"--compiler-version\".to_string(),\n            \"2.8.2\".to_string(),\n            \"--rpc\".to_string(),\n            rpc,\n        ];\n        self.setup_prefunded_account(\u0026mut input).await?;\n        self.run_command(input).await\n    }\n\n    pub async fn invoke_eth_transfer(\n        \u0026mut self,\n        to_address: Felt,\n        amount: u64,\n    ) -\u003e Result\u003c(), Error\u003e {\n        let address = format!(\"{:#064x}\", to_address);\n        let amount = format!(\"u256:{amount}\");\n        let rpc = self.rpc.clone();\n        let mut input = vec![\n            \"starkli\".to_string(),\n            \"invoke\".to_string(),\n            \"eth\".to_string(),\n            \"transfer\".to_string(),\n            address,\n            amount,\n            \"--rpc\".to_string(),\n            rpc,\n        ];\n        self.setup_prefunded_account(\u0026mut input).await?;\n        self.run_command(input).await\n    }\n\n    pub async fn deploy_account(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        let account = self.account_folder.clone() + \"account.json\";\n        let key = self.account_folder.clone() + \"key.json\";\n        let rpc = self.rpc.clone();\n        let input = vec![\n            \"starkli\".to_string(),\n            \"account\".to_string(),\n            \"deploy\".to_string(),\n            account,\n            \"--rpc\".to_string(),\n            rpc,\n            \"--keystore\".to_string(),\n            key,\n            \"--keystore-password\".to_string(),\n            \"password\".to_string(),\n            \"--skip-manual-confirmation\".to_string(),\n        ];\n        self.run_command(input).await\n    }\n\n    async fn setup_prefunded_account(\n        \u0026mut self,\n        input: \u0026mut Vec\u003cString\u003e,\n    ) -\u003e Result\u003c(), Error\u003e {\n        match self.prefunded_account {\n            PreFundedAccount::Katana =\u003e {\n                input.append(\u0026mut vec![\n                    \"--account\".to_string(),\n                    \"katana-0\".to_string(),\n                ]);\n            }\n            PreFundedAccount::Sepolia =\u003e {\n                let account = self.get_deployer_account().await?;\n                let private_key = std::env::var(\"DEPLOYER_PRIVATE_KEY\")?;\n                input.append(\u0026mut vec![\n                    \"--account\".to_string(),\n                    account,\n                    \"--private-key\".to_string(),\n                    private_key,\n                ]);\n            }\n        }\n        Ok(())\n    }\n\n    async fn get_deployer_account(\u0026mut self) -\u003e Result\u003cString, Error\u003e {\n        let account_address = std::env::var(\"DEPLOYER_ACCOUNT_ADDRESS\")?;\n        let account = self.account_folder.clone() + \"account_deployer.json\";\n        if fs::exists(account.clone())? {\n            return Ok(account);\n        }\n        let input = vec![\n            \"starkli\".to_string(),\n            \"account\".to_string(),\n            \"fetch\".to_string(),\n            account_address,\n            \"--output\".to_string(),\n            account.clone(),\n            \"--rpc\".to_string(),\n            self.rpc.clone(),\n        ];\n        self.run_command(input).await?;\n        Ok(account)\n    }\n\n    async fn run_command(\n        \u0026mut self,\n        mut input: Vec\u003cString\u003e,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if !self.persist_logger {\n            self.persist_logger = true;\n        } else {\n            input.push(\"--persist-logger\".to_string());\n        }\n        starkli::utils::run_command(Cli::parse_from(input)).await\n    }\n\n    pub async fn call(\n        \u0026self,\n        address: Felt,\n        func: \u0026str,\n    ) -\u003e Result\u003cVec\u003cFelt\u003e, Error\u003e {\n        let address = \u0026format!(\"{:#064x}\", address);\n        let input = vec![\"starkli\", \"call\", address, func, \"--rpc\", \u0026self.rpc];\n        let cli = Cli::parse_from(input);\n        let cmd = match cli.command {\n            Some(command) =\u003e match command {\n                Subcommands::Call(cmd) =\u003e cmd,\n                _ =\u003e return Err(anyhow!(\"Wrong subcommand\")),\n            },\n            None =\u003e return Err(anyhow!(\"Wrong command\")),\n        };\n        cmd.call().await\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","work","Work","Eiger","code","beerus","tests","starknet","utils.rs"],"content":"use std::fs;\n\nuse anyhow::Error;\nuse chrono;\n\nconst SOURCE_LIB: \u0026str = \"./tests/starknet/contract/account/src/lib.cairo\";\nconst SOURCE_TOML: \u0026str = \"./tests/starknet/contract/account/Scarb.toml\";\n\n#[allow(dead_code)]\npub struct AccountEnvironment {\n    pub folder: String,\n    pub toml: String,\n    pub id: String,\n}\n\n#[allow(dead_code)]\npub fn prepare_account() -\u003e Result\u003cAccountEnvironment, Error\u003e {\n    let now = chrono::offset::Local::now();\n    let id = now.format(\"%Y%m%y%H%M%S\").to_string();\n    let target = \"./target/account-\".to_string() + \u0026id + \"/\";\n    let target_lib = target.clone() + \"src/lib.cairo\";\n    let target_toml = target.clone() + \"Scarb.toml\";\n    let target_src = target.clone() + \"src\";\n\n    fs::create_dir(target.clone())?;\n    fs::create_dir(target_src)?;\n    fs::copy(SOURCE_LIB, target_lib.clone())?;\n    fs::copy(SOURCE_TOML, target_toml.clone())?;\n\n    let account_template = fs::read_to_string(target_lib.clone())?;\n    let account_new = account_template.replace(\"\u003cID\u003e\", \u0026id);\n    fs::write(target_lib, account_new)?;\n\n    Ok(AccountEnvironment { folder: target, toml: target_toml, id })\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>